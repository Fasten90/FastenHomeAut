
STM32F407DiscoHomeAut.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00002468  08000188  08000188  00010188  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000004fc  080025f0  080025f0  000125f0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08002aec  08002aec  00012aec  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08002af0  08002af0  00012af0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000504  20000000  08002af4  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .ccmram       00000000  10000000  10000000  00020504  2**0
                  CONTENTS
  7 .bss          00000440  20000504  20000504  00020504  2**2
                  ALLOC
  8 ._user_heap_stack 00000600  20000944  20000944  00020504  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  00020504  2**0
                  CONTENTS, READONLY
 10 .debug_info   0000e940  00000000  00000000  00020534  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00002acd  00000000  00000000  0002ee74  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000087a3  00000000  00000000  00031941  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 00000aa8  00000000  00000000  0003a0e8  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00001470  00000000  00000000  0003ab90  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000597f  00000000  00000000  0003c000  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00003f25  00000000  00000000  0004197f  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007e  00000000  00000000  000458a4  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00001f7c  00000000  00000000  00045924  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000188 <__do_global_dtors_aux>:
 8000188:	b510      	push	{r4, lr}
 800018a:	4c05      	ldr	r4, [pc, #20]	; (80001a0 <__do_global_dtors_aux+0x18>)
 800018c:	7823      	ldrb	r3, [r4, #0]
 800018e:	b933      	cbnz	r3, 800019e <__do_global_dtors_aux+0x16>
 8000190:	4b04      	ldr	r3, [pc, #16]	; (80001a4 <__do_global_dtors_aux+0x1c>)
 8000192:	b113      	cbz	r3, 800019a <__do_global_dtors_aux+0x12>
 8000194:	4804      	ldr	r0, [pc, #16]	; (80001a8 <__do_global_dtors_aux+0x20>)
 8000196:	f3af 8000 	nop.w
 800019a:	2301      	movs	r3, #1
 800019c:	7023      	strb	r3, [r4, #0]
 800019e:	bd10      	pop	{r4, pc}
 80001a0:	20000504 	.word	0x20000504
 80001a4:	00000000 	.word	0x00000000
 80001a8:	080025d8 	.word	0x080025d8

080001ac <frame_dummy>:
 80001ac:	b508      	push	{r3, lr}
 80001ae:	4b03      	ldr	r3, [pc, #12]	; (80001bc <frame_dummy+0x10>)
 80001b0:	b11b      	cbz	r3, 80001ba <frame_dummy+0xe>
 80001b2:	4903      	ldr	r1, [pc, #12]	; (80001c0 <frame_dummy+0x14>)
 80001b4:	4803      	ldr	r0, [pc, #12]	; (80001c4 <frame_dummy+0x18>)
 80001b6:	f3af 8000 	nop.w
 80001ba:	bd08      	pop	{r3, pc}
 80001bc:	00000000 	.word	0x00000000
 80001c0:	20000508 	.word	0x20000508
 80001c4:	080025d8 	.word	0x080025d8

080001c8 <__aeabi_d2f>:
 80001c8:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80001cc:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 80001d0:	bf24      	itt	cs
 80001d2:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 80001d6:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 80001da:	d90d      	bls.n	80001f8 <__aeabi_d2f+0x30>
 80001dc:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80001e0:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 80001e4:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 80001e8:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 80001ec:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 80001f0:	bf08      	it	eq
 80001f2:	f020 0001 	biceq.w	r0, r0, #1
 80001f6:	4770      	bx	lr
 80001f8:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 80001fc:	d121      	bne.n	8000242 <__aeabi_d2f+0x7a>
 80001fe:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000202:	bfbc      	itt	lt
 8000204:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000208:	4770      	bxlt	lr
 800020a:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800020e:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000212:	f1c2 0218 	rsb	r2, r2, #24
 8000216:	f1c2 0c20 	rsb	ip, r2, #32
 800021a:	fa10 f30c 	lsls.w	r3, r0, ip
 800021e:	fa20 f002 	lsr.w	r0, r0, r2
 8000222:	bf18      	it	ne
 8000224:	f040 0001 	orrne.w	r0, r0, #1
 8000228:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800022c:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000230:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000234:	ea40 000c 	orr.w	r0, r0, ip
 8000238:	fa23 f302 	lsr.w	r3, r3, r2
 800023c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000240:	e7cc      	b.n	80001dc <__aeabi_d2f+0x14>
 8000242:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000246:	d107      	bne.n	8000258 <__aeabi_d2f+0x90>
 8000248:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 800024c:	bf1e      	ittt	ne
 800024e:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000252:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000256:	4770      	bxne	lr
 8000258:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 800025c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000260:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000264:	4770      	bx	lr
 8000266:	bf00      	nop

08000268 <USART_Init>:
	  - Stop Bit = One Stop bit
	  - Parity = None
	  - BaudRate = 9600 baud
	  - Hardware flow control disabled (RTS and CTS signals) */
#ifdef CONFIG_MODULE_DEBUGUSART_ENABLE
	if ( UartHandle == &Debug_UartHandle)
 8000268:	4b16      	ldr	r3, [pc, #88]	; (80002c4 <USART_Init+0x5c>)
 800026a:	4298      	cmp	r0, r3

/***************************************************************************//**
 * @brief		-	USART_Init:	Inicializalja az USART periferiat
 ******************************************************************************/
void USART_Init ( UART_HandleTypeDef *UartHandle)
{
 800026c:	b510      	push	{r4, lr}
 800026e:	4604      	mov	r4, r0
	  - Stop Bit = One Stop bit
	  - Parity = None
	  - BaudRate = 9600 baud
	  - Hardware flow control disabled (RTS and CTS signals) */
#ifdef CONFIG_MODULE_DEBUGUSART_ENABLE
	if ( UartHandle == &Debug_UartHandle)
 8000270:	d00f      	beq.n	8000292 <USART_Init+0x2a>
		UartHandle->Instance        = ESP8266_USARTx;
		UartHandle->Init.BaudRate   = 9600;			// ESP8266
	}
#endif
	
	UartHandle->Init.WordLength = UART_WORDLENGTH_8B;
 8000272:	2300      	movs	r3, #0
	UartHandle->Init.StopBits   = UART_STOPBITS_1;
	UartHandle->Init.Parity     = UART_PARITY_NONE;
	UartHandle->Init.HwFlowCtl  = UART_HWCONTROL_NONE;
	UartHandle->Init.Mode       = UART_MODE_TX_RX;
 8000274:	220c      	movs	r2, #12
		UartHandle->Instance        = ESP8266_USARTx;
		UartHandle->Init.BaudRate   = 9600;			// ESP8266
	}
#endif
	
	UartHandle->Init.WordLength = UART_WORDLENGTH_8B;
 8000276:	6083      	str	r3, [r0, #8]
	UartHandle->Init.StopBits   = UART_STOPBITS_1;
 8000278:	60c3      	str	r3, [r0, #12]
	UartHandle->Init.Parity     = UART_PARITY_NONE;
 800027a:	6103      	str	r3, [r0, #16]
	UartHandle->Init.HwFlowCtl  = UART_HWCONTROL_NONE;
 800027c:	6183      	str	r3, [r0, #24]
	UartHandle->Init.Mode       = UART_MODE_TX_RX;
	UartHandle->Init.OverSampling = UART_OVERSAMPLING_16;
 800027e:	61c3      	str	r3, [r0, #28]
	
	UartHandle->Init.WordLength = UART_WORDLENGTH_8B;
	UartHandle->Init.StopBits   = UART_STOPBITS_1;
	UartHandle->Init.Parity     = UART_PARITY_NONE;
	UartHandle->Init.HwFlowCtl  = UART_HWCONTROL_NONE;
	UartHandle->Init.Mode       = UART_MODE_TX_RX;
 8000280:	6142      	str	r2, [r0, #20]
	UartHandle->Init.OverSampling = UART_OVERSAMPLING_16;

	if(HAL_UART_Init(UartHandle) == HAL_OK)
 8000282:	f001 fc13 	bl	8001aac <HAL_UART_Init>
 8000286:	b900      	cbnz	r0, 800028a <USART_Init+0x22>
 8000288:	bd10      	pop	{r4, pc}
		Error_Handler();
	}
	
	

}
 800028a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		}
#endif
	}
	else	// != HAL_OK
	{	
		Error_Handler();
 800028e:	f000 bfa5 	b.w	80011dc <Error_Handler>
	  - BaudRate = 9600 baud
	  - Hardware flow control disabled (RTS and CTS signals) */
#ifdef CONFIG_MODULE_DEBUGUSART_ENABLE
	if ( UartHandle == &Debug_UartHandle)
	{
		UartHandle->Instance        = DEBUG_USARTx;
 8000292:	4b0d      	ldr	r3, [pc, #52]	; (80002c8 <USART_Init+0x60>)
 8000294:	6003      	str	r3, [r0, #0]
		UartHandle->Init.BaudRate   = 9600;		// Monitor program
 8000296:	f44f 5116 	mov.w	r1, #9600	; 0x2580
		UartHandle->Instance        = ESP8266_USARTx;
		UartHandle->Init.BaudRate   = 9600;			// ESP8266
	}
#endif
	
	UartHandle->Init.WordLength = UART_WORDLENGTH_8B;
 800029a:	2300      	movs	r3, #0
	UartHandle->Init.StopBits   = UART_STOPBITS_1;
	UartHandle->Init.Parity     = UART_PARITY_NONE;
	UartHandle->Init.HwFlowCtl  = UART_HWCONTROL_NONE;
	UartHandle->Init.Mode       = UART_MODE_TX_RX;
 800029c:	220c      	movs	r2, #12
	  - Hardware flow control disabled (RTS and CTS signals) */
#ifdef CONFIG_MODULE_DEBUGUSART_ENABLE
	if ( UartHandle == &Debug_UartHandle)
	{
		UartHandle->Instance        = DEBUG_USARTx;
		UartHandle->Init.BaudRate   = 9600;		// Monitor program
 800029e:	6041      	str	r1, [r0, #4]
		UartHandle->Instance        = ESP8266_USARTx;
		UartHandle->Init.BaudRate   = 9600;			// ESP8266
	}
#endif
	
	UartHandle->Init.WordLength = UART_WORDLENGTH_8B;
 80002a0:	6083      	str	r3, [r0, #8]
	UartHandle->Init.StopBits   = UART_STOPBITS_1;
 80002a2:	60c3      	str	r3, [r0, #12]
	UartHandle->Init.Parity     = UART_PARITY_NONE;
 80002a4:	6103      	str	r3, [r0, #16]
	UartHandle->Init.HwFlowCtl  = UART_HWCONTROL_NONE;
 80002a6:	6183      	str	r3, [r0, #24]
	UartHandle->Init.Mode       = UART_MODE_TX_RX;
	UartHandle->Init.OverSampling = UART_OVERSAMPLING_16;
 80002a8:	61c3      	str	r3, [r0, #28]
	
	UartHandle->Init.WordLength = UART_WORDLENGTH_8B;
	UartHandle->Init.StopBits   = UART_STOPBITS_1;
	UartHandle->Init.Parity     = UART_PARITY_NONE;
	UartHandle->Init.HwFlowCtl  = UART_HWCONTROL_NONE;
	UartHandle->Init.Mode       = UART_MODE_TX_RX;
 80002aa:	6142      	str	r2, [r0, #20]
	UartHandle->Init.OverSampling = UART_OVERSAMPLING_16;

	if(HAL_UART_Init(UartHandle) == HAL_OK)
 80002ac:	f001 fbfe 	bl	8001aac <HAL_UART_Init>
 80002b0:	2800      	cmp	r0, #0
 80002b2:	d1ea      	bne.n	800028a <USART_Init+0x22>
	{	
#ifdef CONFIG_MODULE_DEBUGUSART_ENABLE
		if ( UartHandle == &Debug_UartHandle)
		{
			USART_SendEnable_flag = ENABLE;
 80002b4:	4905      	ldr	r1, [pc, #20]	; (80002cc <USART_Init+0x64>)
			__HAL_UART_CLEAR_FLAG(&Debug_UartHandle, UART_FLAG_CTS | UART_FLAG_RXNE | UART_FLAG_TXE | UART_FLAG_TC | UART_FLAG_ORE | UART_FLAG_NE | UART_FLAG_FE | UART_FLAG_PE);
 80002b6:	6823      	ldr	r3, [r4, #0]
 80002b8:	4a05      	ldr	r2, [pc, #20]	; (80002d0 <USART_Init+0x68>)
	if(HAL_UART_Init(UartHandle) == HAL_OK)
	{	
#ifdef CONFIG_MODULE_DEBUGUSART_ENABLE
		if ( UartHandle == &Debug_UartHandle)
		{
			USART_SendEnable_flag = ENABLE;
 80002ba:	2001      	movs	r0, #1
 80002bc:	7008      	strb	r0, [r1, #0]
			__HAL_UART_CLEAR_FLAG(&Debug_UartHandle, UART_FLAG_CTS | UART_FLAG_RXNE | UART_FLAG_TXE | UART_FLAG_TC | UART_FLAG_ORE | UART_FLAG_NE | UART_FLAG_FE | UART_FLAG_PE);
 80002be:	601a      	str	r2, [r3, #0]
 80002c0:	bd10      	pop	{r4, pc}
 80002c2:	bf00      	nop
 80002c4:	200007e0 	.word	0x200007e0
 80002c8:	40004400 	.word	0x40004400
 80002cc:	20000820 	.word	0x20000820
 80002d0:	fffffd10 	.word	0xfffffd10

080002d4 <HAL_UART_MspInit>:




void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
 80002d4:	b570      	push	{r4, r5, r6, lr}
	GPIO_InitTypeDef  GPIO_InitStruct;

	
#ifdef CONFIG_MODULE_DEBUGUSART_ENABLE

	if (huart == &Debug_UartHandle)
 80002d6:	4b1d      	ldr	r3, [pc, #116]	; (800034c <HAL_UART_MspInit+0x78>)
 80002d8:	4283      	cmp	r3, r0




void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
 80002da:	b088      	sub	sp, #32
	GPIO_InitTypeDef  GPIO_InitStruct;

	
#ifdef CONFIG_MODULE_DEBUGUSART_ENABLE

	if (huart == &Debug_UartHandle)
 80002dc:	d003      	beq.n	80002e6 <HAL_UART_MspInit+0x12>
		
	}
#endif
	else
	{
		Error_Handler();
 80002de:	f000 ff7d 	bl	80011dc <Error_Handler>
	}

	
}
 80002e2:	b008      	add	sp, #32
 80002e4:	bd70      	pop	{r4, r5, r6, pc}
	{
		// ##-1- Enable peripherals and GPIO Clocks #################################

		// Enable GPIO TX/RX clock
		// Enable USARTx clock
		DEBUG_USART_CLK_ENABLES();
 80002e6:	4b1a      	ldr	r3, [pc, #104]	; (8000350 <HAL_UART_MspInit+0x7c>)
		GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
		GPIO_InitStruct.Pull      = GPIO_NOPULL;
		GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
		GPIO_InitStruct.Alternate = DEBUG_USART_AF;		// It is initialie alternate function

		HAL_GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &GPIO_InitStruct);
 80002e8:	481a      	ldr	r0, [pc, #104]	; (8000354 <HAL_UART_MspInit+0x80>)
	{
		// ##-1- Enable peripherals and GPIO Clocks #################################

		// Enable GPIO TX/RX clock
		// Enable USARTx clock
		DEBUG_USART_CLK_ENABLES();
 80002ea:	2400      	movs	r4, #0
 80002ec:	9401      	str	r4, [sp, #4]
 80002ee:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80002f0:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 80002f4:	641a      	str	r2, [r3, #64]	; 0x40
 80002f6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80002f8:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 80002fc:	9201      	str	r2, [sp, #4]
 80002fe:	9a01      	ldr	r2, [sp, #4]
 8000300:	9402      	str	r4, [sp, #8]
 8000302:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000304:	f042 0201 	orr.w	r2, r2, #1
 8000308:	631a      	str	r2, [r3, #48]	; 0x30
 800030a:	6b1b      	ldr	r3, [r3, #48]	; 0x30

		// ##-2- Configure peripheral GPIO ##########################################
		// UART TX GPIO pin configuration
		GPIO_InitStruct.Pin       = DEBUG_USART_TX_GPIO_PIN;
		GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
		GPIO_InitStruct.Pull      = GPIO_NOPULL;
 800030c:	9405      	str	r4, [sp, #20]
	{
		// ##-1- Enable peripherals and GPIO Clocks #################################

		// Enable GPIO TX/RX clock
		// Enable USARTx clock
		DEBUG_USART_CLK_ENABLES();
 800030e:	f003 0301 	and.w	r3, r3, #1
 8000312:	9302      	str	r3, [sp, #8]
		// UART TX GPIO pin configuration
		GPIO_InitStruct.Pin       = DEBUG_USART_TX_GPIO_PIN;
		GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
		GPIO_InitStruct.Pull      = GPIO_NOPULL;
		GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
		GPIO_InitStruct.Alternate = DEBUG_USART_AF;		// It is initialie alternate function
 8000314:	2207      	movs	r2, #7
		DEBUG_USART_CLK_ENABLES();

		// ##-2- Configure peripheral GPIO ##########################################
		// UART TX GPIO pin configuration
		GPIO_InitStruct.Pin       = DEBUG_USART_TX_GPIO_PIN;
		GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 8000316:	2302      	movs	r3, #2
		GPIO_InitStruct.Pull      = GPIO_NOPULL;
		GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
		GPIO_InitStruct.Alternate = DEBUG_USART_AF;		// It is initialie alternate function

		HAL_GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &GPIO_InitStruct);
 8000318:	a903      	add	r1, sp, #12
		// Enable USARTx clock
		DEBUG_USART_CLK_ENABLES();

		// ##-2- Configure peripheral GPIO ##########################################
		// UART TX GPIO pin configuration
		GPIO_InitStruct.Pin       = DEBUG_USART_TX_GPIO_PIN;
 800031a:	2504      	movs	r5, #4
		GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
		GPIO_InitStruct.Pull      = GPIO_NOPULL;
		GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
		GPIO_InitStruct.Alternate = DEBUG_USART_AF;		// It is initialie alternate function
 800031c:	9207      	str	r2, [sp, #28]
		DEBUG_USART_CLK_ENABLES();

		// ##-2- Configure peripheral GPIO ##########################################
		// UART TX GPIO pin configuration
		GPIO_InitStruct.Pin       = DEBUG_USART_TX_GPIO_PIN;
		GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 800031e:	9304      	str	r3, [sp, #16]
		GPIO_InitStruct.Pull      = GPIO_NOPULL;
		GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
 8000320:	9306      	str	r3, [sp, #24]
	{
		// ##-1- Enable peripherals and GPIO Clocks #################################

		// Enable GPIO TX/RX clock
		// Enable USARTx clock
		DEBUG_USART_CLK_ENABLES();
 8000322:	9e02      	ldr	r6, [sp, #8]

		// ##-2- Configure peripheral GPIO ##########################################
		// UART TX GPIO pin configuration
		GPIO_InitStruct.Pin       = DEBUG_USART_TX_GPIO_PIN;
 8000324:	9503      	str	r5, [sp, #12]
		GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
		GPIO_InitStruct.Pull      = GPIO_NOPULL;
		GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
		GPIO_InitStruct.Alternate = DEBUG_USART_AF;		// It is initialie alternate function

		HAL_GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &GPIO_InitStruct);
 8000326:	f001 ff07 	bl	8002138 <HAL_GPIO_Init>

		// UART RX GPIO pin configuration
		GPIO_InitStruct.Pin = DEBUG_USART_RX_GPIO_PIN;
 800032a:	2308      	movs	r3, #8
		//GPIO_InitStruct.Alternate = DEBUG_USART_AF;

		HAL_GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &GPIO_InitStruct);
 800032c:	a903      	add	r1, sp, #12
 800032e:	4809      	ldr	r0, [pc, #36]	; (8000354 <HAL_UART_MspInit+0x80>)
		GPIO_InitStruct.Alternate = DEBUG_USART_AF;		// It is initialie alternate function

		HAL_GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &GPIO_InitStruct);

		// UART RX GPIO pin configuration
		GPIO_InitStruct.Pin = DEBUG_USART_RX_GPIO_PIN;
 8000330:	9303      	str	r3, [sp, #12]
		//GPIO_InitStruct.Alternate = DEBUG_USART_AF;

		HAL_GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &GPIO_InitStruct);
 8000332:	f001 ff01 	bl	8002138 <HAL_GPIO_Init>


		// ##-3- Configure the NVIC for UART ########################################
		// NVIC for USARTx

		HAL_NVIC_SetPriority(DEBUG_USARTx_IRQn, DEBUG_USART_PREEMT_PRIORITY, DEBUG_USART_SUB_PRIORITY);
 8000336:	4622      	mov	r2, r4
 8000338:	210a      	movs	r1, #10
 800033a:	2026      	movs	r0, #38	; 0x26
 800033c:	f002 f81e 	bl	800237c <HAL_NVIC_SetPriority>
		HAL_NVIC_EnableIRQ(DEBUG_USARTx_IRQn);
 8000340:	2026      	movs	r0, #38	; 0x26
 8000342:	f002 f853 	bl	80023ec <HAL_NVIC_EnableIRQ>
	{
		Error_Handler();
	}

	
}
 8000346:	b008      	add	sp, #32
 8000348:	bd70      	pop	{r4, r5, r6, pc}
 800034a:	bf00      	nop
 800034c:	200007e0 	.word	0x200007e0
 8000350:	40023800 	.word	0x40023800
 8000354:	40020000 	.word	0x40020000

08000358 <USART1_IRQHandler>:




void USART1_IRQHandler(void)
{
 8000358:	4770      	bx	lr
 800035a:	bf00      	nop

0800035c <USART2_IRQHandler>:

#ifdef CONFIG_USE_PANEL_DISCOVERY
void USART2_IRQHandler(void)
{

	HAL_UART_IRQHandler(&Debug_UartHandle);
 800035c:	4801      	ldr	r0, [pc, #4]	; (8000364 <USART2_IRQHandler+0x8>)
 800035e:	f001 bc5d 	b.w	8001c1c <HAL_UART_IRQHandler>
 8000362:	bf00      	nop
 8000364:	200007e0 	.word	0x200007e0

08000368 <HAL_UART_TxCpltCallback>:
	xSemaphoreGiveFromISR(DEBUG_USART_Tx_Semaphore,(BaseType_t *)NULL);
	#endif
	
	// Successful sending

	USART_SendEnable_flag = ENABLE;
 8000368:	4b01      	ldr	r3, [pc, #4]	; (8000370 <HAL_UART_TxCpltCallback+0x8>)
 800036a:	2201      	movs	r2, #1
 800036c:	701a      	strb	r2, [r3, #0]
 800036e:	4770      	bx	lr
 8000370:	20000820 	.word	0x20000820

08000374 <HAL_UART_RxCpltCallback>:
	#ifdef CONFIG_USE_FREERTOS
	taskDISABLE_INTERRUPTS();
	#endif

	#ifdef CONFIG_MODULE_DEBUGUSART_ENABLE
	if ( UartHandle == &Debug_UartHandle )
 8000374:	4b08      	ldr	r3, [pc, #32]	; (8000398 <HAL_UART_RxCpltCallback+0x24>)
 8000376:	4283      	cmp	r3, r0
 8000378:	d000      	beq.n	800037c <HAL_UART_RxCpltCallback+0x8>
 800037a:	4770      	bx	lr
  * @note   This example shows a simple way to report end of IT Rx transfer, and
  *         you can add your own implementation.
  * @retval None
  */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *UartHandle)
{
 800037c:	b510      	push	{r4, lr}
	if ( UartHandle == &Debug_UartHandle )
	{
		// TODO: másmilyen engedélyezõ flag kell ide
		//if ( MONITOR_CommandEnable )
		//{
			HAL_UART_Receive_IT(&Debug_UartHandle, (uint8_t *)&USART_RxBuffer[USART_RxBufferWriteCounter], RX_BUFFER_WAIT_LENGTH);
 800037e:	4c07      	ldr	r4, [pc, #28]	; (800039c <HAL_UART_RxCpltCallback+0x28>)
 8000380:	4907      	ldr	r1, [pc, #28]	; (80003a0 <HAL_UART_RxCpltCallback+0x2c>)
 8000382:	7823      	ldrb	r3, [r4, #0]
 8000384:	2201      	movs	r2, #1
 8000386:	4419      	add	r1, r3
 8000388:	f001 fbe2 	bl	8001b50 <HAL_UART_Receive_IT>
			USART_RxBufferWriteCounter++;
 800038c:	7823      	ldrb	r3, [r4, #0]
 800038e:	3301      	adds	r3, #1
 8000390:	b2db      	uxtb	r3, r3
 8000392:	7023      	strb	r3, [r4, #0]
 8000394:	bd10      	pop	{r4, pc}
 8000396:	bf00      	nop
 8000398:	200007e0 	.word	0x200007e0
 800039c:	20000520 	.word	0x20000520
 80003a0:	200005e0 	.word	0x200005e0

080003a4 <HAL_UART_ErrorCallback>:



// !! IMPORTANT !! Hiba eseten ebbe az ErrorCallback-be jutunk.
void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 80003a4:	b508      	push	{r3, lr}

#ifdef CONFIG_MODULE_DEBUGUSART_ENABLE
	if (huart->Instance == DEBUG_USARTx )
 80003a6:	6802      	ldr	r2, [r0, #0]
 80003a8:	4b0f      	ldr	r3, [pc, #60]	; (80003e8 <HAL_UART_ErrorCallback+0x44>)
 80003aa:	429a      	cmp	r2, r3
 80003ac:	d003      	beq.n	80003b6 <HAL_UART_ErrorCallback+0x12>
	{
		Error_Handler();
	}
	
	return;
}
 80003ae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

	}	
#endif
	else
	{
		Error_Handler();
 80003b2:	f000 bf13 	b.w	80011dc <Error_Handler>

		//__HAL_UART_RESET_HANDLE_STATE(&BluetoothUartHandle);
		//__HAL_UART_GET_FLAG(huart, UART_FLAG_TXE);
		//__HAL_UART_CLEAR_FLAG(&BluetoothUartHandle, UART_FLAG_CTS | UART_FLAG_RXNE | UART_FLAG_TXE | UART_FLAG_TC | UART_FLAG_ORE | UART_FLAG_NE | UART_FLAG_FE | UART_FLAG_PE);

		huart->ErrorCode = HAL_UART_ERROR_NONE;
 80003b6:	2300      	movs	r3, #0
		huart->gState = HAL_UART_STATE_READY;
 80003b8:	2120      	movs	r1, #32
		huart->RxXferSize = 0;

		//__HAL_UART_FLUSH_DRREGISTER(&BluetoothUartHandle);
		

		HAL_UART_Receive_IT(&Debug_UartHandle, (uint8_t *)&USART_RxBuffer[USART_RxBufferWriteCounter], RX_BUFFER_WAIT_LENGTH);
 80003ba:	4a0c      	ldr	r2, [pc, #48]	; (80003ec <HAL_UART_ErrorCallback+0x48>)

		//__HAL_UART_RESET_HANDLE_STATE(&BluetoothUartHandle);
		//__HAL_UART_GET_FLAG(huart, UART_FLAG_TXE);
		//__HAL_UART_CLEAR_FLAG(&BluetoothUartHandle, UART_FLAG_CTS | UART_FLAG_RXNE | UART_FLAG_TXE | UART_FLAG_TC | UART_FLAG_ORE | UART_FLAG_NE | UART_FLAG_FE | UART_FLAG_PE);

		huart->ErrorCode = HAL_UART_ERROR_NONE;
 80003bc:	63c3      	str	r3, [r0, #60]	; 0x3c
		huart->gState = HAL_UART_STATE_READY;
 80003be:	f880 1039 	strb.w	r1, [r0, #57]	; 0x39
		huart->RxXferSize = 0;

		//__HAL_UART_FLUSH_DRREGISTER(&BluetoothUartHandle);
		

		HAL_UART_Receive_IT(&Debug_UartHandle, (uint8_t *)&USART_RxBuffer[USART_RxBufferWriteCounter], RX_BUFFER_WAIT_LENGTH);
 80003c2:	7812      	ldrb	r2, [r2, #0]
 80003c4:	490a      	ldr	r1, [pc, #40]	; (80003f0 <HAL_UART_ErrorCallback+0x4c>)
		//__HAL_UART_GET_FLAG(huart, UART_FLAG_TXE);
		//__HAL_UART_CLEAR_FLAG(&BluetoothUartHandle, UART_FLAG_CTS | UART_FLAG_RXNE | UART_FLAG_TXE | UART_FLAG_TC | UART_FLAG_ORE | UART_FLAG_NE | UART_FLAG_FE | UART_FLAG_PE);

		huart->ErrorCode = HAL_UART_ERROR_NONE;
		huart->gState = HAL_UART_STATE_READY;
		huart->TxXferCount = 0;
 80003c6:	84c3      	strh	r3, [r0, #38]	; 0x26
		huart->TxXferSize = 0;
 80003c8:	8483      	strh	r3, [r0, #36]	; 0x24
		huart->RxXferCount = 0;
 80003ca:	85c3      	strh	r3, [r0, #46]	; 0x2e
		huart->RxXferSize = 0;
 80003cc:	8583      	strh	r3, [r0, #44]	; 0x2c

		//__HAL_UART_FLUSH_DRREGISTER(&BluetoothUartHandle);
		

		HAL_UART_Receive_IT(&Debug_UartHandle, (uint8_t *)&USART_RxBuffer[USART_RxBufferWriteCounter], RX_BUFFER_WAIT_LENGTH);
 80003ce:	4411      	add	r1, r2
 80003d0:	4808      	ldr	r0, [pc, #32]	; (80003f4 <HAL_UART_ErrorCallback+0x50>)
 80003d2:	2201      	movs	r2, #1
 80003d4:	f001 fbbc 	bl	8001b50 <HAL_UART_Receive_IT>
		HAL_UART_Transmit_IT(&Debug_UartHandle,(uint8_t *)"$",1);
 80003d8:	2201      	movs	r2, #1
 80003da:	4907      	ldr	r1, [pc, #28]	; (80003f8 <HAL_UART_ErrorCallback+0x54>)
 80003dc:	4805      	ldr	r0, [pc, #20]	; (80003f4 <HAL_UART_ErrorCallback+0x50>)
	{
		Error_Handler();
	}
	
	return;
}
 80003de:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

		//__HAL_UART_FLUSH_DRREGISTER(&BluetoothUartHandle);
		

		HAL_UART_Receive_IT(&Debug_UartHandle, (uint8_t *)&USART_RxBuffer[USART_RxBufferWriteCounter], RX_BUFFER_WAIT_LENGTH);
		HAL_UART_Transmit_IT(&Debug_UartHandle,(uint8_t *)"$",1);
 80003e2:	f001 bb93 	b.w	8001b0c <HAL_UART_Transmit_IT>
 80003e6:	bf00      	nop
 80003e8:	40004400 	.word	0x40004400
 80003ec:	20000520 	.word	0x20000520
 80003f0:	200005e0 	.word	0x200005e0
 80003f4:	200007e0 	.word	0x200007e0
 80003f8:	080025f0 	.word	0x080025f0

080003fc <USART_SendMessage>:
/**
 * \brief	Send string on USART
 */
// TODO: ReturnType + Check Pointer
bool USART_SendMessage ( const char *aTxBuffer )
{
 80003fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80003fe:	4607      	mov	r7, r0
	#ifdef CONFIG_MODULE_DEBUGUSART_ENABLE
	uint8_t length = 0;

	length = StringLength(aTxBuffer);
 8000400:	f000 fa94 	bl	800092c <StringLength>

	if ( length == 0 )
 8000404:	4606      	mov	r6, r0
 8000406:	b308      	cbz	r0, 800044c <USART_SendMessage+0x50>


uint8_t USART_WaitForSend (uint16_t timeoutMiliSecond)
{

	while(USART_SendEnable_flag == DISABLE && timeoutMiliSecond != 0)
 8000408:	4d11      	ldr	r5, [pc, #68]	; (8000450 <USART_SendMessage+0x54>)
 800040a:	782b      	ldrb	r3, [r5, #0]
 800040c:	f44f 74fa 	mov.w	r4, #500	; 0x1f4
 8000410:	b10b      	cbz	r3, 8000416 <USART_SendMessage+0x1a>
 8000412:	e008      	b.n	8000426 <USART_SendMessage+0x2a>
 8000414:	b13c      	cbz	r4, 8000426 <USART_SendMessage+0x2a>
	{	
		timeoutMiliSecond--;
		HAL_Delay(1);
 8000416:	2001      	movs	r0, #1
 8000418:	f002 f858 	bl	80024cc <HAL_Delay>


uint8_t USART_WaitForSend (uint16_t timeoutMiliSecond)
{

	while(USART_SendEnable_flag == DISABLE && timeoutMiliSecond != 0)
 800041c:	782b      	ldrb	r3, [r5, #0]
 800041e:	3c01      	subs	r4, #1
 8000420:	b2a4      	uxth	r4, r4
 8000422:	2b00      	cmp	r3, #0
 8000424:	d0f6      	beq.n	8000414 <USART_SendMessage+0x18>
	{
		// Take semaphore, can sending
		
		USART_SendEnable_flag = DISABLE;
		
		StrCpy((char *)USART_TxBuffer,aTxBuffer);
 8000426:	4639      	mov	r1, r7
	if ( USART_WaitForSend(500))
	#endif
	{
		// Take semaphore, can sending
		
		USART_SendEnable_flag = DISABLE;
 8000428:	2400      	movs	r4, #0
		
		StrCpy((char *)USART_TxBuffer,aTxBuffer);
 800042a:	480a      	ldr	r0, [pc, #40]	; (8000454 <USART_SendMessage+0x58>)
	if ( USART_WaitForSend(500))
	#endif
	{
		// Take semaphore, can sending
		
		USART_SendEnable_flag = DISABLE;
 800042c:	702c      	strb	r4, [r5, #0]
		
		StrCpy((char *)USART_TxBuffer,aTxBuffer);
 800042e:	f000 faa3 	bl	8000978 <StrCpy>

		// ComIT
		if(HAL_UART_Transmit_IT(&Debug_UartHandle, (uint8_t*)USART_TxBuffer, length)!= HAL_OK)
 8000432:	b2b2      	uxth	r2, r6
 8000434:	4907      	ldr	r1, [pc, #28]	; (8000454 <USART_SendMessage+0x58>)
 8000436:	4808      	ldr	r0, [pc, #32]	; (8000458 <USART_SendMessage+0x5c>)
	if ( USART_WaitForSend(500))
	#endif
	{
		// Take semaphore, can sending
		
		USART_SendEnable_flag = DISABLE;
 8000438:	4d05      	ldr	r5, [pc, #20]	; (8000450 <USART_SendMessage+0x54>)
		
		StrCpy((char *)USART_TxBuffer,aTxBuffer);

		// ComIT
		if(HAL_UART_Transmit_IT(&Debug_UartHandle, (uint8_t*)USART_TxBuffer, length)!= HAL_OK)
 800043a:	f001 fb67 	bl	8001b0c <HAL_UART_Transmit_IT>
 800043e:	b118      	cbz	r0, 8000448 <USART_SendMessage+0x4c>
			// NOTE: !!IMPORTANT!! Not sent message
			//Error_Handler();
			#ifdef CONFIG_USE_FREERTOS
			xSemaphoreGive(DEBUG_USART_Tx_Semaphore);
			#endif
			USART_SendEnable_flag = ENABLE;	// Failed to send, now we can send message
 8000440:	2301      	movs	r3, #1
 8000442:	702b      	strb	r3, [r5, #0]

			return false;
 8000444:	4620      	mov	r0, r4
 8000446:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		}
		else
		{
			// Successful sending with IT
			// Semaphore give by IT routine
			return true;
 8000448:	2001      	movs	r0, #1
 800044a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return false;
	}


	#endif // #ifdef CONFIG_MODULE_DEBUGUSART_ENABLE
}
 800044c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800044e:	bf00      	nop
 8000450:	20000820 	.word	0x20000820
 8000454:	200006e0 	.word	0x200006e0
 8000458:	200007e0 	.word	0x200007e0

0800045c <USART_SendChar>:

/**
 * \brief	Send a char on USART
 */
bool USART_SendChar ( char c )
{
 800045c:	b530      	push	{r4, r5, lr}


uint8_t USART_WaitForSend (uint16_t timeoutMiliSecond)
{

	while(USART_SendEnable_flag == DISABLE && timeoutMiliSecond != 0)
 800045e:	4d14      	ldr	r5, [pc, #80]	; (80004b0 <USART_SendChar+0x54>)

/**
 * \brief	Send a char on USART
 */
bool USART_SendChar ( char c )
{
 8000460:	b083      	sub	sp, #12


uint8_t USART_WaitForSend (uint16_t timeoutMiliSecond)
{

	while(USART_SendEnable_flag == DISABLE && timeoutMiliSecond != 0)
 8000462:	782b      	ldrb	r3, [r5, #0]
 */
bool USART_SendChar ( char c )
{
	#ifdef CONFIG_MODULE_DEBUGUSART_ENABLE
	char buf[2];
	buf[0] = c;
 8000464:	f88d 0004 	strb.w	r0, [sp, #4]
	buf[1] = '\0';
 8000468:	2200      	movs	r2, #0
 800046a:	f88d 2005 	strb.w	r2, [sp, #5]


uint8_t USART_WaitForSend (uint16_t timeoutMiliSecond)
{

	while(USART_SendEnable_flag == DISABLE && timeoutMiliSecond != 0)
 800046e:	2464      	movs	r4, #100	; 0x64
 8000470:	b10b      	cbz	r3, 8000476 <USART_SendChar+0x1a>
 8000472:	e008      	b.n	8000486 <USART_SendChar+0x2a>
 8000474:	b13c      	cbz	r4, 8000486 <USART_SendChar+0x2a>
	{	
		timeoutMiliSecond--;
		HAL_Delay(1);
 8000476:	2001      	movs	r0, #1
 8000478:	f002 f828 	bl	80024cc <HAL_Delay>


uint8_t USART_WaitForSend (uint16_t timeoutMiliSecond)
{

	while(USART_SendEnable_flag == DISABLE && timeoutMiliSecond != 0)
 800047c:	782b      	ldrb	r3, [r5, #0]
 800047e:	3c01      	subs	r4, #1
 8000480:	b2a4      	uxth	r4, r4
 8000482:	2b00      	cmp	r3, #0
 8000484:	d0f6      	beq.n	8000474 <USART_SendChar+0x18>
	#endif	
	{
		// Successful take USART semaphore
		USART_SendEnable_flag = DISABLE;

		StrCpy((char *)USART_TxBuffer,buf);
 8000486:	a901      	add	r1, sp, #4
	#else
	if ( USART_WaitForSend(100))
	#endif	
	{
		// Successful take USART semaphore
		USART_SendEnable_flag = DISABLE;
 8000488:	2400      	movs	r4, #0

		StrCpy((char *)USART_TxBuffer,buf);
 800048a:	480a      	ldr	r0, [pc, #40]	; (80004b4 <USART_SendChar+0x58>)
	#else
	if ( USART_WaitForSend(100))
	#endif	
	{
		// Successful take USART semaphore
		USART_SendEnable_flag = DISABLE;
 800048c:	702c      	strb	r4, [r5, #0]

		StrCpy((char *)USART_TxBuffer,buf);
 800048e:	f000 fa73 	bl	8000978 <StrCpy>

		if(HAL_UART_Transmit_IT(&Debug_UartHandle, (uint8_t *)USART_TxBuffer, 1)!= HAL_OK)
 8000492:	2201      	movs	r2, #1
 8000494:	4907      	ldr	r1, [pc, #28]	; (80004b4 <USART_SendChar+0x58>)
 8000496:	4808      	ldr	r0, [pc, #32]	; (80004b8 <USART_SendChar+0x5c>)
	#else
	if ( USART_WaitForSend(100))
	#endif	
	{
		// Successful take USART semaphore
		USART_SendEnable_flag = DISABLE;
 8000498:	4d05      	ldr	r5, [pc, #20]	; (80004b0 <USART_SendChar+0x54>)

		StrCpy((char *)USART_TxBuffer,buf);

		if(HAL_UART_Transmit_IT(&Debug_UartHandle, (uint8_t *)USART_TxBuffer, 1)!= HAL_OK)
 800049a:	f001 fb37 	bl	8001b0c <HAL_UART_Transmit_IT>
 800049e:	b120      	cbz	r0, 80004aa <USART_SendChar+0x4e>
			// NOTE: !! IMPORTANT!! Not sent message
			//Error_Handler();
			#ifdef CONFIG_USE_FREERTOS
			xSemaphoreGive(DEBUG_USART_Tx_Semaphore);
			#endif
			USART_SendEnable_flag = ENABLE;
 80004a0:	2301      	movs	r3, #1
			return false;
 80004a2:	4620      	mov	r0, r4
			// NOTE: !! IMPORTANT!! Not sent message
			//Error_Handler();
			#ifdef CONFIG_USE_FREERTOS
			xSemaphoreGive(DEBUG_USART_Tx_Semaphore);
			#endif
			USART_SendEnable_flag = ENABLE;
 80004a4:	702b      	strb	r3, [r5, #0]
		return false;
	}


	#endif // #ifdef CONFIG_MODULE_DEBUGUSART_ENABLE
}
 80004a6:	b003      	add	sp, #12
 80004a8:	bd30      	pop	{r4, r5, pc}
		}
		else
		{
			// Successful sending on USART
			// Semaphore will give from ISR
			return true;
 80004aa:	2001      	movs	r0, #1
		return false;
	}


	#endif // #ifdef CONFIG_MODULE_DEBUGUSART_ENABLE
}
 80004ac:	b003      	add	sp, #12
 80004ae:	bd30      	pop	{r4, r5, pc}
 80004b0:	20000820 	.word	0x20000820
 80004b4:	200006e0 	.word	0x200006e0
 80004b8:	200007e0 	.word	0x200007e0

080004bc <USART_ReceiveMessage>:
 #ifdef CONFIG_MODULE_DEBUGUSART_ENABLE
void USART_ReceiveMessage ( void )
{

	// USART - Receive Message - uzenetvaras
	HAL_UART_Receive_IT(&Debug_UartHandle, (uint8_t *)&USART_RxBuffer[USART_RxBufferWriteCounter], RX_BUFFER_WAIT_LENGTH);
 80004bc:	4b03      	ldr	r3, [pc, #12]	; (80004cc <USART_ReceiveMessage+0x10>)
 80004be:	4904      	ldr	r1, [pc, #16]	; (80004d0 <USART_ReceiveMessage+0x14>)
 80004c0:	781b      	ldrb	r3, [r3, #0]
 80004c2:	4804      	ldr	r0, [pc, #16]	; (80004d4 <USART_ReceiveMessage+0x18>)
 80004c4:	4419      	add	r1, r3
 80004c6:	2201      	movs	r2, #1
 80004c8:	f001 bb42 	b.w	8001b50 <HAL_UART_Receive_IT>
 80004cc:	20000520 	.word	0x20000520
 80004d0:	200005e0 	.word	0x200005e0
 80004d4:	200007e0 	.word	0x200007e0

080004d8 <uprintf>:



// Function: like printf(); C function
// Bemasoljuk egy stringbe a szoveget, es csak azutan kuldjuk ki
void uprintf(char * param, ...) {			// d, w, h, b, c, s, %
 80004d8:	b40f      	push	{r0, r1, r2, r3}
 80004da:	b5f0      	push	{r4, r5, r6, r7, lr}
 80004dc:	b0c3      	sub	sp, #268	; 0x10c
 80004de:	ab48      	add	r3, sp, #288	; 0x120
	char *string;
	string = TxBuffer;
	//uint8_t	length = 0;

	va_start(ap, param); 							// ap on arg
	for (p = param; *p; p++) {  	       			// p to EOS
 80004e0:	ae02      	add	r6, sp, #8



// Function: like printf(); C function
// Bemasoljuk egy stringbe a szoveget, es csak azutan kuldjuk ki
void uprintf(char * param, ...) {			// d, w, h, b, c, s, %
 80004e2:	f853 4b04 	ldr.w	r4, [r3], #4

	char *string;
	string = TxBuffer;
	//uint8_t	length = 0;

	va_start(ap, param); 							// ap on arg
 80004e6:	9301      	str	r3, [sp, #4]
	for (p = param; *p; p++) {  	       			// p to EOS
 80004e8:	7823      	ldrb	r3, [r4, #0]
 80004ea:	4635      	mov	r5, r6
 80004ec:	b1db      	cbz	r3, 8000526 <uprintf+0x4e>
					  break;

			case 'c': cval = va_arg(ap, int);						// Char
					  *string = cval;								// copy to string
					  string++;
					  *string = '\0';
 80004ee:	2700      	movs	r7, #0
 80004f0:	e004      	b.n	80004fc <uprintf+0x24>

	va_start(ap, param); 							// ap on arg
	for (p = param; *p; p++) {  	       			// p to EOS
		if (*p != '%')								// copy, if not '%'
		{
			*string = *p;							// copy to string
 80004f2:	f805 3b01 	strb.w	r3, [r5], #1
	char *string;
	string = TxBuffer;
	//uint8_t	length = 0;

	va_start(ap, param); 							// ap on arg
	for (p = param; *p; p++) {  	       			// p to EOS
 80004f6:	7863      	ldrb	r3, [r4, #1]
 80004f8:	3401      	adds	r4, #1
 80004fa:	b1a3      	cbz	r3, 8000526 <uprintf+0x4e>
		if (*p != '%')								// copy, if not '%'
 80004fc:	2b25      	cmp	r3, #37	; 0x25
 80004fe:	d1f8      	bne.n	80004f2 <uprintf+0x1a>
		{
			*string = *p;							// copy to string
			string++;
		}
		else            							// there is %, working
		{ switch(*++p)
 8000500:	7862      	ldrb	r2, [r4, #1]
 8000502:	f1a2 0362 	sub.w	r3, r2, #98	; 0x62
 8000506:	3401      	adds	r4, #1
 8000508:	2b15      	cmp	r3, #21
 800050a:	d871      	bhi.n	80005f0 <uprintf+0x118>
 800050c:	e8df f003 	tbb	[pc, r3]
 8000510:	70535c66 	.word	0x70535c66
 8000514:	70367040 	.word	0x70367040
 8000518:	70707070 	.word	0x70707070
 800051c:	70707070 	.word	0x70707070
 8000520:	1f702870 	.word	0x1f702870
 8000524:	1570      	.short	0x1570
		  }
		}
	}
	va_end(ap);						 							// Cleaning after end

	*string = '\0';												// string's end
 8000526:	2300      	movs	r3, #0

	USART_SendMessage(TxBuffer);							// Send on Usart
 8000528:	4630      	mov	r0, r6
		  }
		}
	}
	va_end(ap);						 							// Cleaning after end

	*string = '\0';												// string's end
 800052a:	702b      	strb	r3, [r5, #0]

	USART_SendMessage(TxBuffer);							// Send on Usart
 800052c:	f7ff ff66 	bl	80003fc <USART_SendMessage>
}
 8000530:	b043      	add	sp, #268	; 0x10c
 8000532:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8000536:	b004      	add	sp, #16
 8000538:	4770      	bx	lr

			case 'u': uival = va_arg(ap, int);						// unsigned
					  string += UnsignedDecimalToString(uival,string);
					  break;

			case 'w': uival = va_arg(ap, unsigned int);				// Hex // 32 bits	// 8 hex	// 4 byte
 800053a:	9b01      	ldr	r3, [sp, #4]
 800053c:	1d19      	adds	r1, r3, #4
					  string += DecimalToHexaString(uival,4,string);// copy to string
 800053e:	462a      	mov	r2, r5

			case 'u': uival = va_arg(ap, int);						// unsigned
					  string += UnsignedDecimalToString(uival,string);
					  break;

			case 'w': uival = va_arg(ap, unsigned int);				// Hex // 32 bits	// 8 hex	// 4 byte
 8000540:	9101      	str	r1, [sp, #4]
					  string += DecimalToHexaString(uival,4,string);// copy to string
 8000542:	6818      	ldr	r0, [r3, #0]
 8000544:	2104      	movs	r1, #4
 8000546:	f000 f8c1 	bl	80006cc <DecimalToHexaString>
 800054a:	4405      	add	r5, r0
					  break;
 800054c:	e7d3      	b.n	80004f6 <uprintf+0x1e>
		  {
			case 'd': ival = va_arg(ap, int);						// Decimal
					  string += SignedDecimalToString(ival,string);
					  break;

			case 'u': uival = va_arg(ap, int);						// unsigned
 800054e:	9b01      	ldr	r3, [sp, #4]
					  string += UnsignedDecimalToString(uival,string);
 8000550:	4629      	mov	r1, r5
		  {
			case 'd': ival = va_arg(ap, int);						// Decimal
					  string += SignedDecimalToString(ival,string);
					  break;

			case 'u': uival = va_arg(ap, int);						// unsigned
 8000552:	1d1a      	adds	r2, r3, #4
					  string += UnsignedDecimalToString(uival,string);
 8000554:	6818      	ldr	r0, [r3, #0]
		  {
			case 'd': ival = va_arg(ap, int);						// Decimal
					  string += SignedDecimalToString(ival,string);
					  break;

			case 'u': uival = va_arg(ap, int);						// unsigned
 8000556:	9201      	str	r2, [sp, #4]
					  string += UnsignedDecimalToString(uival,string);
 8000558:	f000 f880 	bl	800065c <UnsignedDecimalToString>
 800055c:	4405      	add	r5, r0
					  break;
 800055e:	e7ca      	b.n	80004f6 <uprintf+0x1e>
					  //string += FloatToString(ival,string,6);
					  //flval = va_arg(ap, float);					// GOOD, but warning
					  flval = va_arg(ap, double);
					  string += FloatToString(flval,string,6);
					  break;
			case 's': for(sval = va_arg(ap,char*); *sval; sval++)	// String
 8000560:	9901      	ldr	r1, [sp, #4]
 8000562:	680a      	ldr	r2, [r1, #0]
 8000564:	7813      	ldrb	r3, [r2, #0]
 8000566:	3104      	adds	r1, #4
 8000568:	9101      	str	r1, [sp, #4]
 800056a:	2b00      	cmp	r3, #0
 800056c:	d0c3      	beq.n	80004f6 <uprintf+0x1e>
					  {
						*string = *sval;							// copy to string
 800056e:	f805 3b01 	strb.w	r3, [r5], #1
					  //string += FloatToString(ival,string,6);
					  //flval = va_arg(ap, float);					// GOOD, but warning
					  flval = va_arg(ap, double);
					  string += FloatToString(flval,string,6);
					  break;
			case 's': for(sval = va_arg(ap,char*); *sval; sval++)	// String
 8000572:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8000576:	2b00      	cmp	r3, #0
 8000578:	d1f9      	bne.n	800056e <uprintf+0x96>
 800057a:	e7bc      	b.n	80004f6 <uprintf+0x1e>

			case 'w': uival = va_arg(ap, unsigned int);				// Hex // 32 bits	// 8 hex	// 4 byte
					  string += DecimalToHexaString(uival,4,string);// copy to string
					  break;

			case 'h': ival = va_arg(ap, int);						// Hex // 16 bits	// 4 hex	// 2 byte
 800057c:	9b01      	ldr	r3, [sp, #4]
 800057e:	1d19      	adds	r1, r3, #4
					  string += DecimalToHexaString(ival,2,string);	// copy to string
 8000580:	462a      	mov	r2, r5

			case 'w': uival = va_arg(ap, unsigned int);				// Hex // 32 bits	// 8 hex	// 4 byte
					  string += DecimalToHexaString(uival,4,string);// copy to string
					  break;

			case 'h': ival = va_arg(ap, int);						// Hex // 16 bits	// 4 hex	// 2 byte
 8000582:	9101      	str	r1, [sp, #4]
					  string += DecimalToHexaString(ival,2,string);	// copy to string
 8000584:	6818      	ldr	r0, [r3, #0]
 8000586:	2102      	movs	r1, #2
 8000588:	f000 f8a0 	bl	80006cc <DecimalToHexaString>
 800058c:	4405      	add	r5, r0
					  break;
 800058e:	e7b2      	b.n	80004f6 <uprintf+0x1e>
					  *string = '\0';
					  break;
			case 'f': //flval = va_arg(ap, float);					// float
					  //string += FloatToString(ival,string,6);
					  //flval = va_arg(ap, float);					// GOOD, but warning
					  flval = va_arg(ap, double);
 8000590:	9b01      	ldr	r3, [sp, #4]
 8000592:	3307      	adds	r3, #7
 8000594:	f023 0307 	bic.w	r3, r3, #7
 8000598:	f103 0208 	add.w	r2, r3, #8
					  string += FloatToString(flval,string,6);
 800059c:	e9d3 0100 	ldrd	r0, r1, [r3]
					  *string = '\0';
					  break;
			case 'f': //flval = va_arg(ap, float);					// float
					  //string += FloatToString(ival,string,6);
					  //flval = va_arg(ap, float);					// GOOD, but warning
					  flval = va_arg(ap, double);
 80005a0:	9201      	str	r2, [sp, #4]
					  string += FloatToString(flval,string,6);
 80005a2:	f7ff fe11 	bl	80001c8 <__aeabi_d2f>
 80005a6:	2106      	movs	r1, #6
 80005a8:	ee00 0a10 	vmov	s0, r0
 80005ac:	4628      	mov	r0, r5
 80005ae:	f000 f8ab 	bl	8000708 <FloatToString>
 80005b2:	4405      	add	r5, r0
					  break;
 80005b4:	e79f      	b.n	80004f6 <uprintf+0x1e>
			string++;
		}
		else            							// there is %, working
		{ switch(*++p)
		  {
			case 'd': ival = va_arg(ap, int);						// Decimal
 80005b6:	9b01      	ldr	r3, [sp, #4]
					  string += SignedDecimalToString(ival,string);
 80005b8:	4629      	mov	r1, r5
			string++;
		}
		else            							// there is %, working
		{ switch(*++p)
		  {
			case 'd': ival = va_arg(ap, int);						// Decimal
 80005ba:	1d1a      	adds	r2, r3, #4
					  string += SignedDecimalToString(ival,string);
 80005bc:	6818      	ldr	r0, [r3, #0]
			string++;
		}
		else            							// there is %, working
		{ switch(*++p)
		  {
			case 'd': ival = va_arg(ap, int);						// Decimal
 80005be:	9201      	str	r2, [sp, #4]
					  string += SignedDecimalToString(ival,string);
 80005c0:	f000 f81a 	bl	80005f8 <SignedDecimalToString>
 80005c4:	4405      	add	r5, r0
					  break;
 80005c6:	e796      	b.n	80004f6 <uprintf+0x1e>

			case 'b': ival = va_arg(ap, int);						// Hex	// 8 bits	// 2 hex	// 1 byte
					  string += DecimalToHexaString(ival,1,string);	// copy to string
					  break;

			case 'c': cval = va_arg(ap, int);						// Char
 80005c8:	9b01      	ldr	r3, [sp, #4]
					  *string = cval;								// copy to string
 80005ca:	462a      	mov	r2, r5
 80005cc:	6819      	ldr	r1, [r3, #0]
 80005ce:	f802 1b01 	strb.w	r1, [r2], #1

			case 'b': ival = va_arg(ap, int);						// Hex	// 8 bits	// 2 hex	// 1 byte
					  string += DecimalToHexaString(ival,1,string);	// copy to string
					  break;

			case 'c': cval = va_arg(ap, int);						// Char
 80005d2:	3304      	adds	r3, #4
					  *string = cval;								// copy to string
					  string++;
					  *string = '\0';
 80005d4:	706f      	strb	r7, [r5, #1]

			case 'b': ival = va_arg(ap, int);						// Hex	// 8 bits	// 2 hex	// 1 byte
					  string += DecimalToHexaString(ival,1,string);	// copy to string
					  break;

			case 'c': cval = va_arg(ap, int);						// Char
 80005d6:	9301      	str	r3, [sp, #4]
					  *string = cval;								// copy to string
					  string++;
 80005d8:	4615      	mov	r5, r2
					  *string = '\0';
					  break;
 80005da:	e78c      	b.n	80004f6 <uprintf+0x1e>

			case 'h': ival = va_arg(ap, int);						// Hex // 16 bits	// 4 hex	// 2 byte
					  string += DecimalToHexaString(ival,2,string);	// copy to string
					  break;

			case 'b': ival = va_arg(ap, int);						// Hex	// 8 bits	// 2 hex	// 1 byte
 80005dc:	9b01      	ldr	r3, [sp, #4]
 80005de:	1d19      	adds	r1, r3, #4
					  string += DecimalToHexaString(ival,1,string);	// copy to string
 80005e0:	462a      	mov	r2, r5

			case 'h': ival = va_arg(ap, int);						// Hex // 16 bits	// 4 hex	// 2 byte
					  string += DecimalToHexaString(ival,2,string);	// copy to string
					  break;

			case 'b': ival = va_arg(ap, int);						// Hex	// 8 bits	// 2 hex	// 1 byte
 80005e2:	9101      	str	r1, [sp, #4]
					  string += DecimalToHexaString(ival,1,string);	// copy to string
 80005e4:	6818      	ldr	r0, [r3, #0]
 80005e6:	2101      	movs	r1, #1
 80005e8:	f000 f870 	bl	80006cc <DecimalToHexaString>
 80005ec:	4405      	add	r5, r0
					  break;
 80005ee:	e782      	b.n	80004f6 <uprintf+0x1e>
						*string = *sval;							// copy to string
						string++;
					  }
					  break;

			default:  *string = *p;									// Other, for example: '%'
 80005f0:	f805 2b01 	strb.w	r2, [r5], #1
					  string++;
					  break;
 80005f4:	e77f      	b.n	80004f6 <uprintf+0x1e>
 80005f6:	bf00      	nop

080005f8 <SignedDecimalToString>:
uint8_t SignedDecimalToString (int32_t value, char *string)
{
	uint8_t length = 0;
	
	// Check pointer
	if (string == NULL)
 80005f8:	b351      	cbz	r1, 8000650 <SignedDecimalToString+0x58>
	{
		return 0;
	}

	if (value < 0)	// if negative decimal num
 80005fa:	2800      	cmp	r0, #0
 * \brief	Convert signed decimal to string
 * \note	Only max INT_MAX / 2 number can be converted
 * \return	created string length
 */
uint8_t SignedDecimalToString (int32_t value, char *string)
{
 80005fc:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (string == NULL)
	{
		return 0;
	}

	if (value < 0)	// if negative decimal num
 80005fe:	db21      	blt.n	8000644 <SignedDecimalToString+0x4c>
 8000600:	2200      	movs	r2, #0
 * \note	Only max INT_MAX / 2 number can be converted
 * \return	created string length
 */
uint8_t SignedDecimalToString (int32_t value, char *string)
{
	uint8_t length = 0;
 8000602:	4694      	mov	ip, r2
{

	uint8_t length = 0;

	// Largest num: 1xxxxxx...
	uint32_t decade = 1000000000;
 8000604:	4b13      	ldr	r3, [pc, #76]	; (8000654 <SignedDecimalToString+0x5c>)

		// Value - first digit
		value %= decade;

		// /10
		decade /= 10;
 8000606:	4f14      	ldr	r7, [pc, #80]	; (8000658 <SignedDecimalToString+0x60>)
	{
		string[length++] = '-';
		value = (uint32_t) (value * (-1));// Sign +
	}

	return (length + UnsignedDecimalToString (value,&string[length]));
 8000608:	4411      	add	r1, r2
 * \return	created string length
 */
uint8_t UnsignedDecimalToString (uint32_t value, char *string)
{

	uint8_t length = 0;
 800060a:	2600      	movs	r6, #0
	{
		string[length++] = '-';
		value = (uint32_t) (value * (-1));// Sign +
	}

	return (length + UnsignedDecimalToString (value,&string[length]));
 800060c:	2209      	movs	r2, #9
	// Largest num: 1xxxxxx...
	uint32_t decade = 1000000000;

	while (decade > 1)
	{
		if (value >= decade)
 800060e:	4283      	cmp	r3, r0
		{
			// Put first digit
			string[length++] = ((value/decade) + '0');
 8000610:	fbb0 f4f3 	udiv	r4, r0, r3
	// Largest num: 1xxxxxx...
	uint32_t decade = 1000000000;

	while (decade > 1)
	{
		if (value >= decade)
 8000614:	d805      	bhi.n	8000622 <SignedDecimalToString+0x2a>
		{
			// Put first digit
			string[length++] = ((value/decade) + '0');
 8000616:	1c75      	adds	r5, r6, #1
 8000618:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 800061c:	f801 e006 	strb.w	lr, [r1, r6]
 8000620:	b2ee      	uxtb	r6, r5

		// Value - first digit
		value %= decade;

		// /10
		decade /= 10;
 8000622:	fba7 e503 	umull	lr, r5, r7, r3
	uint8_t length = 0;

	// Largest num: 1xxxxxx...
	uint32_t decade = 1000000000;

	while (decade > 1)
 8000626:	3a01      	subs	r2, #1
			// Put first digit
			string[length++] = ((value/decade) + '0');
		}

		// Value - first digit
		value %= decade;
 8000628:	fb03 0014 	mls	r0, r3, r4, r0

		// /10
		decade /= 10;
 800062c:	ea4f 03d5 	mov.w	r3, r5, lsr #3
	uint8_t length = 0;

	// Largest num: 1xxxxxx...
	uint32_t decade = 1000000000;

	while (decade > 1)
 8000630:	d1ed      	bne.n	800060e <SignedDecimalToString+0x16>
		// /10
		decade /= 10;
	}

	// Last digit
	string[length++] = (value+ '0');
 8000632:	1c74      	adds	r4, r6, #1
 8000634:	b2e4      	uxtb	r4, r4
 8000636:	3030      	adds	r0, #48	; 0x30
 8000638:	5588      	strb	r0, [r1, r6]

	// End character
	string[length] = '\0';
 800063a:	550a      	strb	r2, [r1, r4]
	{
		string[length++] = '-';
		value = (uint32_t) (value * (-1));// Sign +
	}

	return (length + UnsignedDecimalToString (value,&string[length]));
 800063c:	eb0c 0304 	add.w	r3, ip, r4
 8000640:	b2d8      	uxtb	r0, r3
 8000642:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return 0;
	}

	if (value < 0)	// if negative decimal num
	{
		string[length++] = '-';
 8000644:	232d      	movs	r3, #45	; 0x2d
		value = (uint32_t) (value * (-1));// Sign +
 8000646:	2201      	movs	r2, #1
 8000648:	4240      	negs	r0, r0
		return 0;
	}

	if (value < 0)	// if negative decimal num
	{
		string[length++] = '-';
 800064a:	700b      	strb	r3, [r1, #0]
 800064c:	4694      	mov	ip, r2
 800064e:	e7d9      	b.n	8000604 <SignedDecimalToString+0xc>
	uint8_t length = 0;
	
	// Check pointer
	if (string == NULL)
	{
		return 0;
 8000650:	4608      	mov	r0, r1
 8000652:	4770      	bx	lr
 8000654:	3b9aca00 	.word	0x3b9aca00
 8000658:	cccccccd 	.word	0xcccccccd

0800065c <UnsignedDecimalToString>:
/*
 * \brief	Convert unsigned decimal to string
 * \return	created string length
 */
uint8_t UnsignedDecimalToString (uint32_t value, char *string)
{
 800065c:	b5f0      	push	{r4, r5, r6, r7, lr}

	uint8_t length = 0;

	// Largest num: 1xxxxxx...
	uint32_t decade = 1000000000;
 800065e:	4b0e      	ldr	r3, [pc, #56]	; (8000698 <UnsignedDecimalToString+0x3c>)

		// Value - first digit
		value %= decade;

		// /10
		decade /= 10;
 8000660:	4f0e      	ldr	r7, [pc, #56]	; (800069c <UnsignedDecimalToString+0x40>)
/*
 * \brief	Convert unsigned decimal to string
 * \return	created string length
 */
uint8_t UnsignedDecimalToString (uint32_t value, char *string)
{
 8000662:	2209      	movs	r2, #9

	uint8_t length = 0;
 8000664:	2600      	movs	r6, #0
	// Largest num: 1xxxxxx...
	uint32_t decade = 1000000000;

	while (decade > 1)
	{
		if (value >= decade)
 8000666:	4298      	cmp	r0, r3
		{
			// Put first digit
			string[length++] = ((value/decade) + '0');
 8000668:	fbb0 f4f3 	udiv	r4, r0, r3
	// Largest num: 1xxxxxx...
	uint32_t decade = 1000000000;

	while (decade > 1)
	{
		if (value >= decade)
 800066c:	d305      	bcc.n	800067a <UnsignedDecimalToString+0x1e>
		{
			// Put first digit
			string[length++] = ((value/decade) + '0');
 800066e:	1c75      	adds	r5, r6, #1
 8000670:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 8000674:	f801 e006 	strb.w	lr, [r1, r6]
 8000678:	b2ee      	uxtb	r6, r5

		// Value - first digit
		value %= decade;

		// /10
		decade /= 10;
 800067a:	fba7 e503 	umull	lr, r5, r7, r3
	uint8_t length = 0;

	// Largest num: 1xxxxxx...
	uint32_t decade = 1000000000;

	while (decade > 1)
 800067e:	3a01      	subs	r2, #1
			// Put first digit
			string[length++] = ((value/decade) + '0');
		}

		// Value - first digit
		value %= decade;
 8000680:	fb03 0014 	mls	r0, r3, r4, r0

		// /10
		decade /= 10;
 8000684:	ea4f 03d5 	mov.w	r3, r5, lsr #3
	uint8_t length = 0;

	// Largest num: 1xxxxxx...
	uint32_t decade = 1000000000;

	while (decade > 1)
 8000688:	d1ed      	bne.n	8000666 <UnsignedDecimalToString+0xa>
		// /10
		decade /= 10;
	}

	// Last digit
	string[length++] = (value+ '0');
 800068a:	1c73      	adds	r3, r6, #1
 800068c:	b2db      	uxtb	r3, r3
 800068e:	3030      	adds	r0, #48	; 0x30
 8000690:	5588      	strb	r0, [r1, r6]

	// End character
	string[length] = '\0';

	return length;
}
 8000692:	4618      	mov	r0, r3

	// Last digit
	string[length++] = (value+ '0');

	// End character
	string[length] = '\0';
 8000694:	54ca      	strb	r2, [r1, r3]

	return length;
}
 8000696:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000698:	3b9aca00 	.word	0x3b9aca00
 800069c:	cccccccd 	.word	0xcccccccd

080006a0 <ByteToHexaString>:
{
	uint8_t length = 0;
	uint8_t octet;

	// First octet
	octet = (byte >> 4);
 80006a0:	0903      	lsrs	r3, r0, #4
 * \return	character (octet)
 */
char OctetToChar (uint8_t octet)
{
	char convertedOctet;
	if ((octet >= 0) && (octet <= 9))
 80006a2:	2b09      	cmp	r3, #9
	// First octet
	octet = (byte >> 4);
	string[length++] = OctetToChar (octet);

	// Second octet
	octet = (byte & 0x0F);
 80006a4:	f000 000f 	and.w	r0, r0, #15
{
	char convertedOctet;
	if ((octet >= 0) && (octet <= 9))
	{
		// 0- 9
		convertedOctet = (octet + '0');
 80006a8:	bf94      	ite	ls
 80006aa:	3330      	addls	r3, #48	; 0x30
	}
	else if ((octet >= 10) && (octet <= 15))
	{
		// A-F
		convertedOctet = (octet - 10 + 'A');
 80006ac:	3337      	addhi	r3, #55	; 0x37
 * \return	character (octet)
 */
char OctetToChar (uint8_t octet)
{
	char convertedOctet;
	if ((octet >= 0) && (octet <= 9))
 80006ae:	2809      	cmp	r0, #9
	uint8_t length = 0;
	uint8_t octet;

	// First octet
	octet = (byte >> 4);
	string[length++] = OctetToChar (octet);
 80006b0:	700b      	strb	r3, [r1, #0]
 * \return	character (octet)
 */
char OctetToChar (uint8_t octet)
{
	char convertedOctet;
	if ((octet >= 0) && (octet <= 9))
 80006b2:	d805      	bhi.n	80006c0 <ByteToHexaString+0x20>
	{
		// 0- 9
		convertedOctet = (octet + '0');
 80006b4:	3030      	adds	r0, #48	; 0x30
	// Second octet
	octet = (byte & 0x0F);
	string[length++] = OctetToChar (octet);

	// Put end char
	string[length] = '\0';
 80006b6:	2300      	movs	r3, #0
	octet = (byte >> 4);
	string[length++] = OctetToChar (octet);

	// Second octet
	octet = (byte & 0x0F);
	string[length++] = OctetToChar (octet);
 80006b8:	7048      	strb	r0, [r1, #1]

	// Put end char
	string[length] = '\0';
 80006ba:	708b      	strb	r3, [r1, #2]

	return length;

}
 80006bc:	2002      	movs	r0, #2
 80006be:	4770      	bx	lr
		convertedOctet = (octet + '0');
	}
	else if ((octet >= 10) && (octet <= 15))
	{
		// A-F
		convertedOctet = (octet - 10 + 'A');
 80006c0:	3037      	adds	r0, #55	; 0x37
	// Second octet
	octet = (byte & 0x0F);
	string[length++] = OctetToChar (octet);

	// Put end char
	string[length] = '\0';
 80006c2:	2300      	movs	r3, #0
	octet = (byte >> 4);
	string[length++] = OctetToChar (octet);

	// Second octet
	octet = (byte & 0x0F);
	string[length++] = OctetToChar (octet);
 80006c4:	7048      	strb	r0, [r1, #1]

	// Put end char
	string[length] = '\0';
 80006c6:	708b      	strb	r3, [r1, #2]

	return length;

}
 80006c8:	2002      	movs	r0, #2
 80006ca:	4770      	bx	lr

080006cc <DecimalToHexaString>:
/*
 * \brief	Convert value to hexadecimalstring
 * \return	created string length
 */
uint8_t DecimalToHexaString (uint32_t value, uint8_t ByteNum, char *string)
{
 80006cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t i;
	uint8_t length = 0;

	// Check parameters
	if ((ByteNum > 4) || (ByteNum == 0))
 80006ce:	1e4d      	subs	r5, r1, #1
 80006d0:	b2ee      	uxtb	r6, r5
 80006d2:	2e03      	cmp	r6, #3
 80006d4:	d816      	bhi.n	8000704 <DecimalToHexaString+0x38>
 80006d6:	f101 5100 	add.w	r1, r1, #536870912	; 0x20000000
 80006da:	3902      	subs	r1, #2
 80006dc:	1b89      	subs	r1, r1, r6
 80006de:	4607      	mov	r7, r0
 80006e0:	00ce      	lsls	r6, r1, #3
 80006e2:	00ed      	lsls	r5, r5, #3
 80006e4:	2400      	movs	r4, #0

	for (i = 0; i < ByteNum; i++)
	{
		// Convert next byte
		uint8_t byte = (uint8_t)( value >> ((ByteNum-i-1)*8) );
		length += ByteToHexaString (byte,  string);
 80006e6:	fa27 f005 	lsr.w	r0, r7, r5
 80006ea:	b2c0      	uxtb	r0, r0
 80006ec:	4611      	mov	r1, r2
 80006ee:	f7ff ffd7 	bl	80006a0 <ByteToHexaString>
 80006f2:	3d08      	subs	r5, #8
 80006f4:	4420      	add	r0, r4
	if ((ByteNum > 4) || (ByteNum == 0))
	{
		return 0;
	}

	for (i = 0; i < ByteNum; i++)
 80006f6:	42b5      	cmp	r5, r6
	{
		// Convert next byte
		uint8_t byte = (uint8_t)( value >> ((ByteNum-i-1)*8) );
		length += ByteToHexaString (byte,  string);
 80006f8:	b2c4      	uxtb	r4, r0
	if ((ByteNum > 4) || (ByteNum == 0))
	{
		return 0;
	}

	for (i = 0; i < ByteNum; i++)
 80006fa:	d1f4      	bne.n	80006e6 <DecimalToHexaString+0x1a>
		// Convert next byte
		uint8_t byte = (uint8_t)( value >> ((ByteNum-i-1)*8) );
		length += ByteToHexaString (byte,  string);
	}

	string[length] = '\0';
 80006fc:	2300      	movs	r3, #0
 80006fe:	5513      	strb	r3, [r2, r4]

	for (i = 0; i < ByteNum; i++)
	{
		// Convert next byte
		uint8_t byte = (uint8_t)( value >> ((ByteNum-i-1)*8) );
		length += ByteToHexaString (byte,  string);
 8000700:	4620      	mov	r0, r4
	}

	string[length] = '\0';

	return length;
 8000702:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint8_t length = 0;

	// Check parameters
	if ((ByteNum > 4) || (ByteNum == 0))
	{
		return 0;
 8000704:	2000      	movs	r0, #0

	string[length] = '\0';

	return length;

}
 8000706:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08000708 <FloatToString>:
/*
 * \brief	Convert float value to String
 * \return	Length
 */
uint8_t FloatToString (float value, char *string, uint8_t fractionLength)
{
 8000708:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint8_t length = 0;
	uint32_t calcValue;


	// Sign
	if (value < 0)
 800070c:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8000710:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
/*
 * \brief	Convert float value to String
 * \return	Length
 */
uint8_t FloatToString (float value, char *string, uint8_t fractionLength)
{
 8000714:	b083      	sub	sp, #12
 8000716:	4686      	mov	lr, r0
	uint8_t length = 0;
	uint32_t calcValue;


	// Sign
	if (value < 0)
 8000718:	d454      	bmi.n	80007c4 <FloatToString+0xbc>
 800071a:	f04f 0c00 	mov.w	ip, #0
 * \return	Length
 */
uint8_t FloatToString (float value, char *string, uint8_t fractionLength)
{
	uint8_t num;
	uint8_t length = 0;
 800071e:	46e1      	mov	r9, ip
		value = (value * (-1));	// make positive
	}


	// Integer
	calcValue = (uint32_t)value;
 8000720:	eefc 7ac0 	vcvt.u32.f32	s15, s0
{

	uint8_t length = 0;

	// Largest num: 1xxxxxx...
	uint32_t decade = 1000000000;
 8000724:	4b2b      	ldr	r3, [pc, #172]	; (80007d4 <FloatToString+0xcc>)

		// Value - first digit
		value %= decade;

		// /10
		decade /= 10;
 8000726:	482c      	ldr	r0, [pc, #176]	; (80007d8 <FloatToString+0xd0>)
	}


	// Integer
	calcValue = (uint32_t)value;
	length += UnsignedDecimalToString(calcValue,&string[length]);
 8000728:	ee17 2a90 	vmov	r2, s15
 800072c:	44f4      	add	ip, lr
 800072e:	2409      	movs	r4, #9
 * \return	created string length
 */
uint8_t UnsignedDecimalToString (uint32_t value, char *string)
{

	uint8_t length = 0;
 8000730:	2700      	movs	r7, #0
	// Largest num: 1xxxxxx...
	uint32_t decade = 1000000000;

	while (decade > 1)
	{
		if (value >= decade)
 8000732:	429a      	cmp	r2, r3
		{
			// Put first digit
			string[length++] = ((value/decade) + '0');
 8000734:	fbb2 f5f3 	udiv	r5, r2, r3
	// Largest num: 1xxxxxx...
	uint32_t decade = 1000000000;

	while (decade > 1)
	{
		if (value >= decade)
 8000738:	d305      	bcc.n	8000746 <FloatToString+0x3e>
		{
			// Put first digit
			string[length++] = ((value/decade) + '0');
 800073a:	1c7e      	adds	r6, r7, #1
 800073c:	f105 0830 	add.w	r8, r5, #48	; 0x30
 8000740:	f80c 8007 	strb.w	r8, [ip, r7]
 8000744:	b2f7      	uxtb	r7, r6

		// Value - first digit
		value %= decade;

		// /10
		decade /= 10;
 8000746:	fba0 8603 	umull	r8, r6, r0, r3
	uint8_t length = 0;

	// Largest num: 1xxxxxx...
	uint32_t decade = 1000000000;

	while (decade > 1)
 800074a:	3c01      	subs	r4, #1
			// Put first digit
			string[length++] = ((value/decade) + '0');
		}

		// Value - first digit
		value %= decade;
 800074c:	fb03 2215 	mls	r2, r3, r5, r2

		// /10
		decade /= 10;
 8000750:	ea4f 03d6 	mov.w	r3, r6, lsr #3
	uint8_t length = 0;

	// Largest num: 1xxxxxx...
	uint32_t decade = 1000000000;

	while (decade > 1)
 8000754:	d1ed      	bne.n	8000732 <FloatToString+0x2a>
		// /10
		decade /= 10;
	}

	// Last digit
	string[length++] = (value+ '0');
 8000756:	1c7b      	adds	r3, r7, #1
 8000758:	b2db      	uxtb	r3, r3
	}


	// Integer
	calcValue = (uint32_t)value;
	length += UnsignedDecimalToString(calcValue,&string[length]);
 800075a:	eb09 0503 	add.w	r5, r9, r3
 800075e:	b2ed      	uxtb	r5, r5
		// /10
		decade /= 10;
	}

	// Last digit
	string[length++] = (value+ '0');
 8000760:	3230      	adds	r2, #48	; 0x30
	// fractionLength: 4
	// string: 4.5670

	// 4.567 --> 0.567 --> 5670
	// Only fraction
	value = (value - (uint32_t)value);
 8000762:	eef8 7a67 	vcvt.f32.u32	s15, s15
		// /10
		decade /= 10;
	}

	// Last digit
	string[length++] = (value+ '0');
 8000766:	f80c 2007 	strb.w	r2, [ip, r7]
	calcValue = (uint32_t)value;
	length += UnsignedDecimalToString(calcValue,&string[length]);


	// Point '.'
	string[length++] = '.';
 800076a:	1c68      	adds	r0, r5, #1
 800076c:	222e      	movs	r2, #46	; 0x2e

	// Last digit
	string[length++] = (value+ '0');

	// End character
	string[length] = '\0';
 800076e:	f80c 4003 	strb.w	r4, [ip, r3]
	// fractionLength: 4
	// string: 4.5670

	// 4.567 --> 0.567 --> 5670
	// Only fraction
	value = (value - (uint32_t)value);
 8000772:	ee30 0a67 	vsub.f32	s0, s0, s15
	calcValue = (uint32_t)value;
	length += UnsignedDecimalToString(calcValue,&string[length]);


	// Point '.'
	string[length++] = '.';
 8000776:	f80e 2005 	strb.w	r2, [lr, r5]
 800077a:	b2c0      	uxtb	r0, r0
	// 4.567 --> 0.567 --> 5670
	// Only fraction
	value = (value - (uint32_t)value);

	// * 10, and write
	while (fractionLength--)
 800077c:	b1e1      	cbz	r1, 80007b8 <FloatToString+0xb0>
 800077e:	1c4b      	adds	r3, r1, #1
 8000780:	441d      	add	r5, r3
 8000782:	b2ed      	uxtb	r5, r5
 8000784:	4602      	mov	r2, r0
	{
		// 0.567 --> 5.67
		value *= 10; 			// "shift left" = *10
 8000786:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 800078a:	ee20 0a07 	vmul.f32	s0, s0, s14
		// 5.67 --> 5
		num = (uint8_t)value;	// integer value (MSB octet)
		// 5.67 - 5
		value -= num;			// value--
		string[length++] = num + '0';
 800078e:	1c54      	adds	r4, r2, #1
	while (fractionLength--)
	{
		// 0.567 --> 5.67
		value *= 10; 			// "shift left" = *10
		// 5.67 --> 5
		num = (uint8_t)value;	// integer value (MSB octet)
 8000790:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8000794:	edcd 7a01 	vstr	s15, [sp, #4]
 8000798:	f89d 3004 	ldrb.w	r3, [sp, #4]
		// 5.67 - 5
		value -= num;			// value--
 800079c:	ee07 3a90 	vmov	s15, r3
		string[length++] = num + '0';
 80007a0:	3330      	adds	r3, #48	; 0x30
		// 0.567 --> 5.67
		value *= 10; 			// "shift left" = *10
		// 5.67 --> 5
		num = (uint8_t)value;	// integer value (MSB octet)
		// 5.67 - 5
		value -= num;			// value--
 80007a2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
		string[length++] = num + '0';
 80007a6:	f80e 3002 	strb.w	r3, [lr, r2]
 80007aa:	b2e2      	uxtb	r2, r4
	// 4.567 --> 0.567 --> 5670
	// Only fraction
	value = (value - (uint32_t)value);

	// * 10, and write
	while (fractionLength--)
 80007ac:	42aa      	cmp	r2, r5
		// 0.567 --> 5.67
		value *= 10; 			// "shift left" = *10
		// 5.67 --> 5
		num = (uint8_t)value;	// integer value (MSB octet)
		// 5.67 - 5
		value -= num;			// value--
 80007ae:	ee30 0a67 	vsub.f32	s0, s0, s15
	// 4.567 --> 0.567 --> 5670
	// Only fraction
	value = (value - (uint32_t)value);

	// * 10, and write
	while (fractionLength--)
 80007b2:	d1ea      	bne.n	800078a <FloatToString+0x82>
 80007b4:	4408      	add	r0, r1
 80007b6:	b2c0      	uxtb	r0, r0
		value -= num;			// value--
		string[length++] = num + '0';
	}

	// Put end char
	string[length] = '\0';
 80007b8:	2300      	movs	r3, #0
 80007ba:	f80e 3000 	strb.w	r3, [lr, r0]


	return length;
}
 80007be:	b003      	add	sp, #12
 80007c0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

	// Sign
	if (value < 0)
	{
		// Put '-'
		string[length++] = '-';
 80007c4:	232d      	movs	r3, #45	; 0x2d
		value = (value * (-1));	// make positive
 80007c6:	f04f 0c01 	mov.w	ip, #1
 80007ca:	eeb1 0a40 	vneg.f32	s0, s0

	// Sign
	if (value < 0)
	{
		// Put '-'
		string[length++] = '-';
 80007ce:	7003      	strb	r3, [r0, #0]
 80007d0:	46e1      	mov	r9, ip
 80007d2:	e7a5      	b.n	8000720 <FloatToString+0x18>
 80007d4:	3b9aca00 	.word	0x3b9aca00
 80007d8:	cccccccd 	.word	0xcccccccd

080007dc <StringIsHexadecimalString>:
{
	uint8_t length = 0;
	uint8_t i;

	// Check parameters
	if (string == NULL)
 80007dc:	b198      	cbz	r0, 8000806 <StringIsHexadecimalString+0x2a>
	{
		return 0;
	}
	
	for (i=0; string[i] != '\0'; i++)
 80007de:	7803      	ldrb	r3, [r0, #0]
 80007e0:	b15b      	cbz	r3, 80007fa <StringIsHexadecimalString+0x1e>
 80007e2:	2200      	movs	r2, #0
	bool isOk = false;
	if ((c >= '0') && (c <='9'))
	{
		isOk = true;
	}
	else if ((c >= 'A') && (c <= 'F'))
 80007e4:	f023 0120 	bic.w	r1, r3, #32
 * 			false, if no hex number
 */
bool IsHexChar(char c)
{
	bool isOk = false;
	if ((c >= '0') && (c <='9'))
 80007e8:	3b30      	subs	r3, #48	; 0x30
	for (i=0; string[i] != '\0'; i++)
	{
		// Number all? 0-9, A-F, a-f
		if (IsHexChar(string[i]))
		{
			length++;
 80007ea:	3201      	adds	r2, #1
 * 			false, if no hex number
 */
bool IsHexChar(char c)
{
	bool isOk = false;
	if ((c >= '0') && (c <='9'))
 80007ec:	2b09      	cmp	r3, #9
	for (i=0; string[i] != '\0'; i++)
	{
		// Number all? 0-9, A-F, a-f
		if (IsHexChar(string[i]))
		{
			length++;
 80007ee:	b2d2      	uxtb	r2, r2
	bool isOk = false;
	if ((c >= '0') && (c <='9'))
	{
		isOk = true;
	}
	else if ((c >= 'A') && (c <= 'F'))
 80007f0:	f1a1 0141 	sub.w	r1, r1, #65	; 0x41
 * 			false, if no hex number
 */
bool IsHexChar(char c)
{
	bool isOk = false;
	if ((c >= '0') && (c <='9'))
 80007f4:	d903      	bls.n	80007fe <StringIsHexadecimalString+0x22>
	{
		isOk = true;
	}
	else if ((c >= 'A') && (c <= 'F'))
 80007f6:	2905      	cmp	r1, #5
 80007f8:	d901      	bls.n	80007fe <StringIsHexadecimalString+0x22>
	uint8_t i;

	// Check parameters
	if (string == NULL)
	{
		return 0;
 80007fa:	2000      	movs	r0, #0
 80007fc:	4770      	bx	lr
	}
	
	for (i=0; string[i] != '\0'; i++)
 80007fe:	5c83      	ldrb	r3, [r0, r2]
 8000800:	2b00      	cmp	r3, #0
 8000802:	d1ef      	bne.n	80007e4 <StringIsHexadecimalString+0x8>
	{
		// Number all? 0-9, A-F, a-f
		if (IsHexChar(string[i]))
		{
			length++;
 8000804:	4610      	mov	r0, r2
			return 0;
		}
	}

	return length;
}
 8000806:	4770      	bx	lr

08000808 <StringByteToNum>:
 * \brief	Convert two hexadecimal string to number (byte)
 * \return	true, if successul
 * 			false, if has error
 */
bool StringByteToNum(const char *string, uint8_t *byte)
{
 8000808:	b410      	push	{r4}
	uint8_t calculatedByte = 0;
	calculatedByte |= (HexCharToOctet(string[0])&0x0F) << 4;
 800080a:	7804      	ldrb	r4, [r0, #0]
 * \return	Value (number)
 */
uint8_t HexCharToOctet(char c)
{
	uint8_t octet = 0;
	if ((c >= '0') && (c <='9'))
 800080c:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
 8000810:	b2db      	uxtb	r3, r3
 8000812:	2b09      	cmp	r3, #9
 8000814:	d81d      	bhi.n	8000852 <StringByteToNum+0x4a>
 8000816:	011b      	lsls	r3, r3, #4
 8000818:	b25c      	sxtb	r4, r3
 */
bool StringByteToNum(const char *string, uint8_t *byte)
{
	uint8_t calculatedByte = 0;
	calculatedByte |= (HexCharToOctet(string[0])&0x0F) << 4;
	calculatedByte |= (HexCharToOctet(string[1])&0x0F);
 800081a:	7840      	ldrb	r0, [r0, #1]
 * \return	Value (number)
 */
uint8_t HexCharToOctet(char c)
{
	uint8_t octet = 0;
	if ((c >= '0') && (c <='9'))
 800081c:	f1a0 0230 	sub.w	r2, r0, #48	; 0x30
 8000820:	b2d3      	uxtb	r3, r2
 8000822:	2b09      	cmp	r3, #9
 8000824:	d90e      	bls.n	8000844 <StringByteToNum+0x3c>
	{
		octet = c - '0';
	}
	else if ((c >= 'A') && (c <= 'F'))
 8000826:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
 800082a:	2b05      	cmp	r3, #5
 800082c:	d908      	bls.n	8000840 <StringByteToNum+0x38>
	{
		octet = c - 'A' + 10;
	}
	else if ((c >= 'a') && (c <= 'f'))
 800082e:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
 8000832:	2b05      	cmp	r3, #5
 8000834:	bf9a      	itte	ls
 8000836:	f1a0 0357 	subls.w	r3, r0, #87	; 0x57
 800083a:	b25b      	sxtbls	r3, r3
 800083c:	2300      	movhi	r3, #0
 800083e:	e002      	b.n	8000846 <StringByteToNum+0x3e>
 8000840:	f1a0 0337 	sub.w	r3, r0, #55	; 0x37
 8000844:	b25b      	sxtb	r3, r3
{
	uint8_t calculatedByte = 0;
	calculatedByte |= (HexCharToOctet(string[0])&0x0F) << 4;
	calculatedByte |= (HexCharToOctet(string[1])&0x0F);

	*byte = calculatedByte;
 8000846:	4323      	orrs	r3, r4
	return true;

}
 8000848:	2001      	movs	r0, #1
{
	uint8_t calculatedByte = 0;
	calculatedByte |= (HexCharToOctet(string[0])&0x0F) << 4;
	calculatedByte |= (HexCharToOctet(string[1])&0x0F);

	*byte = calculatedByte;
 800084a:	700b      	strb	r3, [r1, #0]
	return true;

}
 800084c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000850:	4770      	bx	lr
	uint8_t octet = 0;
	if ((c >= '0') && (c <='9'))
	{
		octet = c - '0';
	}
	else if ((c >= 'A') && (c <= 'F'))
 8000852:	f1a4 0341 	sub.w	r3, r4, #65	; 0x41
 8000856:	2b05      	cmp	r3, #5
 8000858:	d804      	bhi.n	8000864 <StringByteToNum+0x5c>
 800085a:	3c37      	subs	r4, #55	; 0x37
 800085c:	f344 0303 	sbfx	r3, r4, #0, #4
 8000860:	011c      	lsls	r4, r3, #4
 8000862:	e7da      	b.n	800081a <StringByteToNum+0x12>
	{
		octet = c - 'A' + 10;
	}
	else if ((c >= 'a') && (c <= 'f'))
 8000864:	f1a4 0361 	sub.w	r3, r4, #97	; 0x61
 8000868:	2b05      	cmp	r3, #5
 800086a:	bf9d      	ittte	ls
 800086c:	3c57      	subls	r4, #87	; 0x57
 800086e:	f344 0303 	sbfxls	r3, r4, #0, #4
 8000872:	011c      	lslls	r4, r3, #4
 8000874:	2400      	movhi	r4, #0
 8000876:	e7d0      	b.n	800081a <StringByteToNum+0x12>

08000878 <StringHexToNum>:
 * \brief	Convert Hex string to number(integer)
 * \return	true, if successul
 * 			false, if has error
 */
bool StringHexToNum (const char *string, uint32_t *hexValue, uint8_t byteLength)
{
 8000878:	b5f0      	push	{r4, r5, r6, r7, lr}
 800087a:	b083      	sub	sp, #12
	uint8_t i;
	uint32_t calculatedValue = 0;
	uint8_t calculatedByte = 0;
 800087c:	2300      	movs	r3, #0
 * \brief	Convert Hex string to number(integer)
 * \return	true, if successul
 * 			false, if has error
 */
bool StringHexToNum (const char *string, uint32_t *hexValue, uint8_t byteLength)
{
 800087e:	460f      	mov	r7, r1
 8000880:	4616      	mov	r6, r2
	uint8_t i;
	uint32_t calculatedValue = 0;
	uint8_t calculatedByte = 0;
 8000882:	f88d 3007 	strb.w	r3, [sp, #7]
 * \brief	Convert Hex string to number(integer)
 * \return	true, if successul
 * 			false, if has error
 */
bool StringHexToNum (const char *string, uint32_t *hexValue, uint8_t byteLength)
{
 8000886:	4605      	mov	r5, r0
	uint32_t calculatedValue = 0;
	uint8_t calculatedByte = 0;
	uint8_t octetLength = 0;


	octetLength = StringIsHexadecimalString (string);	// octetLength = how many hex character have
 8000888:	f7ff ffa8 	bl	80007dc <StringIsHexadecimalString>

	if (octetLength == 0 || (octetLength%2))
 800088c:	b1a8      	cbz	r0, 80008ba <StringHexToNum+0x42>
 800088e:	07c3      	lsls	r3, r0, #31
 8000890:	d413      	bmi.n	80008ba <StringHexToNum+0x42>
	{
		// Wrong string or wrong octetlength
		return false;
	}

	if (byteLength == 0)
 8000892:	b1ae      	cbz	r6, 80008c0 <StringHexToNum+0x48>
	{
		// Calculate byte length
		byteLength = octetLength / 2;
	}
	else if (octetLength != byteLength*2)
 8000894:	ebb0 0f46 	cmp.w	r0, r6, lsl #1
 8000898:	d10f      	bne.n	80008ba <StringHexToNum+0x42>
		// Wrong byteLength
		return false;
	}

	// Create hexValue
	for (i=0; string[i] != '\0'; i++)
 800089a:	782b      	ldrb	r3, [r5, #0]
 800089c:	b1eb      	cbz	r3, 80008da <StringHexToNum+0x62>
 800089e:	2400      	movs	r4, #0
 80008a0:	4628      	mov	r0, r5
 80008a2:	e002      	b.n	80008aa <StringHexToNum+0x32>
 80008a4:	5d2b      	ldrb	r3, [r5, r4]
 80008a6:	1928      	adds	r0, r5, r4
 80008a8:	b16b      	cbz	r3, 80008c6 <StringHexToNum+0x4e>
	{
		// 1. = 0 = event --> shift <<4
		// 2. = 1 = odd --> not need shift
		if ( StringByteToNum(&string[i],&calculatedByte) )
 80008aa:	f10d 0107 	add.w	r1, sp, #7
 80008ae:	f7ff ffab 	bl	8000808 <StringByteToNum>
		// Wrong byteLength
		return false;
	}

	// Create hexValue
	for (i=0; string[i] != '\0'; i++)
 80008b2:	3402      	adds	r4, #2
 80008b4:	b2e4      	uxtb	r4, r4
	{
		// 1. = 0 = event --> shift <<4
		// 2. = 1 = odd --> not need shift
		if ( StringByteToNum(&string[i],&calculatedByte) )
 80008b6:	2800      	cmp	r0, #0
 80008b8:	d1f4      	bne.n	80008a4 <StringHexToNum+0x2c>
	octetLength = StringIsHexadecimalString (string);	// octetLength = how many hex character have

	if (octetLength == 0 || (octetLength%2))
	{
		// Wrong string or wrong octetlength
		return false;
 80008ba:	2000      	movs	r0, #0
	}

	*hexValue = calculatedValue;

	return true;
}
 80008bc:	b003      	add	sp, #12
 80008be:	bdf0      	pop	{r4, r5, r6, r7, pc}
	}

	if (byteLength == 0)
	{
		// Calculate byte length
		byteLength = octetLength / 2;
 80008c0:	f3c0 0647 	ubfx	r6, r0, #1, #8
 80008c4:	e7e9      	b.n	800089a <StringHexToNum+0x22>
		// 2. = 1 = odd --> not need shift
		if ( StringByteToNum(&string[i],&calculatedByte) )
		{
			// For example: for 4 byte, first need << 24 (3*8)
			// After that, << 16 (2*8)
			calculatedValue = calculatedByte << ((byteLength-1)*8);
 80008c6:	3e01      	subs	r6, #1
 80008c8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80008cc:	00f6      	lsls	r6, r6, #3
 80008ce:	fa03 f606 	lsl.w	r6, r3, r6
		}
	}

	*hexValue = calculatedValue;

	return true;
 80008d2:	2001      	movs	r0, #1
		{
			return false;
		}
	}

	*hexValue = calculatedValue;
 80008d4:	603e      	str	r6, [r7, #0]

	return true;
}
 80008d6:	b003      	add	sp, #12
 80008d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 * 			false, if has error
 */
bool StringHexToNum (const char *string, uint32_t *hexValue, uint8_t byteLength)
{
	uint8_t i;
	uint32_t calculatedValue = 0;
 80008da:	461e      	mov	r6, r3
 80008dc:	e7f9      	b.n	80008d2 <StringHexToNum+0x5a>
 80008de:	bf00      	nop

080008e0 <UnsignedDecimalStringToNum>:
	uint32_t calculatedValue = 0;
	uint8_t i;
	uint8_t decimal;


	for (i=0; string[i] != '\0'; i++)
 80008e0:	7803      	ldrb	r3, [r0, #0]
 80008e2:	b1fb      	cbz	r3, 8000924 <UnsignedDecimalStringToNum+0x44>
 * 			false, if no number
 */
bool IsDecimalChar(char c)
{
	bool isOk = false;
	if ((c >= '0') && (c <='9'))
 80008e4:	3b30      	subs	r3, #48	; 0x30
 80008e6:	b2db      	uxtb	r3, r3
 80008e8:	2b09      	cmp	r3, #9
 80008ea:	d819      	bhi.n	8000920 <UnsignedDecimalStringToNum+0x40>
 * \brief	Convert Unsigned decimal string to integer
 * \return	true, if successul
 * 			false, if has error
 */
bool UnsignedDecimalStringToNum (const char *string, uint32_t *value)
{
 80008ec:	b430      	push	{r4, r5}
 * 			false, if no number
 */
bool IsDecimalChar(char c)
{
	bool isOk = false;
	if ((c >= '0') && (c <='9'))
 80008ee:	2200      	movs	r2, #0
 80008f0:	f100 050b 	add.w	r5, r0, #11
 80008f4:	e007      	b.n	8000906 <UnsignedDecimalStringToNum+0x26>
	uint32_t calculatedValue = 0;
	uint8_t i;
	uint8_t decimal;


	for (i=0; string[i] != '\0'; i++)
 80008f6:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 * 			false, if no number
 */
bool IsDecimalChar(char c)
{
	bool isOk = false;
	if ((c >= '0') && (c <='9'))
 80008fa:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
 80008fe:	b2db      	uxtb	r3, r3
	uint32_t calculatedValue = 0;
	uint8_t i;
	uint8_t decimal;


	for (i=0; string[i] != '\0'; i++)
 8000900:	b154      	cbz	r4, 8000918 <UnsignedDecimalStringToNum+0x38>
 * 			false, if no number
 */
bool IsDecimalChar(char c)
{
	bool isOk = false;
	if ((c >= '0') && (c <='9'))
 8000902:	2b09      	cmp	r3, #9
 8000904:	d805      	bhi.n	8000912 <UnsignedDecimalStringToNum+0x32>
	{
		if (IsDecimalChar(string[i]))
		{
			decimal = DecimalCharToNum(string[i]);
			// Shift left 1* =  *10
			calculatedValue *= 10;
 8000906:	eb02 0282 	add.w	r2, r2, r2, lsl #2
		{
			// Wrong character
			return false;
		}

		if (i>10)
 800090a:	42a8      	cmp	r0, r5
		{
			decimal = DecimalCharToNum(string[i]);
			// Shift left 1* =  *10
			calculatedValue *= 10;
			// Add new value
			calculatedValue += decimal;
 800090c:	eb03 0242 	add.w	r2, r3, r2, lsl #1
		{
			// Wrong character
			return false;
		}

		if (i>10)
 8000910:	d1f1      	bne.n	80008f6 <UnsignedDecimalStringToNum+0x16>
			calculatedValue += decimal;
		}
		else
		{
			// Wrong character
			return false;
 8000912:	2000      	movs	r0, #0
	}

	*value = calculatedValue;

	return true;
}
 8000914:	bc30      	pop	{r4, r5}
 8000916:	4770      	bx	lr
		}
	}

	*value = calculatedValue;

	return true;
 8000918:	2001      	movs	r0, #1
			// To long num
			return false;
		}
	}

	*value = calculatedValue;
 800091a:	600a      	str	r2, [r1, #0]

	return true;
}
 800091c:	bc30      	pop	{r4, r5}
 800091e:	4770      	bx	lr
			calculatedValue += decimal;
		}
		else
		{
			// Wrong character
			return false;
 8000920:	2000      	movs	r0, #0
 8000922:	4770      	bx	lr
			// To long num
			return false;
		}
	}

	*value = calculatedValue;
 8000924:	600b      	str	r3, [r1, #0]

	return true;
 8000926:	2001      	movs	r0, #1
}
 8000928:	4770      	bx	lr
 800092a:	bf00      	nop

0800092c <StringLength>:
 */
uint8_t StringLength (const char *string)
{
	uint8_t length = 0;

	if (string == NULL)
 800092c:	b150      	cbz	r0, 8000944 <StringLength+0x18>
	{
		return 0;
	}

	while (string[length] !='\0') length++;	// Length = string length
 800092e:	7802      	ldrb	r2, [r0, #0]
 8000930:	b13a      	cbz	r2, 8000942 <StringLength+0x16>
 8000932:	2300      	movs	r3, #0
 8000934:	3301      	adds	r3, #1
 8000936:	b2db      	uxtb	r3, r3
 8000938:	5cc2      	ldrb	r2, [r0, r3]
 800093a:	2a00      	cmp	r2, #0
 800093c:	d1fa      	bne.n	8000934 <StringLength+0x8>
 800093e:	4618      	mov	r0, r3
 8000940:	4770      	bx	lr
{
	uint8_t length = 0;

	if (string == NULL)
	{
		return 0;
 8000942:	4610      	mov	r0, r2
	}

	while (string[length] !='\0') length++;	// Length = string length
	return length;
}
 8000944:	4770      	bx	lr
 8000946:	bf00      	nop

08000948 <StrCmp>:
 * \return	1, if not equal
 * 			0, if equal
 */
uint8_t StrCmp(const char * ch1, const char *ch2) {

	while ( *ch1 )
 8000948:	7803      	ldrb	r3, [r0, #0]
 800094a:	b16b      	cbz	r3, 8000968 <StrCmp+0x20>
	{
		if ( *ch1 !=  *ch2 )
 800094c:	780a      	ldrb	r2, [r1, #0]
 800094e:	429a      	cmp	r2, r3
 8000950:	d10f      	bne.n	8000972 <StrCmp+0x2a>
 8000952:	1c4b      	adds	r3, r1, #1
 8000954:	e002      	b.n	800095c <StrCmp+0x14>
 8000956:	7809      	ldrb	r1, [r1, #0]
 8000958:	4291      	cmp	r1, r2
 800095a:	d10a      	bne.n	8000972 <StrCmp+0x2a>
 * \return	1, if not equal
 * 			0, if equal
 */
uint8_t StrCmp(const char * ch1, const char *ch2) {

	while ( *ch1 )
 800095c:	f810 2f01 	ldrb.w	r2, [r0, #1]!
		if ( *ch1 !=  *ch2 )
		{
			return 1;	// not equal
		}
		ch1++;
		ch2++;
 8000960:	4619      	mov	r1, r3
 8000962:	3301      	adds	r3, #1
 * \return	1, if not equal
 * 			0, if equal
 */
uint8_t StrCmp(const char * ch1, const char *ch2) {

	while ( *ch1 )
 8000964:	2a00      	cmp	r2, #0
 8000966:	d1f6      	bne.n	8000956 <StrCmp+0xe>
	{
		if ( *ch1 !=  *ch2 )
		{
			return 1;	// not equal
 8000968:	7808      	ldrb	r0, [r1, #0]
 800096a:	3000      	adds	r0, #0
 800096c:	bf18      	it	ne
 800096e:	2001      	movne	r0, #1
 8000970:	4770      	bx	lr
 8000972:	2001      	movs	r0, #1
	else
	{
		return 0;		// last ch2 char is '\0'
	}

}
 8000974:	4770      	bx	lr
 8000976:	bf00      	nop

08000978 <StrCpy>:
 */
uint8_t StringLength (const char *string)
{
	uint8_t length = 0;

	if (string == NULL)
 8000978:	b1e1      	cbz	r1, 80009b4 <StrCpy+0x3c>
	{
		return 0;
	}

	while (string[length] !='\0') length++;	// Length = string length
 800097a:	780a      	ldrb	r2, [r1, #0]
 800097c:	b1e2      	cbz	r2, 80009b8 <StrCpy+0x40>
/*
 * \brief	Copy string to *dest pointer
 * \return	copied string length
 */
uint8_t StrCpy (char *dest, const char *string)
{
 800097e:	b430      	push	{r4, r5}
	if (string == NULL)
	{
		return 0;
	}

	while (string[length] !='\0') length++;	// Length = string length
 8000980:	2200      	movs	r2, #0
 8000982:	e000      	b.n	8000986 <StrCpy+0xe>
 8000984:	461a      	mov	r2, r3
 8000986:	1c53      	adds	r3, r2, #1
 8000988:	b2db      	uxtb	r3, r3
 800098a:	5ccc      	ldrb	r4, [r1, r3]
 800098c:	2c00      	cmp	r4, #0
 800098e:	d1f9      	bne.n	8000984 <StrCpy+0xc>
{
	uint8_t i;
	uint8_t length;

	length = StringLength(string);
	if ( length == 0 )
 8000990:	b16b      	cbz	r3, 80009ae <StrCpy+0x36>
 8000992:	440a      	add	r2, r1
 8000994:	1e44      	subs	r4, r0, #1
 8000996:	3901      	subs	r1, #1
	}

	// Copy characters
	for ( i = 0; i < length; i++ )
	{
		dest[i] = string[i];
 8000998:	f811 5f01 	ldrb.w	r5, [r1, #1]!
 800099c:	f804 5f01 	strb.w	r5, [r4, #1]!
		// Return 0 length
		return 0;
	}

	// Copy characters
	for ( i = 0; i < length; i++ )
 80009a0:	4291      	cmp	r1, r2
 80009a2:	d1f9      	bne.n	8000998 <StrCpy+0x20>
	{
		dest[i] = string[i];
	}
	dest[length] = '\0';
 80009a4:	2200      	movs	r2, #0
 80009a6:	54c2      	strb	r2, [r0, r3]

	// Return length
	return length;
 80009a8:	4618      	mov	r0, r3
}
 80009aa:	bc30      	pop	{r4, r5}
 80009ac:	4770      	bx	lr

	length = StringLength(string);
	if ( length == 0 )
	{
		// Return 0 length
		return 0;
 80009ae:	4618      	mov	r0, r3
	}
	dest[length] = '\0';

	// Return length
	return length;
}
 80009b0:	bc30      	pop	{r4, r5}
 80009b2:	4770      	bx	lr

	length = StringLength(string);
	if ( length == 0 )
	{
		// Return 0 length
		return 0;
 80009b4:	4608      	mov	r0, r1
	}
	dest[length] = '\0';

	// Return length
	return length;
}
 80009b6:	4770      	bx	lr

	length = StringLength(string);
	if ( length == 0 )
	{
		// Return 0 length
		return 0;
 80009b8:	4610      	mov	r0, r2
 80009ba:	4770      	bx	lr

080009bc <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 80009bc:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 80009be:	f001 fd77 	bl	80024b0 <HAL_IncTick>
  osSystickHandler();
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 80009c2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
  osSystickHandler();
 80009c6:	f000 bef9 	b.w	80017bc <osSystickHandler>
 80009ca:	bf00      	nop

080009cc <HAL_MspInit>:

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80009cc:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80009ce:	2003      	movs	r0, #3
 80009d0:	f001 fcc2 	bl	8002358 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 80009d4:	2200      	movs	r2, #0
 80009d6:	4611      	mov	r1, r2
 80009d8:	f06f 000b 	mvn.w	r0, #11
 80009dc:	f001 fcce 	bl	800237c <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 80009e0:	2200      	movs	r2, #0
 80009e2:	4611      	mov	r1, r2
 80009e4:	f06f 000a 	mvn.w	r0, #10
 80009e8:	f001 fcc8 	bl	800237c <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 80009ec:	2200      	movs	r2, #0
 80009ee:	4611      	mov	r1, r2
 80009f0:	f06f 0009 	mvn.w	r0, #9
 80009f4:	f001 fcc2 	bl	800237c <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 80009f8:	2200      	movs	r2, #0
 80009fa:	4611      	mov	r1, r2
 80009fc:	f06f 0004 	mvn.w	r0, #4
 8000a00:	f001 fcbc 	bl	800237c <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 8000a04:	2200      	movs	r2, #0
 8000a06:	4611      	mov	r1, r2
 8000a08:	f06f 0003 	mvn.w	r0, #3
 8000a0c:	f001 fcb6 	bl	800237c <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8000a10:	2200      	movs	r2, #0
 8000a12:	210f      	movs	r1, #15
 8000a14:	f06f 0001 	mvn.w	r0, #1
 8000a18:	f001 fcb0 	bl	800237c <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
 8000a1c:	2200      	movs	r2, #0
 8000a1e:	210f      	movs	r1, #15
 8000a20:	f04f 30ff 	mov.w	r0, #4294967295

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8000a24:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
 8000a28:	f001 bca8 	b.w	800237c <HAL_NVIC_SetPriority>

08000a2c <MONITOR_Init>:



// Function: Init Monitor program
// TODO: kiszedve a kikuldes, mert faultot okoz, ha nincs kapcsolat
uint8_t MONITOR_Init ( void ) {
 8000a2c:	b5f0      	push	{r4, r5, r6, r7, lr}

	// INIT									// Init CommandActual

	MONITOR_CommandEvent = 0;
 8000a2e:	f8df c060 	ldr.w	ip, [pc, #96]	; 8000a90 <MONITOR_Init+0x64>
	MONITOR_CommandActualLength = 0;
 8000a32:	f8df e060 	ldr.w	lr, [pc, #96]	; 8000a94 <MONITOR_Init+0x68>
	MONITOR_CommandSentLength = 0;
 8000a36:	4c0d      	ldr	r4, [pc, #52]	; (8000a6c <MONITOR_Init+0x40>)
	MONITOR_CommandCursorPosition = 0;
 8000a38:	490d      	ldr	r1, [pc, #52]	; (8000a70 <MONITOR_Init+0x44>)
	MONITOR_CommandEscapeSequenceReceived = 0;
 8000a3a:	4a0e      	ldr	r2, [pc, #56]	; (8000a74 <MONITOR_Init+0x48>)
	MONITOR_CommandEscapeSequenceInProgress = 0;
 8000a3c:	4f0e      	ldr	r7, [pc, #56]	; (8000a78 <MONITOR_Init+0x4c>)
	MONITOR_CommandReceivedLastChar = 0;
 8000a3e:	480f      	ldr	r0, [pc, #60]	; (8000a7c <MONITOR_Init+0x50>)
	MONITOR_CommandReceivedNotLastChar = 0;
 8000a40:	4e0f      	ldr	r6, [pc, #60]	; (8000a80 <MONITOR_Init+0x54>)
	MONITOR_CommandEscape_cnt = 0;
 8000a42:	4d10      	ldr	r5, [pc, #64]	; (8000a84 <MONITOR_Init+0x58>)
// TODO: kiszedve a kikuldes, mert faultot okoz, ha nincs kapcsolat
uint8_t MONITOR_Init ( void ) {

	// INIT									// Init CommandActual

	MONITOR_CommandEvent = 0;
 8000a44:	2300      	movs	r3, #0
 8000a46:	f88c 3000 	strb.w	r3, [ip]
	MONITOR_CommandActualLength = 0;
 8000a4a:	f88e 3000 	strb.w	r3, [lr]
	MONITOR_CommandSentLength = 0;
 8000a4e:	7023      	strb	r3, [r4, #0]
	MONITOR_CommandCursorPosition = 0;
 8000a50:	700b      	strb	r3, [r1, #0]
	MONITOR_CommandEscapeSequenceReceived = 0;
	MONITOR_CommandEscapeSequenceInProgress = 0;
	MONITOR_CommandReceivedLastChar = 0;
	MONITOR_CommandReceivedNotLastChar = 0;
	MONITOR_CommandEscape_cnt = 0;
	MONITOR_CommandSendBackChar_Enable = 1;	// enable
 8000a52:	4c0d      	ldr	r4, [pc, #52]	; (8000a88 <MONITOR_Init+0x5c>)
	USART_TxBuffer[TXBUFFERSIZE-1] = '\0';
 8000a54:	490d      	ldr	r1, [pc, #52]	; (8000a8c <MONITOR_Init+0x60>)

	MONITOR_CommandEvent = 0;
	MONITOR_CommandActualLength = 0;
	MONITOR_CommandSentLength = 0;
	MONITOR_CommandCursorPosition = 0;
	MONITOR_CommandEscapeSequenceReceived = 0;
 8000a56:	7013      	strb	r3, [r2, #0]
	MONITOR_CommandEscapeSequenceInProgress = 0;
	MONITOR_CommandReceivedLastChar = 0;
	MONITOR_CommandReceivedNotLastChar = 0;
	MONITOR_CommandEscape_cnt = 0;
	MONITOR_CommandSendBackChar_Enable = 1;	// enable
 8000a58:	2201      	movs	r2, #1
	MONITOR_CommandEvent = 0;
	MONITOR_CommandActualLength = 0;
	MONITOR_CommandSentLength = 0;
	MONITOR_CommandCursorPosition = 0;
	MONITOR_CommandEscapeSequenceReceived = 0;
	MONITOR_CommandEscapeSequenceInProgress = 0;
 8000a5a:	703b      	strb	r3, [r7, #0]
	MONITOR_CommandReceivedLastChar = 0;
 8000a5c:	7003      	strb	r3, [r0, #0]
	MONITOR_CommandReceivedNotLastChar = 0;
 8000a5e:	7033      	strb	r3, [r6, #0]
	MONITOR_CommandEscape_cnt = 0;
 8000a60:	702b      	strb	r3, [r5, #0]
	MONITOR_CommandSendBackChar_Enable = 1;	// enable
 8000a62:	7022      	strb	r2, [r4, #0]
	USART_TxBuffer[TXBUFFERSIZE-1] = '\0';
 8000a64:	f881 30ff 	strb.w	r3, [r1, #255]	; 0xff
	
	// !!IMPORTANT!! Nem szabad kikuldeni uzenetet a kapcsolat letrejotte elott, mert faultba juthatunk.
	
	
	return RETURN_SUCCESS;
}
 8000a68:	4610      	mov	r0, r2
 8000a6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000a6c:	20000525 	.word	0x20000525
 8000a70:	2000092b 	.word	0x2000092b
 8000a74:	2000092c 	.word	0x2000092c
 8000a78:	20000828 	.word	0x20000828
 8000a7c:	20000933 	.word	0x20000933
 8000a80:	20000827 	.word	0x20000827
 8000a84:	20000934 	.word	0x20000934
 8000a88:	20000522 	.word	0x20000522
 8000a8c:	200006e0 	.word	0x200006e0
 8000a90:	20000824 	.word	0x20000824
 8000a94:	20000521 	.word	0x20000521

08000a98 <MONITOR_SendPrimitiveWelcome>:
}



uint8_t MONITOR_SendPrimitiveWelcome ( void )
{
 8000a98:	b508      	push	{r3, lr}


	#ifdef CONFIG_USE_FREERTOS
	vTaskDelay(1);
	#else
	HAL_Delay(1);
 8000a9a:	2001      	movs	r0, #1
 8000a9c:	f001 fd16 	bl	80024cc <HAL_Delay>
	#endif

	
	USART_SEND_CLS();						// Clean screen
 8000aa0:	4808      	ldr	r0, [pc, #32]	; (8000ac4 <MONITOR_SendPrimitiveWelcome+0x2c>)
 8000aa2:	f7ff fcab 	bl	80003fc <USART_SendMessage>
 8000aa6:	4808      	ldr	r0, [pc, #32]	; (8000ac8 <MONITOR_SendPrimitiveWelcome+0x30>)
 8000aa8:	f7ff fca8 	bl	80003fc <USART_SendMessage>
	MONITOR_SEND_WELCOME();					// Welcome message
 8000aac:	4807      	ldr	r0, [pc, #28]	; (8000acc <MONITOR_SendPrimitiveWelcome+0x34>)
 8000aae:	f7ff fca5 	bl	80003fc <USART_SendMessage>


	USART_SEND_NEW_LINE();
 8000ab2:	4807      	ldr	r0, [pc, #28]	; (8000ad0 <MONITOR_SendPrimitiveWelcome+0x38>)
 8000ab4:	f7ff fca2 	bl	80003fc <USART_SendMessage>
	MONITOR_SEND_PROMT();					// New promt
 8000ab8:	4806      	ldr	r0, [pc, #24]	; (8000ad4 <MONITOR_SendPrimitiveWelcome+0x3c>)
 8000aba:	f7ff fc9f 	bl	80003fc <USART_SendMessage>

	return RETURN_SUCCESS;
	
}
 8000abe:	2001      	movs	r0, #1
 8000ac0:	bd08      	pop	{r3, pc}
 8000ac2:	bf00      	nop
 8000ac4:	080025fc 	.word	0x080025fc
 8000ac8:	08002604 	.word	0x08002604
 8000acc:	0800260c 	.word	0x0800260c
 8000ad0:	08002778 	.word	0x08002778
 8000ad4:	080026f4 	.word	0x080026f4

08000ad8 <MONITOR_CommandSeparate>:
	int i;
	int j = 0;
	uint8_t CommandArgCount = 1;	// 1-3	// Arguments num is 1, when we start separate


	for (i=0; CommandActual[i]!='\0'; i++) {
 8000ad8:	780a      	ldrb	r2, [r1, #0]



// Function: Seperate words (command) to command word, and 2 argument
// from char *CommandActul, to argv[0], [1], [2]
uint8_t MONITOR_CommandSeparate ( char** argv, char *CommandActual ) {
 8000ada:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int i;
	int j = 0;
	uint8_t CommandArgCount = 1;	// 1-3	// Arguments num is 1, when we start separate


	for (i=0; CommandActual[i]!='\0'; i++) {
 8000adc:	2a00      	cmp	r2, #0
 8000ade:	d045      	beq.n	8000b6c <MONITOR_CommandSeparate+0x94>
 8000ae0:	2300      	movs	r3, #0
 8000ae2:	4605      	mov	r5, r0
		if ( CommandActual[i] != ' '  ) {						// Not space, copy char to  Argument (CommandArgX[])
			argv[CommandArgCount-1][j] = CommandActual[i];
			j++;
		}
		else {													// It's space or the end, skip the space
			argv[CommandArgCount-1][j] = '\0';
 8000ae4:	469c      	mov	ip, r3
	int i;
	int j = 0;
	uint8_t CommandArgCount = 1;	// 1-3	// Arguments num is 1, when we start separate


	for (i=0; CommandActual[i]!='\0'; i++) {
 8000ae6:	2601      	movs	r6, #1
 8000ae8:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
 8000aec:	e009      	b.n	8000b02 <MONITOR_CommandSeparate+0x2a>
		if ( CommandActual[i] != ' '  ) {						// Not space, copy char to  Argument (CommandArgX[])
			argv[CommandArgCount-1][j] = CommandActual[i];
 8000aee:	f855 7024 	ldr.w	r7, [r5, r4, lsl #2]
 8000af2:	54fa      	strb	r2, [r7, r3]
			j++;
 8000af4:	3301      	adds	r3, #1
			argv[CommandArgCount-1][j] = '\0';
			CommandArgCount++;
			j = 0;
			if ( CommandArgCount >3) { uprintf("Too many arguments!\r\n"); return 0; }
		}
		if ( j >= MONITOR_MAX_ARG_LENGTH ) { uprintf("Too long argument!\r\n"); return 0;}
 8000af6:	2b27      	cmp	r3, #39	; 0x27
 8000af8:	dc23      	bgt.n	8000b42 <MONITOR_CommandSeparate+0x6a>
	int i;
	int j = 0;
	uint8_t CommandArgCount = 1;	// 1-3	// Arguments num is 1, when we start separate


	for (i=0; CommandActual[i]!='\0'; i++) {
 8000afa:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 8000afe:	461f      	mov	r7, r3
 8000b00:	b1c2      	cbz	r2, 8000b34 <MONITOR_CommandSeparate+0x5c>
		if ( CommandActual[i] != ' '  ) {						// Not space, copy char to  Argument (CommandArgX[])
 8000b02:	2a20      	cmp	r2, #32
			argv[CommandArgCount-1][j] = CommandActual[i];
 8000b04:	eb05 0e84 	add.w	lr, r5, r4, lsl #2
	int j = 0;
	uint8_t CommandArgCount = 1;	// 1-3	// Arguments num is 1, when we start separate


	for (i=0; CommandActual[i]!='\0'; i++) {
		if ( CommandActual[i] != ' '  ) {						// Not space, copy char to  Argument (CommandArgX[])
 8000b08:	d1f1      	bne.n	8000aee <MONITOR_CommandSeparate+0x16>
			argv[CommandArgCount-1][j] = CommandActual[i];
			j++;
		}
		else {													// It's space or the end, skip the space
			argv[CommandArgCount-1][j] = '\0';
			CommandArgCount++;
 8000b0a:	3601      	adds	r6, #1
		if ( CommandActual[i] != ' '  ) {						// Not space, copy char to  Argument (CommandArgX[])
			argv[CommandArgCount-1][j] = CommandActual[i];
			j++;
		}
		else {													// It's space or the end, skip the space
			argv[CommandArgCount-1][j] = '\0';
 8000b0c:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
			CommandArgCount++;
 8000b10:	b2f6      	uxtb	r6, r6
 8000b12:	f106 4480 	add.w	r4, r6, #1073741824	; 0x40000000
			j = 0;
			if ( CommandArgCount >3) { uprintf("Too many arguments!\r\n"); return 0; }
 8000b16:	2e03      	cmp	r6, #3
		if ( CommandActual[i] != ' '  ) {						// Not space, copy char to  Argument (CommandArgX[])
			argv[CommandArgCount-1][j] = CommandActual[i];
			j++;
		}
		else {													// It's space or the end, skip the space
			argv[CommandArgCount-1][j] = '\0';
 8000b18:	f802 c003 	strb.w	ip, [r2, r3]
 8000b1c:	f104 34ff 	add.w	r4, r4, #4294967295
			CommandArgCount++;
			j = 0;
			if ( CommandArgCount >3) { uprintf("Too many arguments!\r\n"); return 0; }
 8000b20:	f04f 0300 	mov.w	r3, #0
 8000b24:	d81b      	bhi.n	8000b5e <MONITOR_CommandSeparate+0x86>
	int i;
	int j = 0;
	uint8_t CommandArgCount = 1;	// 1-3	// Arguments num is 1, when we start separate


	for (i=0; CommandActual[i]!='\0'; i++) {
 8000b26:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 8000b2a:	eb05 0e84 	add.w	lr, r5, r4, lsl #2
			j++;
		}
		else {													// It's space or the end, skip the space
			argv[CommandArgCount-1][j] = '\0';
			CommandArgCount++;
			j = 0;
 8000b2e:	461f      	mov	r7, r3
	int i;
	int j = 0;
	uint8_t CommandArgCount = 1;	// 1-3	// Arguments num is 1, when we start separate


	for (i=0; CommandActual[i]!='\0'; i++) {
 8000b30:	2a00      	cmp	r2, #0
 8000b32:	d1e6      	bne.n	8000b02 <MONITOR_CommandSeparate+0x2a>
			if ( CommandArgCount >3) { uprintf("Too many arguments!\r\n"); return 0; }
		}
		if ( j >= MONITOR_MAX_ARG_LENGTH ) { uprintf("Too long argument!\r\n"); return 0;}
	} // End of copies

	argv[CommandArgCount-1][j] = '\0';							// Last argument's end
 8000b34:	f8de 3000 	ldr.w	r3, [lr]

	if ( CommandArgCount < 3 ) argv[2][0] = '\0';				// 3. argument is empty
 8000b38:	2e02      	cmp	r6, #2
			if ( CommandArgCount >3) { uprintf("Too many arguments!\r\n"); return 0; }
		}
		if ( j >= MONITOR_MAX_ARG_LENGTH ) { uprintf("Too long argument!\r\n"); return 0;}
	} // End of copies

	argv[CommandArgCount-1][j] = '\0';							// Last argument's end
 8000b3a:	55da      	strb	r2, [r3, r7]

	if ( CommandArgCount < 3 ) argv[2][0] = '\0';				// 3. argument is empty
 8000b3c:	d906      	bls.n	8000b4c <MONITOR_CommandSeparate+0x74>
 8000b3e:	4630      	mov	r0, r6
 8000b40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			argv[CommandArgCount-1][j] = '\0';
			CommandArgCount++;
			j = 0;
			if ( CommandArgCount >3) { uprintf("Too many arguments!\r\n"); return 0; }
		}
		if ( j >= MONITOR_MAX_ARG_LENGTH ) { uprintf("Too long argument!\r\n"); return 0;}
 8000b42:	480d      	ldr	r0, [pc, #52]	; (8000b78 <MONITOR_CommandSeparate+0xa0>)
 8000b44:	f7ff fcc8 	bl	80004d8 <uprintf>
 8000b48:	2000      	movs	r0, #0
 8000b4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} // End of copies

	argv[CommandArgCount-1][j] = '\0';							// Last argument's end

	if ( CommandArgCount < 3 ) argv[2][0] = '\0';				// 3. argument is empty
 8000b4c:	68ab      	ldr	r3, [r5, #8]
	if ( CommandArgCount < 2 ) argv[1][0] = '\0';				// 2. argument is empty
 8000b4e:	2e01      	cmp	r6, #1
		if ( j >= MONITOR_MAX_ARG_LENGTH ) { uprintf("Too long argument!\r\n"); return 0;}
	} // End of copies

	argv[CommandArgCount-1][j] = '\0';							// Last argument's end

	if ( CommandArgCount < 3 ) argv[2][0] = '\0';				// 3. argument is empty
 8000b50:	701a      	strb	r2, [r3, #0]
	if ( CommandArgCount < 2 ) argv[1][0] = '\0';				// 2. argument is empty
 8000b52:	d109      	bne.n	8000b68 <MONITOR_CommandSeparate+0x90>
 8000b54:	6843      	ldr	r3, [r0, #4]
 8000b56:	2200      	movs	r2, #0
 8000b58:	701a      	strb	r2, [r3, #0]
 8000b5a:	2001      	movs	r0, #1
 8000b5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		}
		else {													// It's space or the end, skip the space
			argv[CommandArgCount-1][j] = '\0';
			CommandArgCount++;
			j = 0;
			if ( CommandArgCount >3) { uprintf("Too many arguments!\r\n"); return 0; }
 8000b5e:	4807      	ldr	r0, [pc, #28]	; (8000b7c <MONITOR_CommandSeparate+0xa4>)
 8000b60:	f7ff fcba 	bl	80004d8 <uprintf>
 8000b64:	2000      	movs	r0, #0
 8000b66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000b68:	2002      	movs	r0, #2
 8000b6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		}
		if ( j >= MONITOR_MAX_ARG_LENGTH ) { uprintf("Too long argument!\r\n"); return 0;}
	} // End of copies

	argv[CommandArgCount-1][j] = '\0';							// Last argument's end
 8000b6c:	6803      	ldr	r3, [r0, #0]
 8000b6e:	701a      	strb	r2, [r3, #0]

	if ( CommandArgCount < 3 ) argv[2][0] = '\0';				// 3. argument is empty
 8000b70:	6883      	ldr	r3, [r0, #8]
 8000b72:	701a      	strb	r2, [r3, #0]
 8000b74:	e7ee      	b.n	8000b54 <MONITOR_CommandSeparate+0x7c>
 8000b76:	bf00      	nop
 8000b78:	08002714 	.word	0x08002714
 8000b7c:	080026fc 	.word	0x080026fc

08000b80 <MONITOR_CommandFind>:
}



// Function: Find the command
uint8_t MONITOR_CommandFind( unsigned int argc, char** argv ) {
 8000b80:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000b84:	4682      	mov	sl, r0
 8000b86:	4688      	mov	r8, r1

	uint8_t i;
	uint8_t CommandValid = 0;
	FunctionPointer	thisFunction;
	uint8_t commandNum = COMMAND_GetCommandNum();
 8000b88:	f000 fca0 	bl	80014cc <COMMAND_GetCommandNum>

	
	// Find the command
	//for (i=0; i < MONITOR_MAX_COMMAND_NUM; i++) {		// Need an correct "MAX_COMMAND_NUM" define
	//for (i=0; CommandList[i].name != NULL; i++) {		// If last command = 0
	for (i=0; i < commandNum; i++) {					// get the command.c "MAX_COMMAND_NUM" define
 8000b8c:	b300      	cbz	r0, 8000bd0 <MONITOR_CommandFind+0x50>
 8000b8e:	2400      	movs	r4, #0
 8000b90:	4607      	mov	r7, r0
 8000b92:	f8df b050 	ldr.w	fp, [pc, #80]	; 8000be4 <MONITOR_CommandFind+0x64>
 8000b96:	4625      	mov	r5, r4
 8000b98:	e003      	b.n	8000ba2 <MONITOR_CommandFind+0x22>
 8000b9a:	3501      	adds	r5, #1
 8000b9c:	b2eb      	uxtb	r3, r5
 8000b9e:	42bb      	cmp	r3, r7
 8000ba0:	d216      	bcs.n	8000bd0 <MONITOR_CommandFind+0x50>
		if (!StrCmp(argv[0],CommandList[i].name)) {						// Found the command
 8000ba2:	f85b 1004 	ldr.w	r1, [fp, r4]
 8000ba6:	f8d8 0000 	ldr.w	r0, [r8]
 8000baa:	f8df 9038 	ldr.w	r9, [pc, #56]	; 8000be4 <MONITOR_CommandFind+0x64>
 8000bae:	f7ff fecb 	bl	8000948 <StrCmp>
 8000bb2:	340c      	adds	r4, #12
 8000bb4:	4606      	mov	r6, r0
 8000bb6:	2800      	cmp	r0, #0
 8000bb8:	d1ef      	bne.n	8000b9a <MONITOR_CommandFind+0x1a>
			thisFunction = ( FunctionPointer )CommandList[i].CommandFunctionPointer;	// execute the command function
 8000bba:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8000bbe:	eb09 0585 	add.w	r5, r9, r5, lsl #2
			thisFunction(argc,argv);
 8000bc2:	4641      	mov	r1, r8
 8000bc4:	686b      	ldr	r3, [r5, #4]
 8000bc6:	4650      	mov	r0, sl
 8000bc8:	4798      	blx	r3
	}
	else {
		return RETURN_FALSE;				// Valid command
	}

}
 8000bca:	4630      	mov	r0, r6
 8000bcc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
	}

	// Valid command or not?
	if (!CommandValid) {
		uprintf("Unknown Command.\r\n");	// Has valid command? If not, throw error text
 8000bd0:	4803      	ldr	r0, [pc, #12]	; (8000be0 <MONITOR_CommandFind+0x60>)
		return RETURN_SUCCESS;
 8000bd2:	2601      	movs	r6, #1
		}
	}

	// Valid command or not?
	if (!CommandValid) {
		uprintf("Unknown Command.\r\n");	// Has valid command? If not, throw error text
 8000bd4:	f7ff fc80 	bl	80004d8 <uprintf>
	}
	else {
		return RETURN_FALSE;				// Valid command
	}

}
 8000bd8:	4630      	mov	r0, r6
 8000bda:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000bde:	bf00      	nop
 8000be0:	0800272c 	.word	0x0800272c
 8000be4:	08002a64 	.word	0x08002a64

08000be8 <MONITOR_EndCommand>:

}


// Function: Prepare (Separate) the command and Find and Run it...
uint8_t MONITOR_EndCommand ( char *CommandActual, unsigned int argc, char** argv  ) {
 8000be8:	b510      	push	{r4, lr}

	// Separate command
	// CommandActual = MONITOR_CommandActual[]
	argc = MONITOR_CommandSeparate ( argv, CommandActual );
 8000bea:	4601      	mov	r1, r0
 8000bec:	4610      	mov	r0, r2

}


// Function: Prepare (Separate) the command and Find and Run it...
uint8_t MONITOR_EndCommand ( char *CommandActual, unsigned int argc, char** argv  ) {
 8000bee:	4614      	mov	r4, r2

	// Separate command
	// CommandActual = MONITOR_CommandActual[]
	argc = MONITOR_CommandSeparate ( argv, CommandActual );
 8000bf0:	f7ff ff72 	bl	8000ad8 <MONITOR_CommandSeparate>

	if ( argc ) {
 8000bf4:	b128      	cbz	r0, 8000c02 <MONITOR_EndCommand+0x1a>
		
		MONITOR_CommandFind ( argc, argv );		// Find and probing execute the command
 8000bf6:	4621      	mov	r1, r4
 8000bf8:	f7ff ffc2 	bl	8000b80 <MONITOR_CommandFind>
		USART_SEND_NEW_LINE();
 8000bfc:	4803      	ldr	r0, [pc, #12]	; (8000c0c <MONITOR_EndCommand+0x24>)
 8000bfe:	f7ff fbfd 	bl	80003fc <USART_SendMessage>
	}
	//else USART_SEND_NEW_LINE();				// argc == 0

	
	// Init new command
	MONITOR_SEND_PROMT();
 8000c02:	4803      	ldr	r0, [pc, #12]	; (8000c10 <MONITOR_EndCommand+0x28>)
 8000c04:	f7ff fbfa 	bl	80003fc <USART_SendMessage>

	return RETURN_SUCCESS;
}
 8000c08:	2001      	movs	r0, #1
 8000c0a:	bd10      	pop	{r4, pc}
 8000c0c:	08002778 	.word	0x08002778
 8000c10:	080026f4 	.word	0x080026f4

08000c14 <MONITOR_CommandBackspace>:


/*
\brief			Command's letter deleting (backspace)
*/
uint8_t MONITOR_CommandBackspace ( void ) {
 8000c14:	b538      	push	{r3, r4, r5, lr}
	uint8_t i;

	if (MONITOR_CommandActualLength > 0) {
 8000c16:	4d28      	ldr	r5, [pc, #160]	; (8000cb8 <MONITOR_CommandBackspace+0xa4>)
 8000c18:	782b      	ldrb	r3, [r5, #0]
 8000c1a:	2b00      	cmp	r3, #0
 8000c1c:	d035      	beq.n	8000c8a <MONITOR_CommandBackspace+0x76>

		if ( MONITOR_CommandCursorPosition == MONITOR_CommandActualLength) {
 8000c1e:	4b27      	ldr	r3, [pc, #156]	; (8000cbc <MONITOR_CommandBackspace+0xa8>)
 8000c20:	7819      	ldrb	r1, [r3, #0]
 8000c22:	782a      	ldrb	r2, [r5, #0]
 8000c24:	4291      	cmp	r1, r2
			MONITOR_CommandActual[--MONITOR_CommandCursorPosition] = '\0';	// del from CommandActual, and Position--
 8000c26:	781a      	ldrb	r2, [r3, #0]
uint8_t MONITOR_CommandBackspace ( void ) {
	uint8_t i;

	if (MONITOR_CommandActualLength > 0) {

		if ( MONITOR_CommandCursorPosition == MONITOR_CommandActualLength) {
 8000c28:	d031      	beq.n	8000c8e <MONITOR_CommandBackspace+0x7a>
#endif

		}
		else {										// CursorPosition != CommandLength, we are in command chars

			if ( MONITOR_CommandCursorPosition > 0 ) {			// not at 0 position
 8000c2a:	2a00      	cmp	r2, #0
 8000c2c:	d02d      	beq.n	8000c8a <MONITOR_CommandBackspace+0x76>
				// delete line
				// save cursor
				// send new command
				// restore cursor

				MONITOR_CommandActualLength--;
 8000c2e:	782a      	ldrb	r2, [r5, #0]
 8000c30:	4c23      	ldr	r4, [pc, #140]	; (8000cc0 <MONITOR_CommandBackspace+0xac>)
 8000c32:	3a01      	subs	r2, #1
 8000c34:	b2d2      	uxtb	r2, r2
 8000c36:	702a      	strb	r2, [r5, #0]
				MONITOR_CommandCursorPosition--;
 8000c38:	781a      	ldrb	r2, [r3, #0]
 8000c3a:	3a01      	subs	r2, #1
 8000c3c:	b2d2      	uxtb	r2, r2
 8000c3e:	701a      	strb	r2, [r3, #0]

				for ( i = MONITOR_CommandCursorPosition; i < MONITOR_CommandActualLength; i++ ) {
 8000c40:	781b      	ldrb	r3, [r3, #0]
 8000c42:	782a      	ldrb	r2, [r5, #0]
 8000c44:	b2db      	uxtb	r3, r3
 8000c46:	4293      	cmp	r3, r2
 8000c48:	d207      	bcs.n	8000c5a <MONITOR_CommandBackspace+0x46>
					MONITOR_CommandActual[i] = MONITOR_CommandActual[i+1];		// copy
 8000c4a:	1c59      	adds	r1, r3, #1
 8000c4c:	5c62      	ldrb	r2, [r4, r1]
 8000c4e:	b2d2      	uxtb	r2, r2
 8000c50:	54e2      	strb	r2, [r4, r3]
				// restore cursor

				MONITOR_CommandActualLength--;
				MONITOR_CommandCursorPosition--;

				for ( i = MONITOR_CommandCursorPosition; i < MONITOR_CommandActualLength; i++ ) {
 8000c52:	782a      	ldrb	r2, [r5, #0]
 8000c54:	b2cb      	uxtb	r3, r1
 8000c56:	4293      	cmp	r3, r2
 8000c58:	d3f7      	bcc.n	8000c4a <MONITOR_CommandBackspace+0x36>
					MONITOR_CommandActual[i] = MONITOR_CommandActual[i+1];		// copy
				}
				MONITOR_CommandActual[i] = '\0';
 8000c5a:	2200      	movs	r2, #0

				// Send backspace
				USART_SEND_KEY_BACKSPACE();
 8000c5c:	2008      	movs	r0, #8
				MONITOR_CommandCursorPosition--;

				for ( i = MONITOR_CommandCursorPosition; i < MONITOR_CommandActualLength; i++ ) {
					MONITOR_CommandActual[i] = MONITOR_CommandActual[i+1];		// copy
				}
				MONITOR_CommandActual[i] = '\0';
 8000c5e:	54e2      	strb	r2, [r4, r3]

				// Send backspace
				USART_SEND_KEY_BACKSPACE();
 8000c60:	f7ff fbfc 	bl	800045c <USART_SendChar>

				// Delete this line
				USART_ESCAPE_DELETELINE();
 8000c64:	4817      	ldr	r0, [pc, #92]	; (8000cc4 <MONITOR_CommandBackspace+0xb0>)
 8000c66:	f7ff fbc9 	bl	80003fc <USART_SendMessage>

				// Save the cursor ( we need backup this, because the user's cursor is stand this position
				USART_ESCAPE_SAVECURSOR();
 8000c6a:	4817      	ldr	r0, [pc, #92]	; (8000cc8 <MONITOR_CommandBackspace+0xb4>)
 8000c6c:	f7ff fbc6 	bl	80003fc <USART_SendMessage>

				// Cursor to line start -> we want write the "CommandActual"
				USART_ESCAPE_CURSOR_TO_LINESTART();
 8000c70:	4816      	ldr	r0, [pc, #88]	; (8000ccc <MONITOR_CommandBackspace+0xb8>)
 8000c72:	f7ff fbc3 	bl	80003fc <USART_SendMessage>
				USART_ESCAPE_CURSORLEFTLOTOF();
 8000c76:	4816      	ldr	r0, [pc, #88]	; (8000cd0 <MONITOR_CommandBackspace+0xbc>)
 8000c78:	f7ff fbc0 	bl	80003fc <USART_SendMessage>

				// Write new CommandActual
				uprintf("# %s",MONITOR_CommandActual);
 8000c7c:	4815      	ldr	r0, [pc, #84]	; (8000cd4 <MONITOR_CommandBackspace+0xc0>)
 8000c7e:	4910      	ldr	r1, [pc, #64]	; (8000cc0 <MONITOR_CommandBackspace+0xac>)
 8000c80:	f7ff fc2a 	bl	80004d8 <uprintf>

				// restore the position
				USART_ESCAPE_RESTORECURSOR();
 8000c84:	4814      	ldr	r0, [pc, #80]	; (8000cd8 <MONITOR_CommandBackspace+0xc4>)
 8000c86:	f7ff fbb9 	bl	80003fc <USART_SendMessage>
			}
		}
	}
	return RETURN_SUCCESS;			// not do anything
}
 8000c8a:	2001      	movs	r0, #1
 8000c8c:	bd38      	pop	{r3, r4, r5, pc}
	uint8_t i;

	if (MONITOR_CommandActualLength > 0) {

		if ( MONITOR_CommandCursorPosition == MONITOR_CommandActualLength) {
			MONITOR_CommandActual[--MONITOR_CommandCursorPosition] = '\0';	// del from CommandActual, and Position--
 8000c8e:	3a01      	subs	r2, #1
 8000c90:	b2d2      	uxtb	r2, r2
 8000c92:	490b      	ldr	r1, [pc, #44]	; (8000cc0 <MONITOR_CommandBackspace+0xac>)
 8000c94:	701a      	strb	r2, [r3, #0]
 8000c96:	2000      	movs	r0, #0
 8000c98:	5488      	strb	r0, [r1, r2]
			MONITOR_CommandActualLength--;
 8000c9a:	782b      	ldrb	r3, [r5, #0]
 8000c9c:	3b01      	subs	r3, #1
 8000c9e:	b2db      	uxtb	r3, r3
			
#ifdef CONFIG_USE_TERMINAL_ZOC
			USART_SEND_KEY_BACKSPACE();
 8000ca0:	2008      	movs	r0, #8

	if (MONITOR_CommandActualLength > 0) {

		if ( MONITOR_CommandCursorPosition == MONITOR_CommandActualLength) {
			MONITOR_CommandActual[--MONITOR_CommandCursorPosition] = '\0';	// del from CommandActual, and Position--
			MONITOR_CommandActualLength--;
 8000ca2:	702b      	strb	r3, [r5, #0]
			
#ifdef CONFIG_USE_TERMINAL_ZOC
			USART_SEND_KEY_BACKSPACE();
 8000ca4:	f7ff fbda 	bl	800045c <USART_SendChar>
			USART_SEND_KEY_DEL();
 8000ca8:	207f      	movs	r0, #127	; 0x7f
 8000caa:	f7ff fbd7 	bl	800045c <USART_SendChar>
			USART_SEND_KEY_BACKSPACE();
 8000cae:	2008      	movs	r0, #8
 8000cb0:	f7ff fbd4 	bl	800045c <USART_SendChar>
 8000cb4:	e7e9      	b.n	8000c8a <MONITOR_CommandBackspace+0x76>
 8000cb6:	bf00      	nop
 8000cb8:	20000521 	.word	0x20000521
 8000cbc:	2000092b 	.word	0x2000092b
 8000cc0:	2000082c 	.word	0x2000082c
 8000cc4:	08002740 	.word	0x08002740
 8000cc8:	08002748 	.word	0x08002748
 8000ccc:	0800274c 	.word	0x0800274c
 8000cd0:	08002754 	.word	0x08002754
 8000cd4:	0800275c 	.word	0x0800275c
 8000cd8:	08002764 	.word	0x08002764

08000cdc <MONITOR_CommandResendLine>:


/*
\brief		Resend the actual line/command
*/
uint8_t MONITOR_CommandResendLine ( void ) {
 8000cdc:	b508      	push	{r3, lr}

	//step right
	USART_ESCAPE_CURSORRIGHT();
 8000cde:	480c      	ldr	r0, [pc, #48]	; (8000d10 <MONITOR_CommandResendLine+0x34>)
 8000ce0:	f7ff fb8c 	bl	80003fc <USART_SendMessage>

	// Delete the line
	USART_ESCAPE_DELETELINE();
 8000ce4:	480b      	ldr	r0, [pc, #44]	; (8000d14 <MONITOR_CommandResendLine+0x38>)
 8000ce6:	f7ff fb89 	bl	80003fc <USART_SendMessage>

	// Save cursor
	USART_ESCAPE_SAVECURSOR();
 8000cea:	480b      	ldr	r0, [pc, #44]	; (8000d18 <MONITOR_CommandResendLine+0x3c>)
 8000cec:	f7ff fb86 	bl	80003fc <USART_SendMessage>

	// Cursor to line start
	USART_ESCAPE_CURSOR_TO_LINESTART();
 8000cf0:	480a      	ldr	r0, [pc, #40]	; (8000d1c <MONITOR_CommandResendLine+0x40>)
 8000cf2:	f7ff fb83 	bl	80003fc <USART_SendMessage>
	USART_ESCAPE_CURSORLEFTLOTOF();
 8000cf6:	480a      	ldr	r0, [pc, #40]	; (8000d20 <MONITOR_CommandResendLine+0x44>)
 8000cf8:	f7ff fb80 	bl	80003fc <USART_SendMessage>

	// Write new CommandActual
	uprintf("# %s",MONITOR_CommandActual);
 8000cfc:	4909      	ldr	r1, [pc, #36]	; (8000d24 <MONITOR_CommandResendLine+0x48>)
 8000cfe:	480a      	ldr	r0, [pc, #40]	; (8000d28 <MONITOR_CommandResendLine+0x4c>)
 8000d00:	f7ff fbea 	bl	80004d8 <uprintf>

	// Restore the position
	USART_ESCAPE_RESTORECURSOR();
 8000d04:	4809      	ldr	r0, [pc, #36]	; (8000d2c <MONITOR_CommandResendLine+0x50>)
 8000d06:	f7ff fb79 	bl	80003fc <USART_SendMessage>

	return RETURN_SUCCESS;
}
 8000d0a:	2001      	movs	r0, #1
 8000d0c:	bd08      	pop	{r3, pc}
 8000d0e:	bf00      	nop
 8000d10:	08002768 	.word	0x08002768
 8000d14:	08002740 	.word	0x08002740
 8000d18:	08002748 	.word	0x08002748
 8000d1c:	0800274c 	.word	0x0800274c
 8000d20:	08002754 	.word	0x08002754
 8000d24:	2000082c 	.word	0x2000082c
 8000d28:	0800275c 	.word	0x0800275c
 8000d2c:	08002764 	.word	0x08002764

08000d30 <MONITOR_NewCommandResendLine>:


/*
\brief		Resend an new line/command
*/
uint8_t MONITOR_NewCommandResendLine ( void ) {
 8000d30:	b508      	push	{r3, lr}

	// Delete the line
	USART_ESCAPE_DELETELINE();
 8000d32:	4807      	ldr	r0, [pc, #28]	; (8000d50 <MONITOR_NewCommandResendLine+0x20>)
 8000d34:	f7ff fb62 	bl	80003fc <USART_SendMessage>

	// Cursor to line start
	USART_ESCAPE_CURSOR_TO_LINESTART();
 8000d38:	4806      	ldr	r0, [pc, #24]	; (8000d54 <MONITOR_NewCommandResendLine+0x24>)
 8000d3a:	f7ff fb5f 	bl	80003fc <USART_SendMessage>
	USART_ESCAPE_CURSORLEFTLOTOF();
 8000d3e:	4806      	ldr	r0, [pc, #24]	; (8000d58 <MONITOR_NewCommandResendLine+0x28>)
 8000d40:	f7ff fb5c 	bl	80003fc <USART_SendMessage>

	// Write new CommandActual
	uprintf("# %s",MONITOR_CommandActual);
 8000d44:	4905      	ldr	r1, [pc, #20]	; (8000d5c <MONITOR_NewCommandResendLine+0x2c>)
 8000d46:	4806      	ldr	r0, [pc, #24]	; (8000d60 <MONITOR_NewCommandResendLine+0x30>)
 8000d48:	f7ff fbc6 	bl	80004d8 <uprintf>

	return RETURN_SUCCESS;
}
 8000d4c:	2001      	movs	r0, #1
 8000d4e:	bd08      	pop	{r3, pc}
 8000d50:	08002740 	.word	0x08002740
 8000d54:	0800274c 	.word	0x0800274c
 8000d58:	08002754 	.word	0x08002754
 8000d5c:	2000082c 	.word	0x2000082c
 8000d60:	0800275c 	.word	0x0800275c

08000d64 <MONITOR_HISTORY_Save>:



#ifdef USE_MONITOR_HISTORY
uint8_t MONITOR_HISTORY_Save ( void )
{
 8000d64:	b570      	push	{r4, r5, r6, lr}
 8000d66:	4e11      	ldr	r6, [pc, #68]	; (8000dac <MONITOR_HISTORY_Save+0x48>)
 8000d68:	4634      	mov	r4, r6
 8000d6a:	f206 45fb 	addw	r5, r6, #1275	; 0x4fb
{
	int i;
	
	for ( i = 0; i < MONITOR_MAX_HISTORY_LENGTH; i++ )
	{
		if ( !StrCmp((const char *)MONITOR_HISTORY[i],(const char * )MONITOR_CommandActual))	// If it is equal
 8000d6e:	4620      	mov	r0, r4
 8000d70:	490f      	ldr	r1, [pc, #60]	; (8000db0 <MONITOR_HISTORY_Save+0x4c>)
 8000d72:	f7ff fde9 	bl	8000948 <StrCmp>
 8000d76:	34ff      	adds	r4, #255	; 0xff
 8000d78:	b188      	cbz	r0, 8000d9e <MONITOR_HISTORY_Save+0x3a>
#ifdef USE_MONITOR_HISTORY
uint8_t MONITOR_HISTORY_IsInIt ( void )
{
	int i;
	
	for ( i = 0; i < MONITOR_MAX_HISTORY_LENGTH; i++ )
 8000d7a:	42a5      	cmp	r5, r4
 8000d7c:	d1f7      	bne.n	8000d6e <MONITOR_HISTORY_Save+0xa>
	if ( MONITOR_HISTORY_IsInIt() == RETURN_SUCCESS )	// Ha van egyezo
	{
		return RETURN_SUCCESS;
	}

	if ( MONITOR_HISTORY_Save_cnt >= ( MONITOR_MAX_HISTORY_LENGTH-1 ) )
 8000d7e:	4a0d      	ldr	r2, [pc, #52]	; (8000db4 <MONITOR_HISTORY_Save+0x50>)
 8000d80:	7813      	ldrb	r3, [r2, #0]
 8000d82:	2b03      	cmp	r3, #3
 8000d84:	d80d      	bhi.n	8000da2 <MONITOR_HISTORY_Save+0x3e>
	{
		MONITOR_HISTORY_Save_cnt = 0;
	}
	else
	{
		MONITOR_HISTORY_Save_cnt++;
 8000d86:	3301      	adds	r3, #1
 8000d88:	b2db      	uxtb	r3, r3
 8000d8a:	7013      	strb	r3, [r2, #0]
 8000d8c:	4618      	mov	r0, r3
	}
	MONITOR_HISTORY_Load_cnt = MONITOR_HISTORY_Save_cnt;	// amit most gepeltunk be, az az utolso


	StrCpy ( MONITOR_HISTORY[MONITOR_HISTORY_Save_cnt], (char *)MONITOR_CommandActual );
 8000d8e:	ebc0 2000 	rsb	r0, r0, r0, lsl #8
	}
	else
	{
		MONITOR_HISTORY_Save_cnt++;
	}
	MONITOR_HISTORY_Load_cnt = MONITOR_HISTORY_Save_cnt;	// amit most gepeltunk be, az az utolso
 8000d92:	4a09      	ldr	r2, [pc, #36]	; (8000db8 <MONITOR_HISTORY_Save+0x54>)


	StrCpy ( MONITOR_HISTORY[MONITOR_HISTORY_Save_cnt], (char *)MONITOR_CommandActual );
 8000d94:	4906      	ldr	r1, [pc, #24]	; (8000db0 <MONITOR_HISTORY_Save+0x4c>)
	}
	else
	{
		MONITOR_HISTORY_Save_cnt++;
	}
	MONITOR_HISTORY_Load_cnt = MONITOR_HISTORY_Save_cnt;	// amit most gepeltunk be, az az utolso
 8000d96:	7013      	strb	r3, [r2, #0]


	StrCpy ( MONITOR_HISTORY[MONITOR_HISTORY_Save_cnt], (char *)MONITOR_CommandActual );
 8000d98:	4430      	add	r0, r6
 8000d9a:	f7ff fded 	bl	8000978 <StrCpy>


	return RETURN_SUCCESS;

}
 8000d9e:	2001      	movs	r0, #1
 8000da0:	bd70      	pop	{r4, r5, r6, pc}
		return RETURN_SUCCESS;
	}

	if ( MONITOR_HISTORY_Save_cnt >= ( MONITOR_MAX_HISTORY_LENGTH-1 ) )
	{
		MONITOR_HISTORY_Save_cnt = 0;
 8000da2:	2300      	movs	r3, #0
 8000da4:	4618      	mov	r0, r3
 8000da6:	7013      	strb	r3, [r2, #0]
 8000da8:	e7f1      	b.n	8000d8e <MONITOR_HISTORY_Save+0x2a>
 8000daa:	bf00      	nop
 8000dac:	20000004 	.word	0x20000004
 8000db0:	2000082c 	.word	0x2000082c
 8000db4:	20000000 	.word	0x20000000
 8000db8:	20000001 	.word	0x20000001

08000dbc <MONITOR_HISTORY_Load>:



#ifdef USE_MONITOR_HISTORY
uint8_t MONITOR_HISTORY_Load ( uint8_t direction )
{
 8000dbc:	b538      	push	{r3, r4, r5, lr}

	// down cursor
	if ( direction == 0 ) // direction == 0
 8000dbe:	4604      	mov	r4, r0
 8000dc0:	b9d0      	cbnz	r0, 8000df8 <MONITOR_HISTORY_Load+0x3c>
	{
		if ( MONITOR_HISTORY_Load_cnt >= ( MONITOR_MAX_HISTORY_LENGTH-1 ) )
 8000dc2:	4a1d      	ldr	r2, [pc, #116]	; (8000e38 <MONITOR_HISTORY_Load+0x7c>)
	}

	// up cursor
	// if direction == 1, masolhato azonnal az aktualis

	StrCpy ( (char *)MONITOR_CommandActual, (const char *)MONITOR_HISTORY[MONITOR_HISTORY_Load_cnt]);
 8000dc4:	491d      	ldr	r1, [pc, #116]	; (8000e3c <MONITOR_HISTORY_Load+0x80>)
{

	// down cursor
	if ( direction == 0 ) // direction == 0
	{
		if ( MONITOR_HISTORY_Load_cnt >= ( MONITOR_MAX_HISTORY_LENGTH-1 ) )
 8000dc6:	7813      	ldrb	r3, [r2, #0]
	}

	// up cursor
	// if direction == 1, masolhato azonnal az aktualis

	StrCpy ( (char *)MONITOR_CommandActual, (const char *)MONITOR_HISTORY[MONITOR_HISTORY_Load_cnt]);
 8000dc8:	481d      	ldr	r0, [pc, #116]	; (8000e40 <MONITOR_HISTORY_Load+0x84>)
{

	// down cursor
	if ( direction == 0 ) // direction == 0
	{
		if ( MONITOR_HISTORY_Load_cnt >= ( MONITOR_MAX_HISTORY_LENGTH-1 ) )
 8000dca:	2b03      	cmp	r3, #3
		{
			MONITOR_HISTORY_Load_cnt = 0;
		}
		else
		{
			MONITOR_HISTORY_Load_cnt++;
 8000dcc:	bf9c      	itt	ls
 8000dce:	1c5c      	addls	r4, r3, #1
 8000dd0:	b2e4      	uxtbls	r4, r4
 8000dd2:	7014      	strb	r4, [r2, #0]
	}

	// up cursor
	// if direction == 1, masolhato azonnal az aktualis

	StrCpy ( (char *)MONITOR_CommandActual, (const char *)MONITOR_HISTORY[MONITOR_HISTORY_Load_cnt]);
 8000dd4:	ebc4 2404 	rsb	r4, r4, r4, lsl #8
 8000dd8:	4421      	add	r1, r4
 8000dda:	f7ff fdcd 	bl	8000978 <StrCpy>

	// cursor, length!
	MONITOR_CommandCursorPosition = StringLength((char *)MONITOR_CommandActual);
 8000dde:	4818      	ldr	r0, [pc, #96]	; (8000e40 <MONITOR_HISTORY_Load+0x84>)
 8000de0:	f7ff fda4 	bl	800092c <StringLength>
 8000de4:	4b17      	ldr	r3, [pc, #92]	; (8000e44 <MONITOR_HISTORY_Load+0x88>)
	MONITOR_CommandActualLength = MONITOR_CommandCursorPosition;
 8000de6:	4a18      	ldr	r2, [pc, #96]	; (8000e48 <MONITOR_HISTORY_Load+0x8c>)
	// if direction == 1, masolhato azonnal az aktualis

	StrCpy ( (char *)MONITOR_CommandActual, (const char *)MONITOR_HISTORY[MONITOR_HISTORY_Load_cnt]);

	// cursor, length!
	MONITOR_CommandCursorPosition = StringLength((char *)MONITOR_CommandActual);
 8000de8:	7018      	strb	r0, [r3, #0]
	MONITOR_CommandActualLength = MONITOR_CommandCursorPosition;
 8000dea:	781b      	ldrb	r3, [r3, #0]
 8000dec:	b2db      	uxtb	r3, r3
 8000dee:	7013      	strb	r3, [r2, #0]

	MONITOR_NewCommandResendLine ();
 8000df0:	f7ff ff9e 	bl	8000d30 <MONITOR_NewCommandResendLine>
	}


	return RETURN_SUCCESS;

}
 8000df4:	2001      	movs	r0, #1
 8000df6:	bd38      	pop	{r3, r4, r5, pc}
	}

	// up cursor
	// if direction == 1, masolhato azonnal az aktualis

	StrCpy ( (char *)MONITOR_CommandActual, (const char *)MONITOR_HISTORY[MONITOR_HISTORY_Load_cnt]);
 8000df8:	4d0f      	ldr	r5, [pc, #60]	; (8000e38 <MONITOR_HISTORY_Load+0x7c>)
 8000dfa:	4910      	ldr	r1, [pc, #64]	; (8000e3c <MONITOR_HISTORY_Load+0x80>)
 8000dfc:	782b      	ldrb	r3, [r5, #0]
 8000dfe:	4810      	ldr	r0, [pc, #64]	; (8000e40 <MONITOR_HISTORY_Load+0x84>)
 8000e00:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
 8000e04:	4419      	add	r1, r3
 8000e06:	f7ff fdb7 	bl	8000978 <StrCpy>

	// cursor, length!
	MONITOR_CommandCursorPosition = StringLength((char *)MONITOR_CommandActual);
 8000e0a:	480d      	ldr	r0, [pc, #52]	; (8000e40 <MONITOR_HISTORY_Load+0x84>)
 8000e0c:	f7ff fd8e 	bl	800092c <StringLength>
 8000e10:	4b0c      	ldr	r3, [pc, #48]	; (8000e44 <MONITOR_HISTORY_Load+0x88>)
	MONITOR_CommandActualLength = MONITOR_CommandCursorPosition;
 8000e12:	4a0d      	ldr	r2, [pc, #52]	; (8000e48 <MONITOR_HISTORY_Load+0x8c>)
	// if direction == 1, masolhato azonnal az aktualis

	StrCpy ( (char *)MONITOR_CommandActual, (const char *)MONITOR_HISTORY[MONITOR_HISTORY_Load_cnt]);

	// cursor, length!
	MONITOR_CommandCursorPosition = StringLength((char *)MONITOR_CommandActual);
 8000e14:	7018      	strb	r0, [r3, #0]
	MONITOR_CommandActualLength = MONITOR_CommandCursorPosition;
 8000e16:	781b      	ldrb	r3, [r3, #0]
 8000e18:	b2db      	uxtb	r3, r3
 8000e1a:	7013      	strb	r3, [r2, #0]

	MONITOR_NewCommandResendLine ();
 8000e1c:	f7ff ff88 	bl	8000d30 <MONITOR_NewCommandResendLine>


	if ( direction == 1 ) // direction == 0
 8000e20:	2c01      	cmp	r4, #1
 8000e22:	d1e7      	bne.n	8000df4 <MONITOR_HISTORY_Load+0x38>
	{
		if ( MONITOR_HISTORY_Load_cnt <= 0 )
 8000e24:	782b      	ldrb	r3, [r5, #0]
 8000e26:	b11b      	cbz	r3, 8000e30 <MONITOR_HISTORY_Load+0x74>
		{
			MONITOR_HISTORY_Load_cnt = MONITOR_MAX_HISTORY_LENGTH-1;
		}
		else
		{
			MONITOR_HISTORY_Load_cnt--;
 8000e28:	3b01      	subs	r3, #1
 8000e2a:	702b      	strb	r3, [r5, #0]
	}


	return RETURN_SUCCESS;

}
 8000e2c:	2001      	movs	r0, #1
 8000e2e:	bd38      	pop	{r3, r4, r5, pc}

	if ( direction == 1 ) // direction == 0
	{
		if ( MONITOR_HISTORY_Load_cnt <= 0 )
		{
			MONITOR_HISTORY_Load_cnt = MONITOR_MAX_HISTORY_LENGTH-1;
 8000e30:	2304      	movs	r3, #4
 8000e32:	702b      	strb	r3, [r5, #0]
	}


	return RETURN_SUCCESS;

}
 8000e34:	2001      	movs	r0, #1
 8000e36:	bd38      	pop	{r3, r4, r5, pc}
 8000e38:	20000001 	.word	0x20000001
 8000e3c:	20000004 	.word	0x20000004
 8000e40:	2000082c 	.word	0x2000082c
 8000e44:	2000092b 	.word	0x2000092b
 8000e48:	20000521 	.word	0x20000521

08000e4c <MONITOR_CommandEscapeCharValidation>:


/*
\brief		Process Excape sequence
*/
uint8_t MONITOR_CommandEscapeCharValidation ( void ) {
 8000e4c:	b510      	push	{r4, lr}
	// return valid char, or 0 if invalid
	// work with ANSI escape codes

	if (MONITOR_CommandActualEscape[0] == '\x1B') { 								// ESC
 8000e4e:	4b1e      	ldr	r3, [pc, #120]	; (8000ec8 <MONITOR_CommandEscapeCharValidation+0x7c>)
 8000e50:	781a      	ldrb	r2, [r3, #0]
 8000e52:	2a1b      	cmp	r2, #27
 8000e54:	d001      	beq.n	8000e5a <MONITOR_CommandEscapeCharValidation+0xe>
			return RETURN_FALSE;
		}
	}
	else
	{
		return RETURN_FALSE;
 8000e56:	2000      	movs	r0, #0
 8000e58:	bd10      	pop	{r4, pc}
uint8_t MONITOR_CommandEscapeCharValidation ( void ) {
	// return valid char, or 0 if invalid
	// work with ANSI escape codes

	if (MONITOR_CommandActualEscape[0] == '\x1B') { 								// ESC
		if ( MONITOR_CommandActualEscape[1] == '[' )							// '[', escape sequence 2. letter
 8000e5a:	785a      	ldrb	r2, [r3, #1]
 8000e5c:	2a5b      	cmp	r2, #91	; 0x5b
 8000e5e:	d1fa      	bne.n	8000e56 <MONITOR_CommandEscapeCharValidation+0xa>
		{
			// This is an escape sequence
			if ( MONITOR_CommandActualEscape[2] == 'A' )						// Up cursor		// previous History command
 8000e60:	789a      	ldrb	r2, [r3, #2]
 8000e62:	2a41      	cmp	r2, #65	; 0x41
 8000e64:	d01c      	beq.n	8000ea0 <MONITOR_CommandEscapeCharValidation+0x54>
				#ifdef USE_MONITOR_HISTORY
				MONITOR_HISTORY_Load ( 1 );
				#endif
				return RETURN_SUCCESS;
			}
			else if ( MONITOR_CommandActualEscape[2] == 'B' )					// Down cursor		// next History command
 8000e66:	789a      	ldrb	r2, [r3, #2]
 8000e68:	2a42      	cmp	r2, #66	; 0x42
 8000e6a:	d027      	beq.n	8000ebc <MONITOR_CommandEscapeCharValidation+0x70>
				#ifdef USE_MONITOR_HISTORY
				MONITOR_HISTORY_Load ( 0 );
				#endif
				return RETURN_SUCCESS;
			}
			else if (  MONITOR_CommandActualEscape[2] == 'C' )					// Right cursor
 8000e6c:	789a      	ldrb	r2, [r3, #2]
 8000e6e:	2a43      	cmp	r2, #67	; 0x43
 8000e70:	d007      	beq.n	8000e82 <MONITOR_CommandEscapeCharValidation+0x36>
					MONITOR_CommandCursorPosition++;
					return RETURN_SUCCESS;
				}
				else return RETURN_SUCCESS;								// not do anything
			}
			else if (  MONITOR_CommandActualEscape[2] == 'D' )	{		// Left cursor
 8000e72:	789b      	ldrb	r3, [r3, #2]
 8000e74:	2b44      	cmp	r3, #68	; 0x44
 8000e76:	d1ee      	bne.n	8000e56 <MONITOR_CommandEscapeCharValidation+0xa>
				if ( MONITOR_CommandCursorPosition > 0 )				// if not at start
 8000e78:	4c14      	ldr	r4, [pc, #80]	; (8000ecc <MONITOR_CommandEscapeCharValidation+0x80>)
 8000e7a:	7823      	ldrb	r3, [r4, #0]
 8000e7c:	b9ab      	cbnz	r3, 8000eaa <MONITOR_CommandEscapeCharValidation+0x5e>
				{
					USART_ESCAPE_CURSORRIGHT();
					MONITOR_CommandCursorPosition++;
					return RETURN_SUCCESS;
				}
				else return RETURN_SUCCESS;								// not do anything
 8000e7e:	2001      	movs	r0, #1
		return RETURN_FALSE;
	}

	return RETURN_FALSE;

}
 8000e80:	bd10      	pop	{r4, pc}
				#endif
				return RETURN_SUCCESS;
			}
			else if (  MONITOR_CommandActualEscape[2] == 'C' )					// Right cursor
			{
				if ( MONITOR_CommandCursorPosition < MONITOR_CommandActualLength )	// if not at end
 8000e82:	4c12      	ldr	r4, [pc, #72]	; (8000ecc <MONITOR_CommandEscapeCharValidation+0x80>)
 8000e84:	4b12      	ldr	r3, [pc, #72]	; (8000ed0 <MONITOR_CommandEscapeCharValidation+0x84>)
 8000e86:	7822      	ldrb	r2, [r4, #0]
 8000e88:	781b      	ldrb	r3, [r3, #0]
 8000e8a:	429a      	cmp	r2, r3
 8000e8c:	d2f7      	bcs.n	8000e7e <MONITOR_CommandEscapeCharValidation+0x32>
				{
					USART_ESCAPE_CURSORRIGHT();
 8000e8e:	4811      	ldr	r0, [pc, #68]	; (8000ed4 <MONITOR_CommandEscapeCharValidation+0x88>)
 8000e90:	f7ff fab4 	bl	80003fc <USART_SendMessage>
					MONITOR_CommandCursorPosition++;
 8000e94:	7823      	ldrb	r3, [r4, #0]
 8000e96:	3301      	adds	r3, #1
 8000e98:	b2db      	uxtb	r3, r3
 8000e9a:	7023      	strb	r3, [r4, #0]
 8000e9c:	2001      	movs	r0, #1
 8000e9e:	bd10      	pop	{r4, pc}
		{
			// This is an escape sequence
			if ( MONITOR_CommandActualEscape[2] == 'A' )						// Up cursor		// previous History command
			{
				#ifdef USE_MONITOR_HISTORY
				MONITOR_HISTORY_Load ( 1 );
 8000ea0:	2001      	movs	r0, #1
 8000ea2:	f7ff ff8b 	bl	8000dbc <MONITOR_HISTORY_Load>
				#endif
				return RETURN_SUCCESS;
 8000ea6:	2001      	movs	r0, #1
 8000ea8:	bd10      	pop	{r4, pc}
				else return RETURN_SUCCESS;								// not do anything
			}
			else if (  MONITOR_CommandActualEscape[2] == 'D' )	{		// Left cursor
				if ( MONITOR_CommandCursorPosition > 0 )				// if not at start
				{
					USART_ESCAPE_CURSORLEFT();
 8000eaa:	480b      	ldr	r0, [pc, #44]	; (8000ed8 <MONITOR_CommandEscapeCharValidation+0x8c>)
 8000eac:	f7ff faa6 	bl	80003fc <USART_SendMessage>
					MONITOR_CommandCursorPosition--;
 8000eb0:	7823      	ldrb	r3, [r4, #0]
 8000eb2:	3b01      	subs	r3, #1
 8000eb4:	b2db      	uxtb	r3, r3
 8000eb6:	7023      	strb	r3, [r4, #0]
					return RETURN_SUCCESS;
 8000eb8:	2001      	movs	r0, #1
 8000eba:	bd10      	pop	{r4, pc}
				return RETURN_SUCCESS;
			}
			else if ( MONITOR_CommandActualEscape[2] == 'B' )					// Down cursor		// next History command
			{
				#ifdef USE_MONITOR_HISTORY
				MONITOR_HISTORY_Load ( 0 );
 8000ebc:	2000      	movs	r0, #0
 8000ebe:	f7ff ff7d 	bl	8000dbc <MONITOR_HISTORY_Load>
				#endif
				return RETURN_SUCCESS;
 8000ec2:	2001      	movs	r0, #1
 8000ec4:	bd10      	pop	{r4, pc}
 8000ec6:	bf00      	nop
 8000ec8:	20000930 	.word	0x20000930
 8000ecc:	2000092b 	.word	0x2000092b
 8000ed0:	20000521 	.word	0x20000521
 8000ed4:	08002768 	.word	0x08002768
 8000ed8:	0800276c 	.word	0x0800276c

08000edc <MONITOR_CheckCommand>:
}



// Function: Always run, wait command and execute it
uint8_t MONITOR_CheckCommand ( void ) {
 8000edc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	argc = 0;
	
	// Initialize - End

	// TODO: átalakítani, jelenleg nincs értelme, mert RxBufferbe másolunk
	MONITOR_CommandEnable = 1;	// !! IMPORTANT !! Last initialize
 8000ee0:	4eab      	ldr	r6, [pc, #684]	; (8001190 <MONITOR_CheckCommand+0x2b4>)
 8000ee2:	f8df 82ec 	ldr.w	r8, [pc, #748]	; 80011d0 <MONITOR_CheckCommand+0x2f4>
 8000ee6:	f8df a2c8 	ldr.w	sl, [pc, #712]	; 80011b0 <MONITOR_CheckCommand+0x2d4>
 8000eea:	4daa      	ldr	r5, [pc, #680]	; (8001194 <MONITOR_CheckCommand+0x2b8>)
 8000eec:	f8df b2e4 	ldr.w	fp, [pc, #740]	; 80011d4 <MONITOR_CheckCommand+0x2f8>
 8000ef0:	4ca9      	ldr	r4, [pc, #676]	; (8001198 <MONITOR_CheckCommand+0x2bc>)
 8000ef2:	f8df 92e4 	ldr.w	r9, [pc, #740]	; 80011d8 <MONITOR_CheckCommand+0x2fc>
				}
				else
				{
					// simple char for the command
					// Receive an char
					if ( MONITOR_CommandActualLength < MONITOR_MAX_COMMAND_LENGTH )	// shorted than max length?
 8000ef6:	4fa9      	ldr	r7, [pc, #676]	; (800119c <MONITOR_CheckCommand+0x2c0>)
}



// Function: Always run, wait command and execute it
uint8_t MONITOR_CheckCommand ( void ) {
 8000ef8:	b0a3      	sub	sp, #140	; 0x8c

	char CommandArg1[MONITOR_MAX_ARG_LENGTH];
	char CommandArg2[MONITOR_MAX_ARG_LENGTH];
	char CommandArg3[MONITOR_MAX_ARG_LENGTH];

	argv[0] = CommandArg1;
 8000efa:	a904      	add	r1, sp, #16
	argv[1] = CommandArg2;
 8000efc:	aa0e      	add	r2, sp, #56	; 0x38
	argv[2] = CommandArg3;
 8000efe:	ab18      	add	r3, sp, #96	; 0x60
	argc = 0;
	
	// Initialize - End

	// TODO: átalakítani, jelenleg nincs értelme, mert RxBufferbe másolunk
	MONITOR_CommandEnable = 1;	// !! IMPORTANT !! Last initialize
 8000f00:	2001      	movs	r0, #1
 8000f02:	7030      	strb	r0, [r6, #0]

	char CommandArg1[MONITOR_MAX_ARG_LENGTH];
	char CommandArg2[MONITOR_MAX_ARG_LENGTH];
	char CommandArg3[MONITOR_MAX_ARG_LENGTH];

	argv[0] = CommandArg1;
 8000f04:	9101      	str	r1, [sp, #4]
	argv[1] = CommandArg2;
 8000f06:	9202      	str	r2, [sp, #8]
	argv[2] = CommandArg3;
 8000f08:	9303      	str	r3, [sp, #12]
	//HAL_UART_Receive_IT(&BluetoothUartHandle, (uint8_t *)USART_RxBuffer, RXBUFFERSIZE);	// TODO: VG - USART - TEST - uzenetvaras

	
	
	// Welcome message
	MONITOR_SendPrimitiveWelcome();
 8000f0a:	f7ff fdc5 	bl	8000a98 <MONITOR_SendPrimitiveWelcome>
	// Enable sendings
#endif


	// Start receive
	USART_ReceiveMessage();
 8000f0e:	f7ff fad5 	bl	80004bc <USART_ReceiveMessage>


static void ProcessReceivedCharacter(void)
{

	while (USART_RxBufferReadCnt!=USART_RxBufferWriteCounter)
 8000f12:	4646      	mov	r6, r8
	USART_ReceiveMessage();

	while (1)
	{
		// always checking the Command
		if ( MONITOR_CommandEnable )
 8000f14:	4b9e      	ldr	r3, [pc, #632]	; (8001190 <MONITOR_CheckCommand+0x2b4>)
 8000f16:	781b      	ldrb	r3, [r3, #0]
 8000f18:	2b00      	cmp	r3, #0
 8000f1a:	d0fb      	beq.n	8000f14 <MONITOR_CheckCommand+0x38>


static void ProcessReceivedCharacter(void)
{

	while (USART_RxBufferReadCnt!=USART_RxBufferWriteCounter)
 8000f1c:	f898 2000 	ldrb.w	r2, [r8]
 8000f20:	f899 3000 	ldrb.w	r3, [r9]
 8000f24:	429a      	cmp	r2, r3
 8000f26:	d07c      	beq.n	8001022 <MONITOR_CheckCommand+0x146>
	{
		volatile char USART_ReceivedChar = '\0';
 8000f28:	2200      	movs	r2, #0
 8000f2a:	f88d 2003 	strb.w	r2, [sp, #3]

		// TODO: Don't know, why work...
		USART_ReceivedChar = USART_RxBuffer[USART_RxBufferReadCnt-1];
 8000f2e:	7833      	ldrb	r3, [r6, #0]
 8000f30:	3b01      	subs	r3, #1
 8000f32:	f81b 3003 	ldrb.w	r3, [fp, r3]
 8000f36:	b2db      	uxtb	r3, r3
 8000f38:	f88d 3003 	strb.w	r3, [sp, #3]
		USART_RxBufferReadCnt++;
 8000f3c:	7833      	ldrb	r3, [r6, #0]
 8000f3e:	3301      	adds	r3, #1
 8000f40:	b2db      	uxtb	r3, r3
 8000f42:	7033      	strb	r3, [r6, #0]

		// ESCAPE SEQUENCE
		if ( MONITOR_CommandEscapeSequenceInProgress == 1 )
 8000f44:	f89a 3000 	ldrb.w	r3, [sl]
 8000f48:	b2db      	uxtb	r3, r3
 8000f4a:	2b01      	cmp	r3, #1
 8000f4c:	d048      	beq.n	8000fe0 <MONITOR_CheckCommand+0x104>
		else
		{
			// No escape sequence
			// An character received

			if ( USART_ReceivedChar  == '\x1B')	// 'ESC'
 8000f4e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8000f52:	2b1b      	cmp	r3, #27
 8000f54:	f000 80b7 	beq.w	80010c6 <MONITOR_CheckCommand+0x1ea>
				MONITOR_CommandEscape_cnt = 1;
				//MONITOR_CommandEvent = 1;
			}
			else
			{
				if ( (USART_ReceivedChar  == '\r') || (USART_ReceivedChar == '\n') ||
 8000f58:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8000f5c:	2b0d      	cmp	r3, #13
 8000f5e:	f000 80dc 	beq.w	800111a <MONITOR_CheckCommand+0x23e>
 8000f62:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8000f66:	2b0a      	cmp	r3, #10
 8000f68:	f000 80d7 	beq.w	800111a <MONITOR_CheckCommand+0x23e>
					(USART_ReceivedChar == '\0'))
 8000f6c:	f89d 3003 	ldrb.w	r3, [sp, #3]
				MONITOR_CommandEscape_cnt = 1;
				//MONITOR_CommandEvent = 1;
			}
			else
			{
				if ( (USART_ReceivedChar  == '\r') || (USART_ReceivedChar == '\n') ||
 8000f70:	2b00      	cmp	r3, #0
 8000f72:	f000 80d2 	beq.w	800111a <MONITOR_CheckCommand+0x23e>
					MONITOR_CommandReadable = 1;
					MONITOR_CommandActual[MONITOR_CommandActualLength] = '\0';
					MONITOR_CommandEvent = 1;
					return;
				}
				else if ( USART_ReceivedChar  == USART_KEY_DELETE )
 8000f76:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8000f7a:	2b7f      	cmp	r3, #127	; 0x7f
 8000f7c:	f000 80e3 	beq.w	8001146 <MONITOR_CheckCommand+0x26a>
				}
				else
				{
					// simple char for the command
					// Receive an char
					if ( MONITOR_CommandActualLength < MONITOR_MAX_COMMAND_LENGTH )	// shorted than max length?
 8000f80:	4b86      	ldr	r3, [pc, #536]	; (800119c <MONITOR_CheckCommand+0x2c0>)
 8000f82:	781b      	ldrb	r3, [r3, #0]
 8000f84:	2bff      	cmp	r3, #255	; 0xff
 8000f86:	d0c9      	beq.n	8000f1c <MONITOR_CheckCommand+0x40>
					{
						if ( MONITOR_CommandCursorPosition == MONITOR_CommandActualLength )
 8000f88:	782a      	ldrb	r2, [r5, #0]
 8000f8a:	783b      	ldrb	r3, [r7, #0]
 8000f8c:	429a      	cmp	r2, r3
						{	// CursorPosition = CommandLength		(end character)
							MONITOR_CommandActual[MONITOR_CommandActualLength] = USART_ReceivedChar;
 8000f8e:	783b      	ldrb	r3, [r7, #0]
				{
					// simple char for the command
					// Receive an char
					if ( MONITOR_CommandActualLength < MONITOR_MAX_COMMAND_LENGTH )	// shorted than max length?
					{
						if ( MONITOR_CommandCursorPosition == MONITOR_CommandActualLength )
 8000f90:	f000 80ac 	beq.w	80010ec <MONITOR_CheckCommand+0x210>
							USART_SendChar( USART_ReceivedChar );
						}
						else
						{
							// CursorPosition < CommandLength		(inner character)
							MONITOR_CommandActualLength++;
 8000f94:	3301      	adds	r3, #1
 8000f96:	b2db      	uxtb	r3, r3
 8000f98:	703b      	strb	r3, [r7, #0]
							// Copy
							for ( uint8_t i = MONITOR_CommandActualLength; i > MONITOR_CommandCursorPosition; i-- )
 8000f9a:	4a7e      	ldr	r2, [pc, #504]	; (8001194 <MONITOR_CheckCommand+0x2b8>)
 8000f9c:	783b      	ldrb	r3, [r7, #0]
 8000f9e:	7812      	ldrb	r2, [r2, #0]
 8000fa0:	b2db      	uxtb	r3, r3
 8000fa2:	4293      	cmp	r3, r2
 8000fa4:	d907      	bls.n	8000fb6 <MONITOR_CheckCommand+0xda>
							{
								MONITOR_CommandActual[i] = MONITOR_CommandActual[i-1];
 8000fa6:	1e59      	subs	r1, r3, #1
 8000fa8:	5c62      	ldrb	r2, [r4, r1]
 8000faa:	b2d2      	uxtb	r2, r2
 8000fac:	54e2      	strb	r2, [r4, r3]
						else
						{
							// CursorPosition < CommandLength		(inner character)
							MONITOR_CommandActualLength++;
							// Copy
							for ( uint8_t i = MONITOR_CommandActualLength; i > MONITOR_CommandCursorPosition; i-- )
 8000fae:	782a      	ldrb	r2, [r5, #0]
 8000fb0:	b2cb      	uxtb	r3, r1
 8000fb2:	4293      	cmp	r3, r2
 8000fb4:	d8f7      	bhi.n	8000fa6 <MONITOR_CheckCommand+0xca>
							{
								MONITOR_CommandActual[i] = MONITOR_CommandActual[i-1];
							}
							MONITOR_CommandActual [MONITOR_CommandCursorPosition] = USART_ReceivedChar;
 8000fb6:	782b      	ldrb	r3, [r5, #0]
 8000fb8:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8000fbc:	b2db      	uxtb	r3, r3
 8000fbe:	b2d2      	uxtb	r2, r2
 8000fc0:	54e2      	strb	r2, [r4, r3]
							MONITOR_CommandActual [MONITOR_CommandActualLength] = '\0';
 8000fc2:	4b76      	ldr	r3, [pc, #472]	; (800119c <MONITOR_CheckCommand+0x2c0>)
 8000fc4:	781b      	ldrb	r3, [r3, #0]
 8000fc6:	b2db      	uxtb	r3, r3
 8000fc8:	2200      	movs	r2, #0
 8000fca:	54e2      	strb	r2, [r4, r3]
							MONITOR_CommandCursorPosition++;
 8000fcc:	782b      	ldrb	r3, [r5, #0]
 8000fce:	3301      	adds	r3, #1
 8000fd0:	b2db      	uxtb	r3, r3
 8000fd2:	702b      	strb	r3, [r5, #0]
							MONITOR_CommandReceivedNotLastChar = 1;
 8000fd4:	4b72      	ldr	r3, [pc, #456]	; (80011a0 <MONITOR_CheckCommand+0x2c4>)
 8000fd6:	2201      	movs	r2, #1
 8000fd8:	701a      	strb	r2, [r3, #0]
							MONITOR_CommandEvent = 1;
 8000fda:	4b72      	ldr	r3, [pc, #456]	; (80011a4 <MONITOR_CheckCommand+0x2c8>)
 8000fdc:	701a      	strb	r2, [r3, #0]
 8000fde:	e79d      	b.n	8000f1c <MONITOR_CheckCommand+0x40>
		if ( MONITOR_CommandEscapeSequenceInProgress == 1 )
		{
			// Escape sequence in progress
			// Copy escape characters to MONITOR_CommandActualEscape[]

			if (MONITOR_CommandEscape_cnt == 1)
 8000fe0:	4871      	ldr	r0, [pc, #452]	; (80011a8 <MONITOR_CheckCommand+0x2cc>)
 8000fe2:	f890 e000 	ldrb.w	lr, [r0]
 8000fe6:	f1be 0f01 	cmp.w	lr, #1
 8000fea:	d077      	beq.n	80010dc <MONITOR_CheckCommand+0x200>
					// Wrong escape sequence
					MONITOR_CommandEscapeSequenceInProgress = 0;
					MONITOR_CommandEscape_cnt = 0;
				}
			}
			else if ( MONITOR_CommandEscape_cnt == 2)
 8000fec:	f890 e000 	ldrb.w	lr, [r0]
 8000ff0:	f1be 0f02 	cmp.w	lr, #2
 8000ff4:	d192      	bne.n	8000f1c <MONITOR_CheckCommand+0x40>
			{
				// TODO: only work with escape sequence if 3 chars (ESC[A)
				MONITOR_CommandActualEscape[MONITOR_CommandEscape_cnt++] = USART_ReceivedChar;
 8000ff6:	f890 e000 	ldrb.w	lr, [r0]
 8000ffa:	496c      	ldr	r1, [pc, #432]	; (80011ac <MONITOR_CheckCommand+0x2d0>)
 8000ffc:	fa5f fe8e 	uxtb.w	lr, lr
 8001000:	f10e 0c01 	add.w	ip, lr, #1
 8001004:	fa5f fc8c 	uxtb.w	ip, ip
 8001008:	f880 c000 	strb.w	ip, [r0]
 800100c:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8001010:	b2c0      	uxtb	r0, r0
 8001012:	f801 000e 	strb.w	r0, [r1, lr]
				MONITOR_CommandEscapeSequenceInProgress = 0;
 8001016:	4966      	ldr	r1, [pc, #408]	; (80011b0 <MONITOR_CheckCommand+0x2d4>)
 8001018:	700a      	strb	r2, [r1, #0]
				MONITOR_CommandEscapeSequenceReceived = 1;
 800101a:	4a66      	ldr	r2, [pc, #408]	; (80011b4 <MONITOR_CheckCommand+0x2d8>)
 800101c:	7013      	strb	r3, [r2, #0]
				MONITOR_CommandEvent = 1;
 800101e:	4a61      	ldr	r2, [pc, #388]	; (80011a4 <MONITOR_CheckCommand+0x2c8>)
 8001020:	7013      	strb	r3, [r2, #0]

			// Check and process received characters
			ProcessReceivedCharacter();


			if ( MONITOR_CommandEvent )
 8001022:	4b60      	ldr	r3, [pc, #384]	; (80011a4 <MONITOR_CheckCommand+0x2c8>)
 8001024:	4a5f      	ldr	r2, [pc, #380]	; (80011a4 <MONITOR_CheckCommand+0x2c8>)
 8001026:	781b      	ldrb	r3, [r3, #0]
 8001028:	2b00      	cmp	r3, #0
 800102a:	f43f af73 	beq.w	8000f14 <MONITOR_CheckCommand+0x38>
			{
				MONITOR_CommandEvent = 0;
 800102e:	2300      	movs	r3, #0
 8001030:	7013      	strb	r3, [r2, #0]


				if ( MONITOR_CommandReceivedNotLastChar )
 8001032:	4a5b      	ldr	r2, [pc, #364]	; (80011a0 <MONITOR_CheckCommand+0x2c4>)
 8001034:	485a      	ldr	r0, [pc, #360]	; (80011a0 <MONITOR_CheckCommand+0x2c4>)
 8001036:	7812      	ldrb	r2, [r2, #0]
 8001038:	f002 01ff 	and.w	r1, r2, #255	; 0xff
 800103c:	2a00      	cmp	r2, #0
 800103e:	f040 8088 	bne.w	8001152 <MONITOR_CheckCommand+0x276>
					MONITOR_CommandEnable = 0;
					MONITOR_CommandReceivedNotLastChar = 0;
					MONITOR_CommandResendLine();
					MONITOR_CommandEnable = 1;
				}
				else if ( MONITOR_CommandEscapeSequenceReceived )
 8001042:	4b5c      	ldr	r3, [pc, #368]	; (80011b4 <MONITOR_CheckCommand+0x2d8>)
 8001044:	485b      	ldr	r0, [pc, #364]	; (80011b4 <MONITOR_CheckCommand+0x2d8>)
 8001046:	781b      	ldrb	r3, [r3, #0]
 8001048:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800104c:	2b00      	cmp	r3, #0
 800104e:	f040 8089 	bne.w	8001164 <MONITOR_CheckCommand+0x288>
					MONITOR_CommandEnable = 0;
					MONITOR_CommandEscapeSequenceReceived = 0;
					MONITOR_CommandEscapeCharValidation ();
					MONITOR_CommandEnable = 1;
				}
				else if ( MONITOR_CommandReceivedBackspace )
 8001052:	4b59      	ldr	r3, [pc, #356]	; (80011b8 <MONITOR_CheckCommand+0x2dc>)
 8001054:	7819      	ldrb	r1, [r3, #0]
 8001056:	4618      	mov	r0, r3
 8001058:	f001 03ff 	and.w	r3, r1, #255	; 0xff
 800105c:	2900      	cmp	r1, #0
 800105e:	f040 808a 	bne.w	8001176 <MONITOR_CheckCommand+0x29a>
					MONITOR_CommandEnable = 0;
					MONITOR_CommandReceivedBackspace = 0;
					MONITOR_CommandBackspace();
					MONITOR_CommandEnable = 1;
				}
				else if ( MONITOR_CommandReadable )
 8001062:	4a56      	ldr	r2, [pc, #344]	; (80011bc <MONITOR_CheckCommand+0x2e0>)
 8001064:	7811      	ldrb	r1, [r2, #0]
 8001066:	2900      	cmp	r1, #0
 8001068:	f43f af54 	beq.w	8000f14 <MONITOR_CheckCommand+0x38>
				{
					// Pressed Enter, EndCommand();
					MONITOR_CommandEnable = 0;			// Disable
 800106c:	4948      	ldr	r1, [pc, #288]	; (8001190 <MONITOR_CheckCommand+0x2b4>)
 800106e:	700b      	strb	r3, [r1, #0]
					MONITOR_CommandReadable = 0;
 8001070:	7013      	strb	r3, [r2, #0]
					if ( MONITOR_CommandActualLength > 0)
 8001072:	4a4a      	ldr	r2, [pc, #296]	; (800119c <MONITOR_CheckCommand+0x2c0>)
 8001074:	7812      	ldrb	r2, [r2, #0]
 8001076:	2a00      	cmp	r2, #0
 8001078:	f000 8086 	beq.w	8001188 <MONITOR_CheckCommand+0x2ac>
*/
uint8_t MONITOR_ConvertSmallLetter( void )
{
	int i;
	
	for ( i = 0; MONITOR_CommandActual[i] != '\0'; i++ )
 800107c:	7822      	ldrb	r2, [r4, #0]
 800107e:	b172      	cbz	r2, 800109e <MONITOR_CheckCommand+0x1c2>
	{
		if ( ( MONITOR_CommandActual[i] > 'A' ) && ( MONITOR_CommandActual[i] < 'Z' ) )
 8001080:	4945      	ldr	r1, [pc, #276]	; (8001198 <MONITOR_CheckCommand+0x2bc>)
 8001082:	5ce2      	ldrb	r2, [r4, r3]
 8001084:	2a41      	cmp	r2, #65	; 0x41
 8001086:	d906      	bls.n	8001096 <MONITOR_CheckCommand+0x1ba>
 8001088:	5cca      	ldrb	r2, [r1, r3]
 800108a:	2a59      	cmp	r2, #89	; 0x59
 800108c:	d803      	bhi.n	8001096 <MONITOR_CheckCommand+0x1ba>
		{	// need to change to small letter
			MONITOR_CommandActual[i] = MONITOR_CommandActual[i] - ( 'A' - 'a'); // length between Big Letter and small letter
 800108e:	5cca      	ldrb	r2, [r1, r3]
 8001090:	3220      	adds	r2, #32
 8001092:	b2d2      	uxtb	r2, r2
 8001094:	54ca      	strb	r2, [r1, r3]
*/
uint8_t MONITOR_ConvertSmallLetter( void )
{
	int i;
	
	for ( i = 0; MONITOR_CommandActual[i] != '\0'; i++ )
 8001096:	3301      	adds	r3, #1
 8001098:	5ce2      	ldrb	r2, [r4, r3]
 800109a:	2a00      	cmp	r2, #0
 800109c:	d1f1      	bne.n	8001082 <MONITOR_CheckCommand+0x1a6>
					{
						// There are some char in the line
						// has an command
						MONITOR_ConvertSmallLetter();
						
						USART_SEND_NEW_LINE();
 800109e:	4848      	ldr	r0, [pc, #288]	; (80011c0 <MONITOR_CheckCommand+0x2e4>)
 80010a0:	f7ff f9ac 	bl	80003fc <USART_SendMessage>
						
						// TODO: 1. parametert kiszedni
						MONITOR_EndCommand ( (char *)MONITOR_CommandActual, argc, argv );	// Parancs megkeresÃ©se Ã©s futtatÃ¡si kÃ­sÃ©rlet		
 80010a4:	aa01      	add	r2, sp, #4
 80010a6:	2100      	movs	r1, #0
 80010a8:	483b      	ldr	r0, [pc, #236]	; (8001198 <MONITOR_CheckCommand+0x2bc>)
 80010aa:	f7ff fd9d 	bl	8000be8 <MONITOR_EndCommand>
						
						#ifdef USE_MONITOR_HISTORY
						MONITOR_HISTORY_Save ();											// History-ba lementÃ©s
 80010ae:	f7ff fe59 	bl	8000d64 <MONITOR_HISTORY_Save>
					}
					else {																	// There is no char in the line	
						//USART_SEND_NEW_LINE();											
						MONITOR_SEND_PROMT();
					}
					MONITOR_CommandActualLength = 0;
 80010b2:	493a      	ldr	r1, [pc, #232]	; (800119c <MONITOR_CheckCommand+0x2c0>)
 80010b4:	2300      	movs	r3, #0
 80010b6:	700b      	strb	r3, [r1, #0]
					MONITOR_CommandSentLength = 0;
 80010b8:	4942      	ldr	r1, [pc, #264]	; (80011c4 <MONITOR_CheckCommand+0x2e8>)
 80010ba:	700b      	strb	r3, [r1, #0]
					MONITOR_CommandCursorPosition = 0;
 80010bc:	702b      	strb	r3, [r5, #0]
					MONITOR_CommandEnable = 1;
 80010be:	4b34      	ldr	r3, [pc, #208]	; (8001190 <MONITOR_CheckCommand+0x2b4>)
 80010c0:	2201      	movs	r2, #1
 80010c2:	701a      	strb	r2, [r3, #0]
 80010c4:	e726      	b.n	8000f14 <MONITOR_CheckCommand+0x38>
			// An character received

			if ( USART_ReceivedChar  == '\x1B')	// 'ESC'
			{
				// receive an Escape sequence
				MONITOR_CommandEscapeSequenceInProgress = 1;
 80010c6:	4b3a      	ldr	r3, [pc, #232]	; (80011b0 <MONITOR_CheckCommand+0x2d4>)
				MONITOR_CommandActualEscape[0] = USART_ReceivedChar;
 80010c8:	4938      	ldr	r1, [pc, #224]	; (80011ac <MONITOR_CheckCommand+0x2d0>)
			// An character received

			if ( USART_ReceivedChar  == '\x1B')	// 'ESC'
			{
				// receive an Escape sequence
				MONITOR_CommandEscapeSequenceInProgress = 1;
 80010ca:	2201      	movs	r2, #1
 80010cc:	701a      	strb	r2, [r3, #0]
				MONITOR_CommandActualEscape[0] = USART_ReceivedChar;
 80010ce:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80010d2:	b2db      	uxtb	r3, r3
 80010d4:	700b      	strb	r3, [r1, #0]
				MONITOR_CommandEscape_cnt = 1;
 80010d6:	4b34      	ldr	r3, [pc, #208]	; (80011a8 <MONITOR_CheckCommand+0x2cc>)
 80010d8:	701a      	strb	r2, [r3, #0]
 80010da:	e71f      	b.n	8000f1c <MONITOR_CheckCommand+0x40>
			// Escape sequence in progress
			// Copy escape characters to MONITOR_CommandActualEscape[]

			if (MONITOR_CommandEscape_cnt == 1)
			{
				if (USART_ReceivedChar == '[')
 80010dc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80010e0:	2b5b      	cmp	r3, #91	; 0x5b
 80010e2:	d025      	beq.n	8001130 <MONITOR_CheckCommand+0x254>
					MONITOR_CommandActualEscape[MONITOR_CommandEscape_cnt++] = USART_ReceivedChar;
				}
				else
				{
					// Wrong escape sequence
					MONITOR_CommandEscapeSequenceInProgress = 0;
 80010e4:	4b32      	ldr	r3, [pc, #200]	; (80011b0 <MONITOR_CheckCommand+0x2d4>)
 80010e6:	701a      	strb	r2, [r3, #0]
					MONITOR_CommandEscape_cnt = 0;
 80010e8:	7002      	strb	r2, [r0, #0]
 80010ea:	e717      	b.n	8000f1c <MONITOR_CheckCommand+0x40>
					// Receive an char
					if ( MONITOR_CommandActualLength < MONITOR_MAX_COMMAND_LENGTH )	// shorted than max length?
					{
						if ( MONITOR_CommandCursorPosition == MONITOR_CommandActualLength )
						{	// CursorPosition = CommandLength		(end character)
							MONITOR_CommandActual[MONITOR_CommandActualLength] = USART_ReceivedChar;
 80010ec:	f89d 2003 	ldrb.w	r2, [sp, #3]
							MONITOR_CommandActualLength++;
							MONITOR_CommandCursorPosition++;
 80010f0:	4928      	ldr	r1, [pc, #160]	; (8001194 <MONITOR_CheckCommand+0x2b8>)
					// Receive an char
					if ( MONITOR_CommandActualLength < MONITOR_MAX_COMMAND_LENGTH )	// shorted than max length?
					{
						if ( MONITOR_CommandCursorPosition == MONITOR_CommandActualLength )
						{	// CursorPosition = CommandLength		(end character)
							MONITOR_CommandActual[MONITOR_CommandActualLength] = USART_ReceivedChar;
 80010f2:	b2db      	uxtb	r3, r3
 80010f4:	b2d2      	uxtb	r2, r2
 80010f6:	54e2      	strb	r2, [r4, r3]
							MONITOR_CommandActualLength++;
 80010f8:	783b      	ldrb	r3, [r7, #0]
 80010fa:	3301      	adds	r3, #1
 80010fc:	b2db      	uxtb	r3, r3
 80010fe:	703b      	strb	r3, [r7, #0]
							MONITOR_CommandCursorPosition++;
 8001100:	4b24      	ldr	r3, [pc, #144]	; (8001194 <MONITOR_CheckCommand+0x2b8>)
 8001102:	781b      	ldrb	r3, [r3, #0]
 8001104:	3301      	adds	r3, #1
 8001106:	b2db      	uxtb	r3, r3
 8001108:	700b      	strb	r3, [r1, #0]
							MONITOR_CommandReceivedLastChar = 1;
 800110a:	4b2f      	ldr	r3, [pc, #188]	; (80011c8 <MONITOR_CheckCommand+0x2ec>)
 800110c:	2201      	movs	r2, #1
 800110e:	701a      	strb	r2, [r3, #0]
							USART_SendChar( USART_ReceivedChar );
 8001110:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8001114:	f7ff f9a2 	bl	800045c <USART_SendChar>
 8001118:	e700      	b.n	8000f1c <MONITOR_CheckCommand+0x40>
			else
			{
				if ( (USART_ReceivedChar  == '\r') || (USART_ReceivedChar == '\n') ||
					(USART_ReceivedChar == '\0'))
				{		// receive Enter
					MONITOR_CommandReadable = 1;
 800111a:	4b28      	ldr	r3, [pc, #160]	; (80011bc <MONITOR_CheckCommand+0x2e0>)
 800111c:	2201      	movs	r2, #1
 800111e:	701a      	strb	r2, [r3, #0]
					MONITOR_CommandActual[MONITOR_CommandActualLength] = '\0';
 8001120:	4b1e      	ldr	r3, [pc, #120]	; (800119c <MONITOR_CheckCommand+0x2c0>)
 8001122:	781b      	ldrb	r3, [r3, #0]
 8001124:	b2db      	uxtb	r3, r3
 8001126:	2100      	movs	r1, #0
 8001128:	54e1      	strb	r1, [r4, r3]
					MONITOR_CommandEvent = 1;
 800112a:	4b1e      	ldr	r3, [pc, #120]	; (80011a4 <MONITOR_CheckCommand+0x2c8>)
 800112c:	701a      	strb	r2, [r3, #0]
 800112e:	e778      	b.n	8001022 <MONITOR_CheckCommand+0x146>

			if (MONITOR_CommandEscape_cnt == 1)
			{
				if (USART_ReceivedChar == '[')
				{
					MONITOR_CommandActualEscape[MONITOR_CommandEscape_cnt++] = USART_ReceivedChar;
 8001130:	7803      	ldrb	r3, [r0, #0]
 8001132:	491e      	ldr	r1, [pc, #120]	; (80011ac <MONITOR_CheckCommand+0x2d0>)
 8001134:	b2db      	uxtb	r3, r3
 8001136:	1c5a      	adds	r2, r3, #1
 8001138:	b2d2      	uxtb	r2, r2
 800113a:	7002      	strb	r2, [r0, #0]
 800113c:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8001140:	b2d2      	uxtb	r2, r2
 8001142:	54ca      	strb	r2, [r1, r3]
 8001144:	e6ea      	b.n	8000f1c <MONITOR_CheckCommand+0x40>
					return;
				}
				else if ( USART_ReceivedChar  == USART_KEY_DELETE )
				{
					// In real world this is backspace	// PuTTy vs ZOC
					MONITOR_CommandReceivedBackspace = 1;
 8001146:	4a1c      	ldr	r2, [pc, #112]	; (80011b8 <MONITOR_CheckCommand+0x2dc>)
 8001148:	2301      	movs	r3, #1
 800114a:	7013      	strb	r3, [r2, #0]
					MONITOR_CommandEvent = 1;
 800114c:	4a15      	ldr	r2, [pc, #84]	; (80011a4 <MONITOR_CheckCommand+0x2c8>)
 800114e:	7013      	strb	r3, [r2, #0]
 8001150:	e767      	b.n	8001022 <MONITOR_CheckCommand+0x146>


				if ( MONITOR_CommandReceivedNotLastChar )
				{
					// Nost Last char - Refresh the line
					MONITOR_CommandEnable = 0;
 8001152:	4a0f      	ldr	r2, [pc, #60]	; (8001190 <MONITOR_CheckCommand+0x2b4>)
 8001154:	7013      	strb	r3, [r2, #0]
					MONITOR_CommandReceivedNotLastChar = 0;
 8001156:	7003      	strb	r3, [r0, #0]
					MONITOR_CommandResendLine();
 8001158:	f7ff fdc0 	bl	8000cdc <MONITOR_CommandResendLine>
					MONITOR_CommandEnable = 1;
 800115c:	4a0c      	ldr	r2, [pc, #48]	; (8001190 <MONITOR_CheckCommand+0x2b4>)
 800115e:	2301      	movs	r3, #1
 8001160:	7013      	strb	r3, [r2, #0]
 8001162:	e6d7      	b.n	8000f14 <MONITOR_CheckCommand+0x38>
				}
				else if ( MONITOR_CommandEscapeSequenceReceived )
				{
					// Escape sequence
					MONITOR_CommandEnable = 0;
 8001164:	4b0a      	ldr	r3, [pc, #40]	; (8001190 <MONITOR_CheckCommand+0x2b4>)
 8001166:	7019      	strb	r1, [r3, #0]
					MONITOR_CommandEscapeSequenceReceived = 0;
 8001168:	7001      	strb	r1, [r0, #0]
					MONITOR_CommandEscapeCharValidation ();
 800116a:	f7ff fe6f 	bl	8000e4c <MONITOR_CommandEscapeCharValidation>
					MONITOR_CommandEnable = 1;
 800116e:	4a08      	ldr	r2, [pc, #32]	; (8001190 <MONITOR_CheckCommand+0x2b4>)
 8001170:	2301      	movs	r3, #1
 8001172:	7013      	strb	r3, [r2, #0]
 8001174:	e6ce      	b.n	8000f14 <MONITOR_CheckCommand+0x38>
				}
				else if ( MONITOR_CommandReceivedBackspace )
				{
					// Backspace
					MONITOR_CommandEnable = 0;
 8001176:	4b06      	ldr	r3, [pc, #24]	; (8001190 <MONITOR_CheckCommand+0x2b4>)
 8001178:	701a      	strb	r2, [r3, #0]
					MONITOR_CommandReceivedBackspace = 0;
 800117a:	7002      	strb	r2, [r0, #0]
					MONITOR_CommandBackspace();
 800117c:	f7ff fd4a 	bl	8000c14 <MONITOR_CommandBackspace>
					MONITOR_CommandEnable = 1;
 8001180:	4a03      	ldr	r2, [pc, #12]	; (8001190 <MONITOR_CheckCommand+0x2b4>)
 8001182:	2301      	movs	r3, #1
 8001184:	7013      	strb	r3, [r2, #0]
 8001186:	e6c5      	b.n	8000f14 <MONITOR_CheckCommand+0x38>
						MONITOR_HISTORY_Save ();											// History-ba lementÃ©s
						#endif
					}
					else {																	// There is no char in the line	
						//USART_SEND_NEW_LINE();											
						MONITOR_SEND_PROMT();
 8001188:	4810      	ldr	r0, [pc, #64]	; (80011cc <MONITOR_CheckCommand+0x2f0>)
 800118a:	f7ff f937 	bl	80003fc <USART_SendMessage>
 800118e:	e790      	b.n	80010b2 <MONITOR_CheckCommand+0x1d6>
 8001190:	20000523 	.word	0x20000523
 8001194:	2000092b 	.word	0x2000092b
 8001198:	2000082c 	.word	0x2000082c
 800119c:	20000521 	.word	0x20000521
 80011a0:	20000827 	.word	0x20000827
 80011a4:	20000824 	.word	0x20000824
 80011a8:	20000934 	.word	0x20000934
 80011ac:	20000930 	.word	0x20000930
 80011b0:	20000828 	.word	0x20000828
 80011b4:	2000092c 	.word	0x2000092c
 80011b8:	20000826 	.word	0x20000826
 80011bc:	20000825 	.word	0x20000825
 80011c0:	08002778 	.word	0x08002778
 80011c4:	20000525 	.word	0x20000525
 80011c8:	20000933 	.word	0x20000933
 80011cc:	080026f4 	.word	0x080026f4
 80011d0:	20000524 	.word	0x20000524
 80011d4:	200005e0 	.word	0x200005e0
 80011d8:	20000520 	.word	0x20000520

080011dc <Error_Handler>:

/*
\brief	Error_Handler - Hibakat feldolgozo fuggveny.
*/
void Error_Handler( void )
{
 80011dc:	e7fe      	b.n	80011dc <Error_Handler>
 80011de:	bf00      	nop

080011e0 <SystemClock_Config>:


#if defined(CONFIG_USE_PANEL_CENTERPANEL) || defined(CONFIG_USE_PANEL_DISCOVERY)

void SystemClock_Config(void)
{
 80011e0:	b510      	push	{r4, lr}
 80011e2:	b08e      	sub	sp, #56	; 0x38

  RCC_OscInitTypeDef RCC_OscInitStruct;

  __PWR_CLK_ENABLE();
 80011e4:	2200      	movs	r2, #0
 80011e6:	4916      	ldr	r1, [pc, #88]	; (8001240 <SystemClock_Config+0x60>)
 80011e8:	9200      	str	r2, [sp, #0]
 80011ea:	6c08      	ldr	r0, [r1, #64]	; 0x40

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80011ec:	4b15      	ldr	r3, [pc, #84]	; (8001244 <SystemClock_Config+0x64>)
void SystemClock_Config(void)
{

  RCC_OscInitTypeDef RCC_OscInitStruct;

  __PWR_CLK_ENABLE();
 80011ee:	f040 5080 	orr.w	r0, r0, #268435456	; 0x10000000
 80011f2:	6408      	str	r0, [r1, #64]	; 0x40
 80011f4:	6c09      	ldr	r1, [r1, #64]	; 0x40
 80011f6:	f001 5180 	and.w	r1, r1, #268435456	; 0x10000000
 80011fa:	9100      	str	r1, [sp, #0]
 80011fc:	9900      	ldr	r1, [sp, #0]

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80011fe:	9201      	str	r2, [sp, #4]
 8001200:	6819      	ldr	r1, [r3, #0]
 8001202:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 8001206:	6019      	str	r1, [r3, #0]
 8001208:	681b      	ldr	r3, [r3, #0]

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 800120a:	9208      	str	r2, [sp, #32]

  RCC_OscInitTypeDef RCC_OscInitStruct;

  __PWR_CLK_ENABLE();

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800120c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8001210:	2102      	movs	r1, #2
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8001212:	2201      	movs	r2, #1

  RCC_OscInitTypeDef RCC_OscInitStruct;

  __PWR_CLK_ENABLE();

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8001214:	9301      	str	r3, [sp, #4]

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8001216:	a802      	add	r0, sp, #8

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
 8001218:	2310      	movs	r3, #16

  __PWR_CLK_ENABLE();

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 800121a:	9102      	str	r1, [sp, #8]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 800121c:	9205      	str	r2, [sp, #20]
  RCC_OscInitStruct.HSICalibrationValue = 16;
 800121e:	9306      	str	r3, [sp, #24]

  RCC_OscInitTypeDef RCC_OscInitStruct;

  __PWR_CLK_ENABLE();

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8001220:	9c01      	ldr	r4, [sp, #4]

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8001222:	f000 fdc7 	bl	8001db4 <HAL_RCC_OscConfig>

  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8001226:	f000 ff51 	bl	80020cc <HAL_RCC_GetHCLKFreq>
 800122a:	4b07      	ldr	r3, [pc, #28]	; (8001248 <SystemClock_Config+0x68>)
 800122c:	fba3 3000 	umull	r3, r0, r3, r0
 8001230:	0980      	lsrs	r0, r0, #6
 8001232:	f001 f8e7 	bl	8002404 <HAL_SYSTICK_Config>

  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 8001236:	2004      	movs	r0, #4
 8001238:	f001 f8fe 	bl	8002438 <HAL_SYSTICK_CLKSourceConfig>

}
 800123c:	b00e      	add	sp, #56	; 0x38
 800123e:	bd10      	pop	{r4, pc}
 8001240:	40023800 	.word	0x40023800
 8001244:	40007000 	.word	0x40007000
 8001248:	10624dd3 	.word	0x10624dd3

0800124c <main>:


//#ifdef CONFIG_USE_PANEL_CENTERPANEL
// TODO:
int main(void)
{
 800124c:	b508      	push	{r3, lr}


	/* MCU Configuration----------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();
 800124e:	f001 f915 	bl	800247c <HAL_Init>

	/* Configure the system clock */
	SystemClock_Config();
 8001252:	f7ff ffc5 	bl	80011e0 <SystemClock_Config>
		Error_Handler();
	}
#endif	//#ifdef CONFIG_USE_FREERTOS
	
	// Monitor
	USART_Init(&Debug_UartHandle);
 8001256:	4804      	ldr	r0, [pc, #16]	; (8001268 <main+0x1c>)
 8001258:	f7ff f806 	bl	8000268 <USART_Init>
	MONITOR_Init();
 800125c:	f7ff fbe6 	bl	8000a2c <MONITOR_Init>
				MONITOR_TASK_PRIORITY, &MONITOR_TaskHandle ) != pdPASS)
	{
		Error_Handler();
	}
#else
	MONITOR_CheckCommand();	// infinite loop
 8001260:	f7ff fe3c 	bl	8000edc <MONITOR_CheckCommand>
 8001264:	e7fe      	b.n	8001264 <main+0x18>
 8001266:	bf00      	nop
 8001268:	200007e0 	.word	0x200007e0

0800126c <CommandFunction_raspberrypi>:
	
#endif
	
	
	return RETURN_SUCCESS;
}
 800126c:	2001      	movs	r0, #1
 800126e:	4770      	bx	lr

08001270 <CommandFunction_cls>:
/*							COMMAND FUNCTIONS 								*/
//////////////////////////////////////////////////////////////////////////////


// Function: cls (clean screen)
uint32_t CommandFunction_cls ( uint32_t argc, char** argv ) {
 8001270:	b508      	push	{r3, lr}

	//(void)argc;
	//(void)argv;
	USART_SEND_CLS();
 8001272:	4804      	ldr	r0, [pc, #16]	; (8001284 <CommandFunction_cls+0x14>)
 8001274:	f7ff f8c2 	bl	80003fc <USART_SendMessage>
 8001278:	4803      	ldr	r0, [pc, #12]	; (8001288 <CommandFunction_cls+0x18>)
 800127a:	f7ff f8bf 	bl	80003fc <USART_SendMessage>

	return RETURN_SUCCESS;
}
 800127e:	2001      	movs	r0, #1
 8001280:	bd08      	pop	{r3, pc}
 8001282:	bf00      	nop
 8001284:	080025fc 	.word	0x080025fc
 8001288:	08002604 	.word	0x08002604

0800128c <CommandFunction_reset>:
}



// Function: reset
uint32_t CommandFunction_reset ( uint32_t argc, char** argv ) {
 800128c:	b508      	push	{r3, lr}
	//(void)argc;
	//(void)argv;
	int i;
	//if ( argc > 1 )	USART_SendString("Too many arguments!\r\n");

	uprintf("Reset...\r\n");
 800128e:	4808      	ldr	r0, [pc, #32]	; (80012b0 <CommandFunction_reset+0x24>)
 8001290:	f7ff f922 	bl	80004d8 <uprintf>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8001294:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8001298:	4906      	ldr	r1, [pc, #24]	; (80012b4 <CommandFunction_reset+0x28>)
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800129a:	4b07      	ldr	r3, [pc, #28]	; (80012b8 <CommandFunction_reset+0x2c>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800129c:	68ca      	ldr	r2, [r1, #12]
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800129e:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 80012a2:	4313      	orrs	r3, r2
 80012a4:	60cb      	str	r3, [r1, #12]
 80012a6:	f3bf 8f4f 	dsb	sy
  \brief   No Operation
  \details No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 80012aa:	bf00      	nop
 80012ac:	e7fd      	b.n	80012aa <CommandFunction_reset+0x1e>
 80012ae:	bf00      	nop
 80012b0:	08002770 	.word	0x08002770
 80012b4:	e000ed00 	.word	0xe000ed00
 80012b8:	05fa0004 	.word	0x05fa0004

080012bc <CommandFunction_test>:
*/



// Function: TEST...
uint32_t CommandFunction_test	( uint32_t argc, char** argv ) {
 80012bc:	b508      	push	{r3, lr}
	//(void)argc;
	//(void)argv;
	//uint8_t i = 0;
	//uint8_t buf[2];
	
	uprintf("Test start:\r\n");
 80012be:	4804      	ldr	r0, [pc, #16]	; (80012d0 <CommandFunction_test+0x14>)
 80012c0:	f7ff f90a 	bl	80004d8 <uprintf>
			"\r\n",
			230,
			520);
	*/

	uprintf("Test end\r\n");
 80012c4:	4803      	ldr	r0, [pc, #12]	; (80012d4 <CommandFunction_test+0x18>)
 80012c6:	f7ff f907 	bl	80004d8 <uprintf>

	return RETURN_SUCCESS;

}
 80012ca:	2001      	movs	r0, #1
 80012cc:	bd08      	pop	{r3, pc}
 80012ce:	bf00      	nop
 80012d0:	0800277c 	.word	0x0800277c
 80012d4:	0800278c 	.word	0x0800278c

080012d8 <CommandFunction_flashdel>:

// Function: Flash erase
// Syntax: flashdel <address> <block/sector>
uint32_t CommandFunction_flashdel	( uint32_t argc, char** argv ) {

	if ( argc < 3 )
 80012d8:	2802      	cmp	r0, #2
#endif


// Function: Flash erase
// Syntax: flashdel <address> <block/sector>
uint32_t CommandFunction_flashdel	( uint32_t argc, char** argv ) {
 80012da:	b538      	push	{r3, r4, r5, lr}

	if ( argc < 3 )
 80012dc:	d914      	bls.n	8001308 <CommandFunction_flashdel+0x30>
	{
		uprintf("Too few arguments!\r\n");
		return RETURN_FALSE;
	}
	if ( argc > 3 )
 80012de:	2803      	cmp	r0, #3
 80012e0:	d10d      	bne.n	80012fe <CommandFunction_flashdel+0x26>
		uprintf("Too many arguments!\r\n");
		return RETURN_FALSE;
	}
	
	// Convert arg2 hex
	if ( !StringHexToNum(argv[1],&Arg2Num,0))
 80012e2:	4d0e      	ldr	r5, [pc, #56]	; (800131c <CommandFunction_flashdel+0x44>)
 80012e4:	6848      	ldr	r0, [r1, #4]
 80012e6:	2200      	movs	r2, #0
 80012e8:	4629      	mov	r1, r5
 80012ea:	f7ff fac5 	bl	8000878 <StringHexToNum>
 80012ee:	4604      	mov	r4, r0
 80012f0:	b178      	cbz	r0, 8001312 <CommandFunction_flashdel+0x3a>
	{
		return RETURN_FALSE;
	}
	#endif		
			
	uprintf("address erased: 0x%h\r\n",
 80012f2:	6829      	ldr	r1, [r5, #0]
 80012f4:	480a      	ldr	r0, [pc, #40]	; (8001320 <CommandFunction_flashdel+0x48>)
 80012f6:	f7ff f8ef 	bl	80004d8 <uprintf>
 80012fa:	2001      	movs	r0, #1
			Arg2Num
			);
	
	return RETURN_SUCCESS;
}
 80012fc:	bd38      	pop	{r3, r4, r5, pc}
		uprintf("Too few arguments!\r\n");
		return RETURN_FALSE;
	}
	if ( argc > 3 )
	{
		uprintf("Too many arguments!\r\n");
 80012fe:	4809      	ldr	r0, [pc, #36]	; (8001324 <CommandFunction_flashdel+0x4c>)
 8001300:	f7ff f8ea 	bl	80004d8 <uprintf>
		return RETURN_FALSE;
 8001304:	2000      	movs	r0, #0
 8001306:	bd38      	pop	{r3, r4, r5, pc}
// Syntax: flashdel <address> <block/sector>
uint32_t CommandFunction_flashdel	( uint32_t argc, char** argv ) {

	if ( argc < 3 )
	{
		uprintf("Too few arguments!\r\n");
 8001308:	4807      	ldr	r0, [pc, #28]	; (8001328 <CommandFunction_flashdel+0x50>)
 800130a:	f7ff f8e5 	bl	80004d8 <uprintf>
		return RETURN_FALSE;
 800130e:	2000      	movs	r0, #0
 8001310:	bd38      	pop	{r3, r4, r5, pc}
	}
	
	// Convert arg2 hex
	if ( !StringHexToNum(argv[1],&Arg2Num,0))
	{
		USART_SendString("Wrong Argument!\r\n");
 8001312:	4806      	ldr	r0, [pc, #24]	; (800132c <CommandFunction_flashdel+0x54>)
 8001314:	f7ff f872 	bl	80003fc <USART_SendMessage>
		return RETURN_FALSE;
 8001318:	4620      	mov	r0, r4
 800131a:	bd38      	pop	{r3, r4, r5, pc}
 800131c:	20000938 	.word	0x20000938
 8001320:	080027c4 	.word	0x080027c4
 8001324:	080026fc 	.word	0x080026fc
 8001328:	08002798 	.word	0x08002798
 800132c:	080027b0 	.word	0x080027b0

08001330 <CommandFunction_flashread>:
// Function: FLASH read
// Syntax: flashread <address>
uint32_t CommandFunction_flashread	( uint32_t argc, char** argv ) {
	
	
	if ( argc < 2 )
 8001330:	2801      	cmp	r0, #1



// Function: FLASH read
// Syntax: flashread <address>
uint32_t CommandFunction_flashread	( uint32_t argc, char** argv ) {
 8001332:	b510      	push	{r4, lr}
	
	
	if ( argc < 2 )
 8001334:	d914      	bls.n	8001360 <CommandFunction_flashread+0x30>
	{
		uprintf("Too few arguments!\r\n");
		return RETURN_FALSE;
	}
	if ( argc > 2 )
 8001336:	2802      	cmp	r0, #2
 8001338:	d10d      	bne.n	8001356 <CommandFunction_flashread+0x26>
		return RETURN_FALSE;
	}
	
	
	// Convert arg2 hex
	if ( !StringHexToNum(argv[1],&Arg2Num,0))
 800133a:	6848      	ldr	r0, [r1, #4]
 800133c:	490b      	ldr	r1, [pc, #44]	; (800136c <CommandFunction_flashread+0x3c>)
 800133e:	2200      	movs	r2, #0
 8001340:	f7ff fa9a 	bl	8000878 <StringHexToNum>
 8001344:	4604      	mov	r4, r0
 8001346:	b108      	cbz	r0, 800134c <CommandFunction_flashread+0x1c>
			Arg2Num,
			Buffer[0]
			);
	#endif
	
	return RETURN_SUCCESS;
 8001348:	2001      	movs	r0, #1
}
 800134a:	bd10      	pop	{r4, pc}
	
	
	// Convert arg2 hex
	if ( !StringHexToNum(argv[1],&Arg2Num,0))
	{
		USART_SendString("Wrong Argument!\r\n");
 800134c:	4808      	ldr	r0, [pc, #32]	; (8001370 <CommandFunction_flashread+0x40>)
 800134e:	f7ff f855 	bl	80003fc <USART_SendMessage>
		return RETURN_FALSE;
 8001352:	4620      	mov	r0, r4
 8001354:	bd10      	pop	{r4, pc}
		uprintf("Too few arguments!\r\n");
		return RETURN_FALSE;
	}
	if ( argc > 2 )
	{
		uprintf("Too many arguments!\r\n");
 8001356:	4807      	ldr	r0, [pc, #28]	; (8001374 <CommandFunction_flashread+0x44>)
 8001358:	f7ff f8be 	bl	80004d8 <uprintf>
		return RETURN_FALSE;
 800135c:	2000      	movs	r0, #0
 800135e:	bd10      	pop	{r4, pc}
uint32_t CommandFunction_flashread	( uint32_t argc, char** argv ) {
	
	
	if ( argc < 2 )
	{
		uprintf("Too few arguments!\r\n");
 8001360:	4805      	ldr	r0, [pc, #20]	; (8001378 <CommandFunction_flashread+0x48>)
 8001362:	f7ff f8b9 	bl	80004d8 <uprintf>
		return RETURN_FALSE;
 8001366:	2000      	movs	r0, #0
 8001368:	bd10      	pop	{r4, pc}
 800136a:	bf00      	nop
 800136c:	20000938 	.word	0x20000938
 8001370:	080027b0 	.word	0x080027b0
 8001374:	080026fc 	.word	0x080026fc
 8001378:	08002798 	.word	0x08002798

0800137c <CommandFunction_help>:
uint32_t CommandFunction_help ( uint32_t argc, char** argv ) {

	uint8_t i;
	uint8_t found = 0;

	if ( argc > 2 )
 800137c:	2802      	cmp	r0, #2


// Function: help (list commands)
// 'help' or 'help <command>'
// Listing commands or write the command's describe
uint32_t CommandFunction_help ( uint32_t argc, char** argv ) {
 800137e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

	uint8_t i;
	uint8_t found = 0;

	if ( argc > 2 )
 8001380:	d820      	bhi.n	80013c4 <CommandFunction_help+0x48>
	{
		uprintf("Too many arguments!\r\n");
		return RETURN_FALSE;
	}

	if ( argc == 1) {																		// if Arg2 is empty, listing all commands
 8001382:	2801      	cmp	r0, #1
 8001384:	d028      	beq.n	80013d8 <CommandFunction_help+0x5c>
		uprintf("Using help:\r\n"
				"help <command>\r\n\r\n"
				"Commands list:\r\n");
		for (i=0; i < MONITOR_MAX_COMMAND_NUM; i++) uprintf("%s\r\n",CommandList[i].name);	// listing
	}
	else if (argc == 2) {																	// Arg2 not empty, find the command
 8001386:	2802      	cmp	r0, #2
 8001388:	d001      	beq.n	800138e <CommandFunction_help+0x12>
			if (found) return 2;
		}
		if (!found) uprintf("There isn't this command.\r\n");
	}
	else {
		return RETURN_FALSE;
 800138a:	2000      	movs	r0, #0
 800138c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800138e:	4f1b      	ldr	r7, [pc, #108]	; (80013fc <CommandFunction_help+0x80>)
		uprintf("Using help:\r\n"
				"help <command>\r\n\r\n"
				"Commands list:\r\n");
		for (i=0; i < MONITOR_MAX_COMMAND_NUM; i++) uprintf("%s\r\n",CommandList[i].name);	// listing
	}
	else if (argc == 2) {																	// Arg2 not empty, find the command
 8001390:	481b      	ldr	r0, [pc, #108]	; (8001400 <CommandFunction_help+0x84>)
 8001392:	460e      	mov	r6, r1
 8001394:	463d      	mov	r5, r7
 8001396:	2400      	movs	r4, #0
 8001398:	e004      	b.n	80013a4 <CommandFunction_help+0x28>
 800139a:	3401      	adds	r4, #1
		for (i=0; i < MONITOR_MAX_COMMAND_NUM; i++) {										// Find the command
 800139c:	2c0a      	cmp	r4, #10
 800139e:	d016      	beq.n	80013ce <CommandFunction_help+0x52>
 80013a0:	f855 0f0c 	ldr.w	r0, [r5, #12]!
			if (!StrCmp(CommandList[i].name,argv[1])) { uprintf("%s\r\n",CommandList[i].description); found = 1; }		// Command's describe
 80013a4:	6871      	ldr	r1, [r6, #4]
 80013a6:	f7ff facf 	bl	8000948 <StrCmp>
 80013aa:	2800      	cmp	r0, #0
 80013ac:	d1f5      	bne.n	800139a <CommandFunction_help+0x1e>
 80013ae:	b2e4      	uxtb	r4, r4
 80013b0:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 80013b4:	eb07 0484 	add.w	r4, r7, r4, lsl #2
 80013b8:	4812      	ldr	r0, [pc, #72]	; (8001404 <CommandFunction_help+0x88>)
 80013ba:	68a1      	ldr	r1, [r4, #8]
 80013bc:	f7ff f88c 	bl	80004d8 <uprintf>
			if (found) return 2;
 80013c0:	2002      	movs	r0, #2
 80013c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint8_t i;
	uint8_t found = 0;

	if ( argc > 2 )
	{
		uprintf("Too many arguments!\r\n");
 80013c4:	4810      	ldr	r0, [pc, #64]	; (8001408 <CommandFunction_help+0x8c>)
 80013c6:	f7ff f887 	bl	80004d8 <uprintf>
		return RETURN_FALSE;
 80013ca:	2000      	movs	r0, #0
 80013cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	else if (argc == 2) {																	// Arg2 not empty, find the command
		for (i=0; i < MONITOR_MAX_COMMAND_NUM; i++) {										// Find the command
			if (!StrCmp(CommandList[i].name,argv[1])) { uprintf("%s\r\n",CommandList[i].description); found = 1; }		// Command's describe
			if (found) return 2;
		}
		if (!found) uprintf("There isn't this command.\r\n");
 80013ce:	480f      	ldr	r0, [pc, #60]	; (800140c <CommandFunction_help+0x90>)
 80013d0:	f7ff f882 	bl	80004d8 <uprintf>
	}
	else {
		return RETURN_FALSE;
	}

	return RETURN_SUCCESS;
 80013d4:	2001      	movs	r0, #1
 80013d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80013d8:	4c08      	ldr	r4, [pc, #32]	; (80013fc <CommandFunction_help+0x80>)
		uprintf("Too many arguments!\r\n");
		return RETURN_FALSE;
	}

	if ( argc == 1) {																		// if Arg2 is empty, listing all commands
		uprintf("Using help:\r\n"
 80013da:	480d      	ldr	r0, [pc, #52]	; (8001410 <CommandFunction_help+0x94>)
 80013dc:	f7ff f87c 	bl	80004d8 <uprintf>
 80013e0:	f104 056c 	add.w	r5, r4, #108	; 0x6c
 80013e4:	4906      	ldr	r1, [pc, #24]	; (8001400 <CommandFunction_help+0x84>)
 80013e6:	e001      	b.n	80013ec <CommandFunction_help+0x70>
 80013e8:	f854 1f0c 	ldr.w	r1, [r4, #12]!
				"help <command>\r\n\r\n"
				"Commands list:\r\n");
		for (i=0; i < MONITOR_MAX_COMMAND_NUM; i++) uprintf("%s\r\n",CommandList[i].name);	// listing
 80013ec:	4805      	ldr	r0, [pc, #20]	; (8001404 <CommandFunction_help+0x88>)
 80013ee:	f7ff f873 	bl	80004d8 <uprintf>
 80013f2:	42a5      	cmp	r5, r4
 80013f4:	d1f8      	bne.n	80013e8 <CommandFunction_help+0x6c>
 80013f6:	2001      	movs	r0, #1
 80013f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80013fa:	bf00      	nop
 80013fc:	08002a64 	.word	0x08002a64
 8001400:	080027dc 	.word	0x080027dc
 8001404:	08002814 	.word	0x08002814
 8001408:	080026fc 	.word	0x080026fc
 800140c:	0800281c 	.word	0x0800281c
 8001410:	080027e4 	.word	0x080027e4

08001414 <CommandFunction_led>:
// or led toggle <num>
// or led status <dummy>
uint32_t CommandFunction_led ( uint32_t argc, char** argv )	// TODO: !!IMPORTANT!! atirni
{

	if ( argc < 3 )
 8001414:	2802      	cmp	r0, #2
// led on <num>
// or led off <num>
// or led toggle <num>
// or led status <dummy>
uint32_t CommandFunction_led ( uint32_t argc, char** argv )	// TODO: !!IMPORTANT!! atirni
{
 8001416:	b510      	push	{r4, lr}

	if ( argc < 3 )
 8001418:	d90e      	bls.n	8001438 <CommandFunction_led+0x24>
	{
		uprintf("Too few arguments!\r\n");
		return RETURN_FALSE;
	}
	if ( argc > 3 )
 800141a:	2803      	cmp	r0, #3
 800141c:	d107      	bne.n	800142e <CommandFunction_led+0x1a>
		uprintf("Too many arguments!\r\n");
		return RETURN_FALSE;
	}

	// Convert arg2, decimal
	if (!UnsignedDecimalStringToNum(argv[2],&Arg3Num))
 800141e:	6888      	ldr	r0, [r1, #8]
 8001420:	490a      	ldr	r1, [pc, #40]	; (800144c <CommandFunction_led+0x38>)
 8001422:	f7ff fa5d 	bl	80008e0 <UnsignedDecimalStringToNum>
 8001426:	4604      	mov	r4, r0
 8001428:	b158      	cbz	r0, 8001442 <CommandFunction_led+0x2e>
		return RETURN_FALSE;
	}

#endif
	
	return RETURN_SUCCESS;
 800142a:	2001      	movs	r0, #1

}
 800142c:	bd10      	pop	{r4, pc}
		uprintf("Too few arguments!\r\n");
		return RETURN_FALSE;
	}
	if ( argc > 3 )
	{
		uprintf("Too many arguments!\r\n");
 800142e:	4808      	ldr	r0, [pc, #32]	; (8001450 <CommandFunction_led+0x3c>)
 8001430:	f7ff f852 	bl	80004d8 <uprintf>
		return RETURN_FALSE;
 8001434:	2000      	movs	r0, #0
 8001436:	bd10      	pop	{r4, pc}
uint32_t CommandFunction_led ( uint32_t argc, char** argv )	// TODO: !!IMPORTANT!! atirni
{

	if ( argc < 3 )
	{
		uprintf("Too few arguments!\r\n");
 8001438:	4806      	ldr	r0, [pc, #24]	; (8001454 <CommandFunction_led+0x40>)
 800143a:	f7ff f84d 	bl	80004d8 <uprintf>
		return RETURN_FALSE;
 800143e:	2000      	movs	r0, #0
 8001440:	bd10      	pop	{r4, pc}
	}

	// Convert arg2, decimal
	if (!UnsignedDecimalStringToNum(argv[2],&Arg3Num))
	{
		USART_SendString("Wrong 1. argument!\r\n");
 8001442:	4805      	ldr	r0, [pc, #20]	; (8001458 <CommandFunction_led+0x44>)
 8001444:	f7fe ffda 	bl	80003fc <USART_SendMessage>
		return RETURN_FALSE;
 8001448:	4620      	mov	r0, r4
 800144a:	bd10      	pop	{r4, pc}
 800144c:	2000093c 	.word	0x2000093c
 8001450:	080026fc 	.word	0x080026fc
 8001454:	08002798 	.word	0x08002798
 8001458:	08002838 	.word	0x08002838

0800145c <CommandFunction_flashwrite>:

// Function: FLASH write
// Syntax: flashwrite <address> <data>
uint32_t CommandFunction_flashwrite	( uint32_t argc, char** argv ) {

	if ( argc < 3 )
 800145c:	2802      	cmp	r0, #2



// Function: FLASH write
// Syntax: flashwrite <address> <data>
uint32_t CommandFunction_flashwrite	( uint32_t argc, char** argv ) {
 800145e:	b570      	push	{r4, r5, r6, lr}

	if ( argc < 3 )
 8001460:	d920      	bls.n	80014a4 <CommandFunction_flashwrite+0x48>
	{
		uprintf("Too few arguments!\r\n");
		return RETURN_FALSE;
	}
	if ( argc > 3 )
 8001462:	2803      	cmp	r0, #3
 8001464:	d114      	bne.n	8001490 <CommandFunction_flashwrite+0x34>
		uprintf("Too many arguments!\r\n");
		return RETURN_FALSE;
	}
	
	// Convert arg2 hex
	if ( !StringHexToNum(argv[1],&Arg2Num,0))
 8001466:	4d12      	ldr	r5, [pc, #72]	; (80014b0 <CommandFunction_flashwrite+0x54>)
 8001468:	6848      	ldr	r0, [r1, #4]
 800146a:	460c      	mov	r4, r1
 800146c:	2200      	movs	r2, #0
 800146e:	4629      	mov	r1, r5
 8001470:	f7ff fa02 	bl	8000878 <StringHexToNum>
 8001474:	b188      	cbz	r0, 800149a <CommandFunction_flashwrite+0x3e>
		USART_SendString("Wrong 1. argument!\r\n");
		return RETURN_FALSE;
	}
	
	// Convert arg3, decimal
	if (!UnsignedDecimalStringToNum(argv[2],&Arg3Num))
 8001476:	4e0f      	ldr	r6, [pc, #60]	; (80014b4 <CommandFunction_flashwrite+0x58>)
 8001478:	68a0      	ldr	r0, [r4, #8]
 800147a:	4631      	mov	r1, r6
 800147c:	f7ff fa30 	bl	80008e0 <UnsignedDecimalStringToNum>
 8001480:	b158      	cbz	r0, 800149a <CommandFunction_flashwrite+0x3e>
	Buffer[0] = (uint8_t)Arg3Num;
		
	FLASH_Write(Arg2Num,Buffer,1,5000);
	#endif
	
	uprintf("address: 0x%w\r\n"
 8001482:	6832      	ldr	r2, [r6, #0]
 8001484:	6829      	ldr	r1, [r5, #0]
 8001486:	480c      	ldr	r0, [pc, #48]	; (80014b8 <CommandFunction_flashwrite+0x5c>)
 8001488:	f7ff f826 	bl	80004d8 <uprintf>
 800148c:	2001      	movs	r0, #1
			Arg2Num,
			Arg3Num);

	
	return RETURN_SUCCESS;
}
 800148e:	bd70      	pop	{r4, r5, r6, pc}
		uprintf("Too few arguments!\r\n");
		return RETURN_FALSE;
	}
	if ( argc > 3 )
	{
		uprintf("Too many arguments!\r\n");
 8001490:	480a      	ldr	r0, [pc, #40]	; (80014bc <CommandFunction_flashwrite+0x60>)
 8001492:	f7ff f821 	bl	80004d8 <uprintf>
		return RETURN_FALSE;
 8001496:	2000      	movs	r0, #0
 8001498:	bd70      	pop	{r4, r5, r6, pc}
	}
	
	// Convert arg2 hex
	if ( !StringHexToNum(argv[1],&Arg2Num,0))
	{
		USART_SendString("Wrong 1. argument!\r\n");
 800149a:	4809      	ldr	r0, [pc, #36]	; (80014c0 <CommandFunction_flashwrite+0x64>)
 800149c:	f7fe ffae 	bl	80003fc <USART_SendMessage>
		return RETURN_FALSE;
 80014a0:	2000      	movs	r0, #0
 80014a2:	bd70      	pop	{r4, r5, r6, pc}
// Syntax: flashwrite <address> <data>
uint32_t CommandFunction_flashwrite	( uint32_t argc, char** argv ) {

	if ( argc < 3 )
	{
		uprintf("Too few arguments!\r\n");
 80014a4:	4807      	ldr	r0, [pc, #28]	; (80014c4 <CommandFunction_flashwrite+0x68>)
 80014a6:	f7ff f817 	bl	80004d8 <uprintf>
		return RETURN_FALSE;
 80014aa:	2000      	movs	r0, #0
 80014ac:	bd70      	pop	{r4, r5, r6, pc}
 80014ae:	bf00      	nop
 80014b0:	20000938 	.word	0x20000938
 80014b4:	2000093c 	.word	0x2000093c
 80014b8:	08002850 	.word	0x08002850
 80014bc:	080026fc 	.word	0x080026fc
 80014c0:	08002838 	.word	0x08002838
 80014c4:	08002798 	.word	0x08002798

080014c8 <CommandFunction_temp>:
 80014c8:	2001      	movs	r0, #1
 80014ca:	4770      	bx	lr

080014cc <COMMAND_GetCommandNum>:

uint8_t COMMAND_GetCommandNum( void )
{
	return MONITOR_MAX_COMMAND_NUM;

}
 80014cc:	200a      	movs	r0, #10
 80014ce:	4770      	bx	lr

080014d0 <prvResetNextTaskUnblockTime.part.2>:
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 80014d0:	4a03      	ldr	r2, [pc, #12]	; (80014e0 <prvResetNextTaskUnblockTime.part.2+0x10>)
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 80014d2:	4b04      	ldr	r3, [pc, #16]	; (80014e4 <prvResetNextTaskUnblockTime.part.2+0x14>)
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 80014d4:	6812      	ldr	r2, [r2, #0]
 80014d6:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 80014d8:	68d2      	ldr	r2, [r2, #12]
 80014da:	6852      	ldr	r2, [r2, #4]
 80014dc:	601a      	str	r2, [r3, #0]
 80014de:	4770      	bx	lr
 80014e0:	20000528 	.word	0x20000528
 80014e4:	200005c8 	.word	0x200005c8

080014e8 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 80014e8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80014ec:	4b46      	ldr	r3, [pc, #280]	; (8001608 <xTaskIncrementTick+0x120>)
 80014ee:	681b      	ldr	r3, [r3, #0]
 80014f0:	2b00      	cmp	r3, #0
 80014f2:	d153      	bne.n	800159c <xTaskIncrementTick+0xb4>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
 80014f4:	4b45      	ldr	r3, [pc, #276]	; (800160c <xTaskIncrementTick+0x124>)
 80014f6:	681a      	ldr	r2, [r3, #0]
 80014f8:	3201      	adds	r2, #1
 80014fa:	601a      	str	r2, [r3, #0]

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 80014fc:	681f      	ldr	r7, [r3, #0]

			if( xConstTickCount == ( TickType_t ) 0U )
 80014fe:	2f00      	cmp	r7, #0
 8001500:	d059      	beq.n	80015b6 <xTaskIncrementTick+0xce>
 8001502:	f8df b128 	ldr.w	fp, [pc, #296]	; 800162c <xTaskIncrementTick+0x144>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 8001506:	f8db 2000 	ldr.w	r2, [fp]
 800150a:	4e41      	ldr	r6, [pc, #260]	; (8001610 <xTaskIncrementTick+0x128>)
 800150c:	4d41      	ldr	r5, [pc, #260]	; (8001614 <xTaskIncrementTick+0x12c>)
 800150e:	4297      	cmp	r7, r2
 8001510:	d35e      	bcc.n	80015d0 <xTaskIncrementTick+0xe8>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 8001512:	f8df 911c 	ldr.w	r9, [pc, #284]	; 8001630 <xTaskIncrementTick+0x148>
 8001516:	2400      	movs	r4, #0
 8001518:	e02d      	b.n	8001576 <xTaskIncrementTick+0x8e>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800151a:	4b3f      	ldr	r3, [pc, #252]	; (8001618 <xTaskIncrementTick+0x130>)
 800151c:	681a      	ldr	r2, [r3, #0]
 800151e:	68d2      	ldr	r2, [r2, #12]
 8001520:	f8d2 800c 	ldr.w	r8, [r2, #12]
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 8001524:	f8d8 1004 	ldr.w	r1, [r8, #4]
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8001528:	f108 0a04 	add.w	sl, r8, #4
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );

						if( xConstTickCount < xItemValue )
 800152c:	428f      	cmp	r7, r1
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 800152e:	4650      	mov	r0, sl
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );

						if( xConstTickCount < xItemValue )
 8001530:	d35f      	bcc.n	80015f2 <xTaskIncrementTick+0x10a>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8001532:	f000 f92f 	bl	8001794 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8001536:	f8d8 1028 	ldr.w	r1, [r8, #40]	; 0x28
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800153a:	f108 0018 	add.w	r0, r8, #24
						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800153e:	b109      	cbz	r1, 8001544 <xTaskIncrementTick+0x5c>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8001540:	f000 f928 	bl	8001794 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 8001544:	f8d8 002c 	ldr.w	r0, [r8, #44]	; 0x2c
 8001548:	f8d9 3000 	ldr.w	r3, [r9]
 800154c:	2201      	movs	r2, #1
 800154e:	fa02 fc00 	lsl.w	ip, r2, r0
 8001552:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001556:	4651      	mov	r1, sl
 8001558:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 800155c:	ea4c 0303 	orr.w	r3, ip, r3
 8001560:	f8c9 3000 	str.w	r3, [r9]
 8001564:	f000 f906 	bl	8001774 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8001568:	6828      	ldr	r0, [r5, #0]
 800156a:	f8d8 102c 	ldr.w	r1, [r8, #44]	; 0x2c
 800156e:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
							{
								xSwitchRequired = pdTRUE;
 8001570:	4291      	cmp	r1, r2
 8001572:	bf28      	it	cs
 8001574:	2401      	movcs	r4, #1
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8001576:	4b28      	ldr	r3, [pc, #160]	; (8001618 <xTaskIncrementTick+0x130>)
 8001578:	681a      	ldr	r2, [r3, #0]
 800157a:	6812      	ldr	r2, [r2, #0]
 800157c:	2a00      	cmp	r2, #0
 800157e:	d1cc      	bne.n	800151a <xTaskIncrementTick+0x32>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
 8001580:	f04f 32ff 	mov.w	r2, #4294967295
 8001584:	f8cb 2000 	str.w	r2, [fp]
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8001588:	682b      	ldr	r3, [r5, #0]
 800158a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800158c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8001590:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
			{
				xSwitchRequired = pdTRUE;
 8001594:	2b02      	cmp	r3, #2
 8001596:	bf28      	it	cs
 8001598:	2401      	movcs	r4, #1
 800159a:	e004      	b.n	80015a6 <xTaskIncrementTick+0xbe>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 800159c:	4a1f      	ldr	r2, [pc, #124]	; (800161c <xTaskIncrementTick+0x134>)
 800159e:	6813      	ldr	r3, [r2, #0]
 80015a0:	3301      	adds	r3, #1
 80015a2:	6013      	str	r3, [r2, #0]

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 80015a4:	2400      	movs	r4, #0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 80015a6:	4b1e      	ldr	r3, [pc, #120]	; (8001620 <xTaskIncrementTick+0x138>)
 80015a8:	681b      	ldr	r3, [r3, #0]
		{
			xSwitchRequired = pdTRUE;
 80015aa:	2b00      	cmp	r3, #0
 80015ac:	bf18      	it	ne
 80015ae:	2401      	movne	r4, #1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 80015b0:	4620      	mov	r0, r4
 80015b2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			block. */
			const TickType_t xConstTickCount = xTickCount;

			if( xConstTickCount == ( TickType_t ) 0U )
			{
				taskSWITCH_DELAYED_LISTS();
 80015b6:	4b18      	ldr	r3, [pc, #96]	; (8001618 <xTaskIncrementTick+0x130>)
 80015b8:	681a      	ldr	r2, [r3, #0]
 80015ba:	6812      	ldr	r2, [r2, #0]
 80015bc:	b152      	cbz	r2, 80015d4 <xTaskIncrementTick+0xec>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 80015be:	f04f 0350 	mov.w	r3, #80	; 0x50
 80015c2:	f383 8811 	msr	BASEPRI, r3
 80015c6:	f3bf 8f6f 	isb	sy
 80015ca:	f3bf 8f4f 	dsb	sy
 80015ce:	e7fe      	b.n	80015ce <xTaskIncrementTick+0xe6>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 80015d0:	2400      	movs	r4, #0
 80015d2:	e7d9      	b.n	8001588 <xTaskIncrementTick+0xa0>
			block. */
			const TickType_t xConstTickCount = xTickCount;

			if( xConstTickCount == ( TickType_t ) 0U )
			{
				taskSWITCH_DELAYED_LISTS();
 80015d4:	4a13      	ldr	r2, [pc, #76]	; (8001624 <xTaskIncrementTick+0x13c>)
 80015d6:	6818      	ldr	r0, [r3, #0]
 80015d8:	4913      	ldr	r1, [pc, #76]	; (8001628 <xTaskIncrementTick+0x140>)
 80015da:	6814      	ldr	r4, [r2, #0]
 80015dc:	601c      	str	r4, [r3, #0]
 80015de:	6010      	str	r0, [r2, #0]
 80015e0:	680a      	ldr	r2, [r1, #0]
 80015e2:	3201      	adds	r2, #1
 80015e4:	600a      	str	r2, [r1, #0]

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80015e6:	681b      	ldr	r3, [r3, #0]
 80015e8:	681b      	ldr	r3, [r3, #0]
 80015ea:	b12b      	cbz	r3, 80015f8 <xTaskIncrementTick+0x110>
 80015ec:	f7ff ff70 	bl	80014d0 <prvResetNextTaskUnblockTime.part.2>
 80015f0:	e787      	b.n	8001502 <xTaskIncrementTick+0x1a>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
 80015f2:	f8cb 1000 	str.w	r1, [fp]
							break;
 80015f6:	e7c7      	b.n	8001588 <xTaskIncrementTick+0xa0>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 80015f8:	f8df b030 	ldr.w	fp, [pc, #48]	; 800162c <xTaskIncrementTick+0x144>
 80015fc:	f04f 32ff 	mov.w	r2, #4294967295
 8001600:	f8cb 2000 	str.w	r2, [fp]
 8001604:	e77f      	b.n	8001506 <xTaskIncrementTick+0x1e>
 8001606:	bf00      	nop
 8001608:	200005c0 	.word	0x200005c0
 800160c:	200005d0 	.word	0x200005d0
 8001610:	20000534 	.word	0x20000534
 8001614:	200005c4 	.word	0x200005c4
 8001618:	20000528 	.word	0x20000528
 800161c:	20000530 	.word	0x20000530
 8001620:	200005dc 	.word	0x200005dc
 8001624:	200005d4 	.word	0x200005d4
 8001628:	200005cc 	.word	0x200005cc
 800162c:	200005c8 	.word	0x200005c8
 8001630:	200005d8 	.word	0x200005d8

08001634 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8001634:	4b16      	ldr	r3, [pc, #88]	; (8001690 <vTaskSwitchContext+0x5c>)
 8001636:	681b      	ldr	r3, [r3, #0]
 8001638:	bb33      	cbnz	r3, 8001688 <vTaskSwitchContext+0x54>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
 800163a:	4916      	ldr	r1, [pc, #88]	; (8001694 <vTaskSwitchContext+0x60>)
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800163c:	4a16      	ldr	r2, [pc, #88]	; (8001698 <vTaskSwitchContext+0x64>)
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
 800163e:	600b      	str	r3, [r1, #0]
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8001640:	6813      	ldr	r3, [r2, #0]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
	{
	uint8_t ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 8001642:	fab3 f383 	clz	r3, r3
 8001646:	b2db      	uxtb	r3, r3
 8001648:	f1c3 031f 	rsb	r3, r3, #31
 800164c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8001650:	009b      	lsls	r3, r3, #2
 8001652:	4812      	ldr	r0, [pc, #72]	; (800169c <vTaskSwitchContext+0x68>)
 8001654:	58c2      	ldr	r2, [r0, r3]
 8001656:	18c1      	adds	r1, r0, r3
 8001658:	b942      	cbnz	r2, 800166c <vTaskSwitchContext+0x38>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 800165a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800165e:	f383 8811 	msr	BASEPRI, r3
 8001662:	f3bf 8f6f 	isb	sy
 8001666:	f3bf 8f4f 	dsb	sy
 800166a:	e7fe      	b.n	800166a <vTaskSwitchContext+0x36>
 800166c:	684a      	ldr	r2, [r1, #4]
 800166e:	3308      	adds	r3, #8
 8001670:	6852      	ldr	r2, [r2, #4]
 8001672:	604a      	str	r2, [r1, #4]
 8001674:	4403      	add	r3, r0
 8001676:	429a      	cmp	r2, r3
 8001678:	bf08      	it	eq
 800167a:	6852      	ldreq	r2, [r2, #4]
 800167c:	4b08      	ldr	r3, [pc, #32]	; (80016a0 <vTaskSwitchContext+0x6c>)
 800167e:	bf08      	it	eq
 8001680:	604a      	streq	r2, [r1, #4]
 8001682:	68d2      	ldr	r2, [r2, #12]
 8001684:	601a      	str	r2, [r3, #0]
 8001686:	4770      	bx	lr
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 8001688:	4b02      	ldr	r3, [pc, #8]	; (8001694 <vTaskSwitchContext+0x60>)
 800168a:	2201      	movs	r2, #1
 800168c:	601a      	str	r2, [r3, #0]
 800168e:	4770      	bx	lr
 8001690:	200005c0 	.word	0x200005c0
 8001694:	200005dc 	.word	0x200005dc
 8001698:	200005d8 	.word	0x200005d8
 800169c:	20000534 	.word	0x20000534
 80016a0:	200005c4 	.word	0x200005c4

080016a4 <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
 80016a4:	4b05      	ldr	r3, [pc, #20]	; (80016bc <xTaskGetSchedulerState+0x18>)
 80016a6:	681b      	ldr	r3, [r3, #0]
 80016a8:	b133      	cbz	r3, 80016b8 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80016aa:	4b05      	ldr	r3, [pc, #20]	; (80016c0 <xTaskGetSchedulerState+0x1c>)
 80016ac:	681b      	ldr	r3, [r3, #0]
 80016ae:	2b00      	cmp	r3, #0
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
 80016b0:	bf0c      	ite	eq
 80016b2:	2002      	moveq	r0, #2
 80016b4:	2000      	movne	r0, #0
 80016b6:	4770      	bx	lr
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
 80016b8:	2001      	movs	r0, #1
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
 80016ba:	4770      	bx	lr
 80016bc:	2000052c 	.word	0x2000052c
 80016c0:	200005c0 	.word	0x200005c0

080016c4 <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 80016c4:	4b06      	ldr	r3, [pc, #24]	; (80016e0 <pxCurrentTCBConst2>)
 80016c6:	6819      	ldr	r1, [r3, #0]
 80016c8:	6808      	ldr	r0, [r1, #0]
 80016ca:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80016ce:	f380 8809 	msr	PSP, r0
 80016d2:	f3bf 8f6f 	isb	sy
 80016d6:	f04f 0000 	mov.w	r0, #0
 80016da:	f380 8811 	msr	BASEPRI, r0
 80016de:	4770      	bx	lr

080016e0 <pxCurrentTCBConst2>:
 80016e0:	200005c4 	.word	0x200005c4

080016e4 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 80016e4:	f3ef 8009 	mrs	r0, PSP
 80016e8:	f3bf 8f6f 	isb	sy
 80016ec:	4b14      	ldr	r3, [pc, #80]	; (8001740 <pxCurrentTCBConst>)
 80016ee:	681a      	ldr	r2, [r3, #0]
 80016f0:	f01e 0f10 	tst.w	lr, #16
 80016f4:	bf08      	it	eq
 80016f6:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 80016fa:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80016fe:	6010      	str	r0, [r2, #0]
 8001700:	f84d 3d04 	str.w	r3, [sp, #-4]!
 8001704:	f04f 0050 	mov.w	r0, #80	; 0x50
 8001708:	f380 8811 	msr	BASEPRI, r0
 800170c:	f3bf 8f4f 	dsb	sy
 8001710:	f3bf 8f6f 	isb	sy
 8001714:	f7ff ff8e 	bl	8001634 <vTaskSwitchContext>
 8001718:	f04f 0000 	mov.w	r0, #0
 800171c:	f380 8811 	msr	BASEPRI, r0
 8001720:	bc08      	pop	{r3}
 8001722:	6819      	ldr	r1, [r3, #0]
 8001724:	6808      	ldr	r0, [r1, #0]
 8001726:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800172a:	f01e 0f10 	tst.w	lr, #16
 800172e:	bf08      	it	eq
 8001730:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8001734:	f380 8809 	msr	PSP, r0
 8001738:	f3bf 8f6f 	isb	sy
 800173c:	4770      	bx	lr
 800173e:	bf00      	nop

08001740 <pxCurrentTCBConst>:
 8001740:	200005c4 	.word	0x200005c4

08001744 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8001744:	b508      	push	{r3, lr}

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
 8001746:	f3ef 8311 	mrs	r3, BASEPRI
 800174a:	f04f 0250 	mov.w	r2, #80	; 0x50
 800174e:	f382 8811 	msr	BASEPRI, r2
 8001752:	f3bf 8f6f 	isb	sy
 8001756:	f3bf 8f4f 	dsb	sy
	save and then restore the interrupt mask value as its value is already
	known. */
	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 800175a:	f7ff fec5 	bl	80014e8 <xTaskIncrementTick>
 800175e:	b118      	cbz	r0, 8001768 <xPortSysTickHandler+0x24>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8001760:	4b03      	ldr	r3, [pc, #12]	; (8001770 <xPortSysTickHandler+0x2c>)
 8001762:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001766:	601a      	str	r2, [r3, #0]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8001768:	2300      	movs	r3, #0
 800176a:	f383 8811 	msr	BASEPRI, r3
 800176e:	bd08      	pop	{r3, pc}
 8001770:	e000ed04 	.word	0xe000ed04

08001774 <vListInsertEnd>:
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8001774:	e890 000c 	ldmia.w	r0, {r2, r3}
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8001778:	b410      	push	{r4}

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800177a:	689c      	ldr	r4, [r3, #8]
 800177c:	608c      	str	r4, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 800177e:	689c      	ldr	r4, [r3, #8]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 8001780:	604b      	str	r3, [r1, #4]
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8001782:	3201      	adds	r2, #1
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8001784:	6061      	str	r1, [r4, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8001786:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
}
 8001788:	f85d 4b04 	ldr.w	r4, [sp], #4

	pxIndex->pxPrevious->pxNext = pxNewListItem;
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 800178c:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 800178e:	6002      	str	r2, [r0, #0]
}
 8001790:	4770      	bx	lr
 8001792:	bf00      	nop

08001794 <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8001794:	6843      	ldr	r3, [r0, #4]
 8001796:	6881      	ldr	r1, [r0, #8]

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8001798:	6902      	ldr	r2, [r0, #16]
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 800179a:	b410      	push	{r4}
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800179c:	6099      	str	r1, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 800179e:	6881      	ldr	r1, [r0, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 80017a0:	6854      	ldr	r4, [r2, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 80017a2:	604b      	str	r3, [r1, #4]
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
	( pxList->uxNumberOfItems )--;
 80017a4:	6813      	ldr	r3, [r2, #0]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 80017a6:	42a0      	cmp	r0, r4
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 80017a8:	bf08      	it	eq
 80017aa:	6051      	streq	r1, [r2, #4]
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
	( pxList->uxNumberOfItems )--;
 80017ac:	3b01      	subs	r3, #1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 80017ae:	2100      	movs	r1, #0
 80017b0:	6101      	str	r1, [r0, #16]
	( pxList->uxNumberOfItems )--;

	return pxList->uxNumberOfItems;
}
 80017b2:	f85d 4b04 	ldr.w	r4, [sp], #4
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
	( pxList->uxNumberOfItems )--;
 80017b6:	6013      	str	r3, [r2, #0]

	return pxList->uxNumberOfItems;
}
 80017b8:	4618      	mov	r0, r3
 80017ba:	4770      	bx	lr

080017bc <osSystickHandler>:
* @brief  Handles the tick increment
* @param  none.
* @retval none.
*/
void osSystickHandler(void)
{
 80017bc:	b508      	push	{r3, lr}

#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
 80017be:	f7ff ff71 	bl	80016a4 <xTaskGetSchedulerState>
 80017c2:	2801      	cmp	r0, #1
 80017c4:	d003      	beq.n	80017ce <osSystickHandler+0x12>
#endif  /* INCLUDE_xTaskGetSchedulerState */  
    xPortSysTickHandler();
#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  }
#endif  /* INCLUDE_xTaskGetSchedulerState */  
}
 80017c6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
  {
#endif  /* INCLUDE_xTaskGetSchedulerState */  
    xPortSysTickHandler();
 80017ca:	f7ff bfbb 	b.w	8001744 <xPortSysTickHandler>
 80017ce:	bd08      	pop	{r3, pc}

080017d0 <UART_SetConfig>:
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 80017d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
  assert_param(IS_UART_PARITY(huart->Init.Parity));
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = huart->Instance->CR2;
 80017d4:	6806      	ldr	r6, [r0, #0]
 80017d6:	6937      	ldr	r7, [r6, #16]
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 80017d8:	4605      	mov	r5, r0

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);

  /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
  tmpreg |= (uint32_t)huart->Init.StopBits;
 80017da:	68c0      	ldr	r0, [r0, #12]
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80017dc:	69ec      	ldr	r4, [r5, #28]
 80017de:	f8d5 e008 	ldr.w	lr, [r5, #8]
 80017e2:	692a      	ldr	r2, [r5, #16]
 80017e4:	6969      	ldr	r1, [r5, #20]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = huart->Instance->CR2;

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 80017e6:	f427 5740 	bic.w	r7, r7, #12288	; 0x3000

  /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
  tmpreg |= (uint32_t)huart->Init.StopBits;
 80017ea:	4338      	orrs	r0, r7
  
  /* Write to USART CR2 */
  WRITE_REG(huart->Instance->CR2, (uint32_t)tmpreg);
 80017ec:	6130      	str	r0, [r6, #16]

  /*-------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = huart->Instance->CR1;
 80017ee:	68f3      	ldr	r3, [r6, #12]
  
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
  
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  tmpreg |= huart->Init.HwFlowCtl;
 80017f0:	69a8      	ldr	r0, [r5, #24]
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80017f2:	ea4e 0202 	orr.w	r2, lr, r2

  /*-------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = huart->Instance->CR1;

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 80017f6:	f423 4316 	bic.w	r3, r3, #38400	; 0x9600
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80017fa:	430a      	orrs	r2, r1

  /*-------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = huart->Instance->CR1;

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 80017fc:	f023 030c 	bic.w	r3, r3, #12
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8001800:	4322      	orrs	r2, r4
 8001802:	4313      	orrs	r3, r2
  
  /* Write to USART CR1 */
  WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
 8001804:	60f3      	str	r3, [r6, #12]
  
  /*-------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = huart->Instance->CR3;
 8001806:	6973      	ldr	r3, [r6, #20]
  
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
 8001808:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  tmpreg |= huart->Init.HwFlowCtl;
 800180c:	4303      	orrs	r3, r0
  
  /* Write to USART CR3 */
  WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800180e:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
  
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  tmpreg |= huart->Init.HwFlowCtl;
  
  /* Write to USART CR3 */
  WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
 8001812:	6173      	str	r3, [r6, #20]
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 8001814:	4ba3      	ldr	r3, [pc, #652]	; (8001aa4 <UART_SetConfig+0x2d4>)
  
  /* Write to USART CR3 */
  WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8001816:	d05d      	beq.n	80018d4 <UART_SetConfig+0x104>
    }
  }
  else
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 8001818:	429e      	cmp	r6, r3
 800181a:	f000 80f6 	beq.w	8001a0a <UART_SetConfig+0x23a>
 800181e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001822:	429e      	cmp	r6, r3
 8001824:	f000 80f1 	beq.w	8001a0a <UART_SetConfig+0x23a>
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
    }
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8001828:	f000 fc56 	bl	80020d8 <HAL_RCC_GetPCLK1Freq>
 800182c:	686f      	ldr	r7, [r5, #4]
 800182e:	f8df 8278 	ldr.w	r8, [pc, #632]	; 8001aa8 <UART_SetConfig+0x2d8>
 8001832:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001836:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800183a:	00bf      	lsls	r7, r7, #2
 800183c:	fbb0 f7f7 	udiv	r7, r0, r7
 8001840:	f000 fc4a 	bl	80020d8 <HAL_RCC_GetPCLK1Freq>
 8001844:	686c      	ldr	r4, [r5, #4]
 8001846:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800184a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800184e:	00a4      	lsls	r4, r4, #2
 8001850:	fbb0 f4f4 	udiv	r4, r0, r4
 8001854:	f000 fc40 	bl	80020d8 <HAL_RCC_GetPCLK1Freq>
 8001858:	fba8 3707 	umull	r3, r7, r8, r7
 800185c:	686b      	ldr	r3, [r5, #4]
 800185e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001862:	009b      	lsls	r3, r3, #2
 8001864:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001868:	fbb0 f0f3 	udiv	r0, r0, r3
 800186c:	fba8 3000 	umull	r3, r0, r8, r0
 8001870:	0940      	lsrs	r0, r0, #5
 8001872:	f04f 0a64 	mov.w	sl, #100	; 0x64
 8001876:	fb0a 4410 	mls	r4, sl, r0, r4
 800187a:	f000 fc2d 	bl	80020d8 <HAL_RCC_GetPCLK1Freq>
 800187e:	6869      	ldr	r1, [r5, #4]
 8001880:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001884:	008a      	lsls	r2, r1, #2
 8001886:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800188a:	fbb0 f9f2 	udiv	r9, r0, r2
 800188e:	f000 fc23 	bl	80020d8 <HAL_RCC_GetPCLK1Freq>
 8001892:	0124      	lsls	r4, r4, #4
 8001894:	686a      	ldr	r2, [r5, #4]
 8001896:	3432      	adds	r4, #50	; 0x32
 8001898:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800189c:	0092      	lsls	r2, r2, #2
 800189e:	fba8 3404 	umull	r3, r4, r8, r4
 80018a2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80018a6:	fbb0 f0f2 	udiv	r0, r0, r2
 80018aa:	fba8 3000 	umull	r3, r0, r8, r0
 80018ae:	097f      	lsrs	r7, r7, #5
 80018b0:	0964      	lsrs	r4, r4, #5
 80018b2:	0940      	lsrs	r0, r0, #5
 80018b4:	013f      	lsls	r7, r7, #4
 80018b6:	f004 04f0 	and.w	r4, r4, #240	; 0xf0
 80018ba:	fb0a 9210 	mls	r2, sl, r0, r9
 80018be:	0112      	lsls	r2, r2, #4
 80018c0:	3232      	adds	r2, #50	; 0x32
 80018c2:	fba8 2302 	umull	r2, r3, r8, r2
 80018c6:	f3c3 1343 	ubfx	r3, r3, #5, #4
 80018ca:	441c      	add	r4, r3
 80018cc:	4427      	add	r7, r4
 80018ce:	60b7      	str	r7, [r6, #8]
 80018d0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 80018d4:	429e      	cmp	r6, r3
 80018d6:	d059      	beq.n	800198c <UART_SetConfig+0x1bc>
 80018d8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80018dc:	429e      	cmp	r6, r3
 80018de:	d055      	beq.n	800198c <UART_SetConfig+0x1bc>
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
    }
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 80018e0:	f000 fbfa 	bl	80020d8 <HAL_RCC_GetPCLK1Freq>
 80018e4:	686f      	ldr	r7, [r5, #4]
 80018e6:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 8001aa8 <UART_SetConfig+0x2d8>
 80018ea:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80018ee:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80018f2:	007f      	lsls	r7, r7, #1
 80018f4:	fbb0 f7f7 	udiv	r7, r0, r7
 80018f8:	f000 fbee 	bl	80020d8 <HAL_RCC_GetPCLK1Freq>
 80018fc:	686c      	ldr	r4, [r5, #4]
 80018fe:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001902:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001906:	0064      	lsls	r4, r4, #1
 8001908:	fbb0 f4f4 	udiv	r4, r0, r4
 800190c:	f000 fbe4 	bl	80020d8 <HAL_RCC_GetPCLK1Freq>
 8001910:	686a      	ldr	r2, [r5, #4]
 8001912:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001916:	fba8 3707 	umull	r3, r7, r8, r7
 800191a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800191e:	0053      	lsls	r3, r2, #1
 8001920:	fbb0 f3f3 	udiv	r3, r0, r3
 8001924:	fba8 2303 	umull	r2, r3, r8, r3
 8001928:	095b      	lsrs	r3, r3, #5
 800192a:	f04f 0a64 	mov.w	sl, #100	; 0x64
 800192e:	fb0a 4413 	mls	r4, sl, r3, r4
 8001932:	00e4      	lsls	r4, r4, #3
 8001934:	f000 fbd0 	bl	80020d8 <HAL_RCC_GetPCLK1Freq>
 8001938:	3432      	adds	r4, #50	; 0x32
 800193a:	fba8 3404 	umull	r3, r4, r8, r4
 800193e:	686b      	ldr	r3, [r5, #4]
 8001940:	097f      	lsrs	r7, r7, #5
 8001942:	0924      	lsrs	r4, r4, #4
 8001944:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001948:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800194c:	005a      	lsls	r2, r3, #1
 800194e:	013f      	lsls	r7, r7, #4
 8001950:	f404 74f8 	and.w	r4, r4, #496	; 0x1f0
 8001954:	fbb0 f9f2 	udiv	r9, r0, r2
 8001958:	f000 fbbe 	bl	80020d8 <HAL_RCC_GetPCLK1Freq>
 800195c:	6869      	ldr	r1, [r5, #4]
 800195e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001962:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001966:	0049      	lsls	r1, r1, #1
 8001968:	fbb0 f1f1 	udiv	r1, r0, r1
 800196c:	fba8 3101 	umull	r3, r1, r8, r1
 8001970:	0949      	lsrs	r1, r1, #5
 8001972:	fb0a 9211 	mls	r2, sl, r1, r9
 8001976:	00d2      	lsls	r2, r2, #3
 8001978:	3232      	adds	r2, #50	; 0x32
 800197a:	fba8 2302 	umull	r2, r3, r8, r2
 800197e:	f3c3 1342 	ubfx	r3, r3, #5, #3
 8001982:	443b      	add	r3, r7
 8001984:	441c      	add	r4, r3
 8001986:	60b4      	str	r4, [r6, #8]
 8001988:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
    if((huart->Instance == USART1) || (huart->Instance == USART6))
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 800198c:	f000 fbbc 	bl	8002108 <HAL_RCC_GetPCLK2Freq>
 8001990:	686f      	ldr	r7, [r5, #4]
 8001992:	f8df 8114 	ldr.w	r8, [pc, #276]	; 8001aa8 <UART_SetConfig+0x2d8>
 8001996:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800199a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800199e:	007f      	lsls	r7, r7, #1
 80019a0:	fbb0 f7f7 	udiv	r7, r0, r7
 80019a4:	f000 fbb0 	bl	8002108 <HAL_RCC_GetPCLK2Freq>
 80019a8:	686c      	ldr	r4, [r5, #4]
 80019aa:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80019ae:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80019b2:	0064      	lsls	r4, r4, #1
 80019b4:	fbb0 f4f4 	udiv	r4, r0, r4
 80019b8:	f000 fba6 	bl	8002108 <HAL_RCC_GetPCLK2Freq>
 80019bc:	686a      	ldr	r2, [r5, #4]
 80019be:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80019c2:	fba8 3707 	umull	r3, r7, r8, r7
 80019c6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80019ca:	0053      	lsls	r3, r2, #1
 80019cc:	fbb0 f3f3 	udiv	r3, r0, r3
 80019d0:	fba8 2303 	umull	r2, r3, r8, r3
 80019d4:	095b      	lsrs	r3, r3, #5
 80019d6:	f04f 0a64 	mov.w	sl, #100	; 0x64
 80019da:	fb0a 4413 	mls	r4, sl, r3, r4
 80019de:	00e4      	lsls	r4, r4, #3
 80019e0:	f000 fb92 	bl	8002108 <HAL_RCC_GetPCLK2Freq>
 80019e4:	3432      	adds	r4, #50	; 0x32
 80019e6:	fba8 3404 	umull	r3, r4, r8, r4
 80019ea:	686b      	ldr	r3, [r5, #4]
 80019ec:	097f      	lsrs	r7, r7, #5
 80019ee:	0924      	lsrs	r4, r4, #4
 80019f0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80019f4:	005a      	lsls	r2, r3, #1
 80019f6:	013f      	lsls	r7, r7, #4
 80019f8:	f404 74f8 	and.w	r4, r4, #496	; 0x1f0
 80019fc:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001a00:	fbb0 f9f2 	udiv	r9, r0, r2
 8001a04:	f000 fb80 	bl	8002108 <HAL_RCC_GetPCLK2Freq>
 8001a08:	e7a8      	b.n	800195c <UART_SetConfig+0x18c>
  else
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
    if((huart->Instance == USART1) || (huart->Instance == USART6))
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8001a0a:	f000 fb7d 	bl	8002108 <HAL_RCC_GetPCLK2Freq>
 8001a0e:	686f      	ldr	r7, [r5, #4]
 8001a10:	f8df 8094 	ldr.w	r8, [pc, #148]	; 8001aa8 <UART_SetConfig+0x2d8>
 8001a14:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001a18:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001a1c:	00bf      	lsls	r7, r7, #2
 8001a1e:	fbb0 f7f7 	udiv	r7, r0, r7
 8001a22:	f000 fb71 	bl	8002108 <HAL_RCC_GetPCLK2Freq>
 8001a26:	686c      	ldr	r4, [r5, #4]
 8001a28:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001a2c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001a30:	00a4      	lsls	r4, r4, #2
 8001a32:	fbb0 f4f4 	udiv	r4, r0, r4
 8001a36:	f000 fb67 	bl	8002108 <HAL_RCC_GetPCLK2Freq>
 8001a3a:	686a      	ldr	r2, [r5, #4]
 8001a3c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001a40:	fba8 3707 	umull	r3, r7, r8, r7
 8001a44:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001a48:	0093      	lsls	r3, r2, #2
 8001a4a:	fbb0 f3f3 	udiv	r3, r0, r3
 8001a4e:	fba8 2303 	umull	r2, r3, r8, r3
 8001a52:	095b      	lsrs	r3, r3, #5
 8001a54:	f04f 0a64 	mov.w	sl, #100	; 0x64
 8001a58:	fb0a 4413 	mls	r4, sl, r3, r4
 8001a5c:	0124      	lsls	r4, r4, #4
 8001a5e:	f000 fb53 	bl	8002108 <HAL_RCC_GetPCLK2Freq>
 8001a62:	3432      	adds	r4, #50	; 0x32
 8001a64:	fba8 3404 	umull	r3, r4, r8, r4
 8001a68:	686b      	ldr	r3, [r5, #4]
 8001a6a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001a6e:	009a      	lsls	r2, r3, #2
 8001a70:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001a74:	fbb0 f9f2 	udiv	r9, r0, r2
 8001a78:	f000 fb46 	bl	8002108 <HAL_RCC_GetPCLK2Freq>
 8001a7c:	6869      	ldr	r1, [r5, #4]
 8001a7e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001a82:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8001a86:	0089      	lsls	r1, r1, #2
 8001a88:	fbb0 f1f1 	udiv	r1, r0, r1
 8001a8c:	fba8 3101 	umull	r3, r1, r8, r1
 8001a90:	097f      	lsrs	r7, r7, #5
 8001a92:	0964      	lsrs	r4, r4, #5
 8001a94:	0949      	lsrs	r1, r1, #5
 8001a96:	013f      	lsls	r7, r7, #4
 8001a98:	f004 04f0 	and.w	r4, r4, #240	; 0xf0
 8001a9c:	fb0a 9211 	mls	r2, sl, r1, r9
 8001aa0:	e70d      	b.n	80018be <UART_SetConfig+0xee>
 8001aa2:	bf00      	nop
 8001aa4:	40011000 	.word	0x40011000
 8001aa8:	51eb851f 	.word	0x51eb851f

08001aac <HAL_UART_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
  /* Check the UART handle allocation */
  if(huart == NULL)
 8001aac:	b360      	cbz	r0, 8001b08 <HAL_UART_Init+0x5c>
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 8001aae:	b538      	push	{r3, r4, r5, lr}
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
  
  if(huart->gState == HAL_UART_STATE_RESET)
 8001ab0:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8001ab4:	4604      	mov	r4, r0
 8001ab6:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001aba:	b303      	cbz	r3, 8001afe <HAL_UART_Init+0x52>
  }

  huart->gState = HAL_UART_STATE_BUSY;

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 8001abc:	6822      	ldr	r2, [r4, #0]
    huart->Lock = HAL_UNLOCKED;
    /* Init the low level hardware */
    HAL_UART_MspInit(huart);
  }

  huart->gState = HAL_UART_STATE_BUSY;
 8001abe:	2324      	movs	r3, #36	; 0x24
 8001ac0:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 8001ac4:	68d3      	ldr	r3, [r2, #12]
 8001ac6:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8001aca:	60d3      	str	r3, [r2, #12]
  
  /* Set the UART Communication parameters */
  UART_SetConfig(huart);
 8001acc:	4620      	mov	r0, r4
 8001ace:	f7ff fe7f 	bl	80017d0 <UART_SetConfig>
  
  /* In asynchronous mode, the following bits must be kept cleared: 
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8001ad2:	6823      	ldr	r3, [r4, #0]
 8001ad4:	691a      	ldr	r2, [r3, #16]
 8001ad6:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8001ada:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8001adc:	695a      	ldr	r2, [r3, #20]
 8001ade:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8001ae2:	615a      	str	r2, [r3, #20]
  
  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
 8001ae4:	68da      	ldr	r2, [r3, #12]
  
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001ae6:	2500      	movs	r5, #0
  huart->gState= HAL_UART_STATE_READY;
 8001ae8:	2120      	movs	r1, #32
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
  
  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
 8001aea:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8001aee:	60da      	str	r2, [r3, #12]
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
  huart->gState= HAL_UART_STATE_READY;
  huart->RxState= HAL_UART_STATE_READY;
  
  return HAL_OK;
 8001af0:	4628      	mov	r0, r5
  
  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
  
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001af2:	63e5      	str	r5, [r4, #60]	; 0x3c
  huart->gState= HAL_UART_STATE_READY;
 8001af4:	f884 1039 	strb.w	r1, [r4, #57]	; 0x39
  huart->RxState= HAL_UART_STATE_READY;
 8001af8:	f884 103a 	strb.w	r1, [r4, #58]	; 0x3a
  
  return HAL_OK;
 8001afc:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
  
  if(huart->gState == HAL_UART_STATE_RESET)
  {  
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 8001afe:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    /* Init the low level hardware */
    HAL_UART_MspInit(huart);
 8001b02:	f7fe fbe7 	bl	80002d4 <HAL_UART_MspInit>
 8001b06:	e7d9      	b.n	8001abc <HAL_UART_Init+0x10>
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
  /* Check the UART handle allocation */
  if(huart == NULL)
  {
    return HAL_ERROR;
 8001b08:	2001      	movs	r0, #1
 8001b0a:	4770      	bx	lr

08001b0c <HAL_UART_Transmit_IT>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
  /* Check that a Tx process is not already ongoing */
  if(huart->gState == HAL_UART_STATE_READY)
 8001b0c:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8001b10:	2b20      	cmp	r3, #32
 8001b12:	d001      	beq.n	8001b18 <HAL_UART_Transmit_IT+0xc>
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;   
 8001b14:	2002      	movs	r0, #2
 8001b16:	4770      	bx	lr
HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
  /* Check that a Tx process is not already ongoing */
  if(huart->gState == HAL_UART_STATE_READY)
  {
    if((pData == NULL ) || (Size == 0U)) 
 8001b18:	b1b9      	cbz	r1, 8001b4a <HAL_UART_Transmit_IT+0x3e>
 8001b1a:	b1b2      	cbz	r2, 8001b4a <HAL_UART_Transmit_IT+0x3e>
    {
      return HAL_ERROR;
    }
    
    /* Process Locked */
    __HAL_LOCK(huart);
 8001b1c:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8001b20:	2b01      	cmp	r3, #1
 8001b22:	d0f7      	beq.n	8001b14 <HAL_UART_Transmit_IT+0x8>
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 8001b24:	b430      	push	{r4, r5}
    
    huart->pTxBuffPtr = pData;
    huart->TxXferSize = Size;
    huart->TxXferCount = Size;

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001b26:	2300      	movs	r3, #0

    /* Process Unlocked */
    __HAL_UNLOCK(huart);

    /* Enable the UART Transmit data register empty Interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 8001b28:	6805      	ldr	r5, [r0, #0]
    
    huart->pTxBuffPtr = pData;
    huart->TxXferSize = Size;
    huart->TxXferCount = Size;

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001b2a:	63c3      	str	r3, [r0, #60]	; 0x3c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8001b2c:	2421      	movs	r4, #33	; 0x21
 8001b2e:	f880 4039 	strb.w	r4, [r0, #57]	; 0x39

    /* Process Unlocked */
    __HAL_UNLOCK(huart);

    /* Enable the UART Transmit data register empty Interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 8001b32:	68ec      	ldr	r4, [r5, #12]
    }
    
    /* Process Locked */
    __HAL_LOCK(huart);
    
    huart->pTxBuffPtr = pData;
 8001b34:	6201      	str	r1, [r0, #32]

    /* Process Unlocked */
    __HAL_UNLOCK(huart);

    /* Enable the UART Transmit data register empty Interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 8001b36:	f044 0180 	orr.w	r1, r4, #128	; 0x80
    
    /* Process Locked */
    __HAL_LOCK(huart);
    
    huart->pTxBuffPtr = pData;
    huart->TxXferSize = Size;
 8001b3a:	8482      	strh	r2, [r0, #36]	; 0x24
    huart->TxXferCount = Size;
 8001b3c:	84c2      	strh	r2, [r0, #38]	; 0x26

    huart->ErrorCode = HAL_UART_ERROR_NONE;
    huart->gState = HAL_UART_STATE_BUSY_TX;

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 8001b3e:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38

    /* Enable the UART Transmit data register empty Interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
    
    return HAL_OK;
 8001b42:	4618      	mov	r0, r3

    /* Process Unlocked */
    __HAL_UNLOCK(huart);

    /* Enable the UART Transmit data register empty Interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 8001b44:	60e9      	str	r1, [r5, #12]
  }
  else
  {
    return HAL_BUSY;   
  }
}
 8001b46:	bc30      	pop	{r4, r5}
 8001b48:	4770      	bx	lr
  /* Check that a Tx process is not already ongoing */
  if(huart->gState == HAL_UART_STATE_READY)
  {
    if((pData == NULL ) || (Size == 0U)) 
    {
      return HAL_ERROR;
 8001b4a:	2001      	movs	r0, #1
 8001b4c:	4770      	bx	lr
 8001b4e:	bf00      	nop

08001b50 <HAL_UART_Receive_IT>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
  /* Check that a Rx process is not already ongoing */ 
  if(huart->RxState == HAL_UART_STATE_READY)
 8001b50:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
 8001b54:	2b20      	cmp	r3, #32
 8001b56:	d001      	beq.n	8001b5c <HAL_UART_Receive_IT+0xc>
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY; 
 8001b58:	2002      	movs	r0, #2
 8001b5a:	4770      	bx	lr
HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
  /* Check that a Rx process is not already ongoing */ 
  if(huart->RxState == HAL_UART_STATE_READY)
  {
    if((pData == NULL ) || (Size == 0U)) 
 8001b5c:	b1d9      	cbz	r1, 8001b96 <HAL_UART_Receive_IT+0x46>
 8001b5e:	b1d2      	cbz	r2, 8001b96 <HAL_UART_Receive_IT+0x46>
    {
      return HAL_ERROR;
    }
    
    /* Process Locked */
    __HAL_LOCK(huart);
 8001b60:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8001b64:	2b01      	cmp	r3, #1
 8001b66:	d0f7      	beq.n	8001b58 <HAL_UART_Receive_IT+0x8>
  * @param  pData: Pointer to data buffer
  * @param  Size: Amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 8001b68:	b430      	push	{r4, r5}
    
    huart->pRxBuffPtr = pData;
    huart->RxXferSize = Size;
    huart->RxXferCount = Size;
    
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001b6a:	2300      	movs	r3, #0
    
    /* Process Unlocked */
    __HAL_UNLOCK(huart);

    /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8001b6c:	6804      	ldr	r4, [r0, #0]
    
    huart->pRxBuffPtr = pData;
    huart->RxXferSize = Size;
    huart->RxXferCount = Size;
    
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001b6e:	63c3      	str	r3, [r0, #60]	; 0x3c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8001b70:	2522      	movs	r5, #34	; 0x22
 8001b72:	f880 503a 	strb.w	r5, [r0, #58]	; 0x3a
    
    /* Process Unlocked */
    __HAL_UNLOCK(huart);

    /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8001b76:	6965      	ldr	r5, [r4, #20]
    }
    
    /* Process Locked */
    __HAL_LOCK(huart);
    
    huart->pRxBuffPtr = pData;
 8001b78:	6281      	str	r1, [r0, #40]	; 0x28
    
    /* Process Unlocked */
    __HAL_UNLOCK(huart);

    /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8001b7a:	f045 0101 	orr.w	r1, r5, #1
    
    /* Process Locked */
    __HAL_LOCK(huart);
    
    huart->pRxBuffPtr = pData;
    huart->RxXferSize = Size;
 8001b7e:	8582      	strh	r2, [r0, #44]	; 0x2c
    huart->RxXferCount = Size;
 8001b80:	85c2      	strh	r2, [r0, #46]	; 0x2e
    
    huart->ErrorCode = HAL_UART_ERROR_NONE;
    huart->RxState = HAL_UART_STATE_BUSY_RX;
    
    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 8001b82:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38

    /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8001b86:	6161      	str	r1, [r4, #20]

    /* Enable the UART Parity Error and Data Register not empty Interrupts */
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 8001b88:	68e2      	ldr	r2, [r4, #12]
 8001b8a:	f442 7290 	orr.w	r2, r2, #288	; 0x120
    
    return HAL_OK;
 8001b8e:	4618      	mov	r0, r3

    /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);

    /* Enable the UART Parity Error and Data Register not empty Interrupts */
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 8001b90:	60e2      	str	r2, [r4, #12]
  }
  else
  {
    return HAL_BUSY; 
  }
}
 8001b92:	bc30      	pop	{r4, r5}
 8001b94:	4770      	bx	lr
  /* Check that a Rx process is not already ongoing */ 
  if(huart->RxState == HAL_UART_STATE_READY)
  {
    if((pData == NULL ) || (Size == 0U)) 
    {
      return HAL_ERROR;
 8001b96:	2001      	movs	r0, #1
 8001b98:	4770      	bx	lr
 8001b9a:	bf00      	nop

08001b9c <UART_Receive_IT.part.1>:
  uint16_t* tmp;
  
  /* Check that a Rx process is ongoing */
  if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 8001b9c:	6883      	ldr	r3, [r0, #8]
 8001b9e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8001ba2:	d028      	beq.n	8001bf6 <UART_Receive_IT.part.1+0x5a>
        huart->pRxBuffPtr += 1U;
      }
    }
    else
    {
      if(huart->Init.Parity == UART_PARITY_NONE)
 8001ba4:	6903      	ldr	r3, [r0, #16]
 8001ba6:	b173      	cbz	r3, 8001bc6 <UART_Receive_IT.part.1+0x2a>
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FFU);
      }
      else
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007FU);
 8001ba8:	6803      	ldr	r3, [r0, #0]
 8001baa:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8001bac:	685b      	ldr	r3, [r3, #4]
 8001bae:	1c51      	adds	r1, r2, #1
 8001bb0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8001bb4:	6281      	str	r1, [r0, #40]	; 0x28
 8001bb6:	7013      	strb	r3, [r2, #0]
      }
    }

    if(--huart->RxXferCount == 0U)
 8001bb8:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
 8001bba:	3b01      	subs	r3, #1
 8001bbc:	b29b      	uxth	r3, r3
 8001bbe:	85c3      	strh	r3, [r0, #46]	; 0x2e
 8001bc0:	b143      	cbz	r3, 8001bd4 <UART_Receive_IT.part.1+0x38>
  }
  else
  {
    return HAL_BUSY;
  }
}
 8001bc2:	2000      	movs	r0, #0
 8001bc4:	4770      	bx	lr
    }
    else
    {
      if(huart->Init.Parity == UART_PARITY_NONE)
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FFU);
 8001bc6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001bc8:	6802      	ldr	r2, [r0, #0]
 8001bca:	1c59      	adds	r1, r3, #1
 8001bcc:	6852      	ldr	r2, [r2, #4]
 8001bce:	6281      	str	r1, [r0, #40]	; 0x28
 8001bd0:	701a      	strb	r2, [r3, #0]
 8001bd2:	e7f1      	b.n	8001bb8 <UART_Receive_IT.part.1+0x1c>
    }

    if(--huart->RxXferCount == 0U)
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8001bd4:	6802      	ldr	r2, [r0, #0]
 8001bd6:	68d1      	ldr	r1, [r2, #12]
 8001bd8:	f421 7190 	bic.w	r1, r1, #288	; 0x120
  * @brief  Receives an amount of data in non blocking mode 
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
 8001bdc:	b510      	push	{r4, lr}
    }

    if(--huart->RxXferCount == 0U)
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8001bde:	60d1      	str	r1, [r2, #12]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8001be0:	6951      	ldr	r1, [r2, #20]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8001be2:	2420      	movs	r4, #32
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8001be4:	f021 0101 	bic.w	r1, r1, #1
 8001be8:	6151      	str	r1, [r2, #20]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8001bea:	f880 403a 	strb.w	r4, [r0, #58]	; 0x3a
     
      HAL_UART_RxCpltCallback(huart);
 8001bee:	f7fe fbc1 	bl	8000374 <HAL_UART_RxCpltCallback>
  }
  else
  {
    return HAL_BUSY;
  }
}
 8001bf2:	2000      	movs	r0, #0
 8001bf4:	bd10      	pop	{r4, pc}
  if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
    {
      tmp = (uint16_t*) huart->pRxBuffPtr;
      if(huart->Init.Parity == UART_PARITY_NONE)
 8001bf6:	6902      	ldr	r2, [r0, #16]
  /* Check that a Rx process is ongoing */
  if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
    {
      tmp = (uint16_t*) huart->pRxBuffPtr;
 8001bf8:	6a83      	ldr	r3, [r0, #40]	; 0x28
      if(huart->Init.Parity == UART_PARITY_NONE)
 8001bfa:	b93a      	cbnz	r2, 8001c0c <UART_Receive_IT.part.1+0x70>
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FFU);
 8001bfc:	6802      	ldr	r2, [r0, #0]
 8001bfe:	6852      	ldr	r2, [r2, #4]
 8001c00:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8001c04:	f823 2b02 	strh.w	r2, [r3], #2
        huart->pRxBuffPtr += 2U;
 8001c08:	6283      	str	r3, [r0, #40]	; 0x28
 8001c0a:	e7d5      	b.n	8001bb8 <UART_Receive_IT.part.1+0x1c>
      }
      else
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FFU);
 8001c0c:	6802      	ldr	r2, [r0, #0]
 8001c0e:	6852      	ldr	r2, [r2, #4]
 8001c10:	b2d2      	uxtb	r2, r2
 8001c12:	f823 2b01 	strh.w	r2, [r3], #1
        huart->pRxBuffPtr += 1U;
 8001c16:	6283      	str	r3, [r0, #40]	; 0x28
 8001c18:	e7ce      	b.n	8001bb8 <UART_Receive_IT.part.1+0x1c>
 8001c1a:	bf00      	nop

08001c1c <HAL_UART_IRQHandler>:
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
   uint32_t isrflags   = READ_REG(huart->Instance->SR);
 8001c1c:	6803      	ldr	r3, [r0, #0]
 8001c1e:	681a      	ldr	r2, [r3, #0]
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 8001c20:	b570      	push	{r4, r5, r6, lr}
   uint32_t errorflags = 0x00U;
   uint32_t dmarequest = 0x00U;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
  if(errorflags == RESET)
 8001c22:	0716      	lsls	r6, r2, #28
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
   uint32_t isrflags   = READ_REG(huart->Instance->SR);
   uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8001c24:	68dd      	ldr	r5, [r3, #12]
   uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8001c26:	6959      	ldr	r1, [r3, #20]
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 8001c28:	4604      	mov	r4, r0
   uint32_t errorflags = 0x00U;
   uint32_t dmarequest = 0x00U;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
  if(errorflags == RESET)
 8001c2a:	d049      	beq.n	8001cc0 <HAL_UART_IRQHandler+0xa4>
      return;
    }
  }

  /* If some errors occur */
  if((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
 8001c2c:	f011 0101 	ands.w	r1, r1, #1
 8001c30:	d052      	beq.n	8001cd8 <HAL_UART_IRQHandler+0xbc>
  {
    /* UART parity error interrupt occurred ----------------------------------*/
    if(((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 8001c32:	07d6      	lsls	r6, r2, #31
 8001c34:	d505      	bpl.n	8001c42 <HAL_UART_IRQHandler+0x26>
 8001c36:	05e8      	lsls	r0, r5, #23
 8001c38:	d503      	bpl.n	8001c42 <HAL_UART_IRQHandler+0x26>
    {
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8001c3a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8001c3c:	f040 0001 	orr.w	r0, r0, #1
 8001c40:	63e0      	str	r0, [r4, #60]	; 0x3c
    }
    
    /* UART noise error interrupt occurred -----------------------------------*/
    if(((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8001c42:	0756      	lsls	r6, r2, #29
 8001c44:	d57a      	bpl.n	8001d3c <HAL_UART_IRQHandler+0x120>
 8001c46:	2900      	cmp	r1, #0
 8001c48:	f000 8084 	beq.w	8001d54 <HAL_UART_IRQHandler+0x138>
    {
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8001c4c:	6be1      	ldr	r1, [r4, #60]	; 0x3c
    }
    
    /* UART frame error interrupt occurred -----------------------------------*/
    if(((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8001c4e:	0790      	lsls	r0, r2, #30
    }
    
    /* UART noise error interrupt occurred -----------------------------------*/
    if(((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
    {
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8001c50:	f041 0102 	orr.w	r1, r1, #2
 8001c54:	63e1      	str	r1, [r4, #60]	; 0x3c
    }
    
    /* UART frame error interrupt occurred -----------------------------------*/
    if(((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8001c56:	d576      	bpl.n	8001d46 <HAL_UART_IRQHandler+0x12a>
    {
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 8001c58:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8001c5a:	f041 0104 	orr.w	r1, r1, #4
 8001c5e:	63e1      	str	r1, [r4, #60]	; 0x3c
    }
    
    /* UART Over-Run interrupt occurred --------------------------------------*/
    if(((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8001c60:	0711      	lsls	r1, r2, #28
 8001c62:	d472      	bmi.n	8001d4a <HAL_UART_IRQHandler+0x12e>
    { 
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
    }

    /* Call UART Error Call back function if need be --------------------------*/    
    if(huart->ErrorCode != HAL_UART_ERROR_NONE)
 8001c64:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8001c66:	2900      	cmp	r1, #0
 8001c68:	d029      	beq.n	8001cbe <HAL_UART_IRQHandler+0xa2>
    {
      /* UART in mode Receiver -----------------------------------------------*/
      if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8001c6a:	0691      	lsls	r1, r2, #26
 8001c6c:	d505      	bpl.n	8001c7a <HAL_UART_IRQHandler+0x5e>
 8001c6e:	06aa      	lsls	r2, r5, #26
 8001c70:	d503      	bpl.n	8001c7a <HAL_UART_IRQHandler+0x5e>
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{
  uint16_t* tmp;
  
  /* Check that a Rx process is ongoing */
  if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
 8001c72:	f894 203a 	ldrb.w	r2, [r4, #58]	; 0x3a
 8001c76:	2a22      	cmp	r2, #34	; 0x22
 8001c78:	d07c      	beq.n	8001d74 <HAL_UART_IRQHandler+0x158>
        UART_Receive_IT(huart);
      }

      /* If Overrun error occurs, or if any error occurs in DMA mode reception,
         consider error as blocking */
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8001c7a:	695a      	ldr	r2, [r3, #20]
      if(((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 8001c7c:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8001c7e:	070e      	lsls	r6, r1, #28
 8001c80:	d402      	bmi.n	8001c88 <HAL_UART_IRQHandler+0x6c>
 8001c82:	f012 0540 	ands.w	r5, r2, #64	; 0x40
 8001c86:	d07a      	beq.n	8001d7e <HAL_UART_IRQHandler+0x162>
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8001c88:	68da      	ldr	r2, [r3, #12]
 8001c8a:	f422 7290 	bic.w	r2, r2, #288	; 0x120
 8001c8e:	60da      	str	r2, [r3, #12]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8001c90:	695a      	ldr	r2, [r3, #20]

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8001c92:	2120      	movs	r1, #32
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8001c94:	f022 0201 	bic.w	r2, r2, #1
 8001c98:	615a      	str	r2, [r3, #20]

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8001c9a:	f884 103a 	strb.w	r1, [r4, #58]	; 0x3a
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
        
        /* Disable the UART DMA Rx request if enabled */
        if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8001c9e:	695a      	ldr	r2, [r3, #20]
 8001ca0:	0655      	lsls	r5, r2, #25
 8001ca2:	d55e      	bpl.n	8001d62 <HAL_UART_IRQHandler+0x146>
        {
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8001ca4:	695a      	ldr	r2, [r3, #20]
          
          /* Abort the UART DMA Rx channel */
          if(huart->hdmarx != NULL)
 8001ca6:	6b60      	ldr	r0, [r4, #52]	; 0x34
        UART_EndRxTransfer(huart);
        
        /* Disable the UART DMA Rx request if enabled */
        if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
        {
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8001ca8:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8001cac:	615a      	str	r2, [r3, #20]
          
          /* Abort the UART DMA Rx channel */
          if(huart->hdmarx != NULL)
 8001cae:	2800      	cmp	r0, #0
 8001cb0:	d057      	beq.n	8001d62 <HAL_UART_IRQHandler+0x146>
          {
            /* Set the UART DMA Abort callback : 
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8001cb2:	4b3b      	ldr	r3, [pc, #236]	; (8001da0 <HAL_UART_IRQHandler+0x184>)
 8001cb4:	6503      	str	r3, [r0, #80]	; 0x50
            if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8001cb6:	f000 fb3d 	bl	8002334 <HAL_DMA_Abort_IT>
 8001cba:	2800      	cmp	r0, #0
 8001cbc:	d155      	bne.n	8001d6a <HAL_UART_IRQHandler+0x14e>
 8001cbe:	bd70      	pop	{r4, r5, r6, pc}
  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
  if(errorflags == RESET)
  {
    /* UART in mode Receiver -------------------------------------------------*/
    if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8001cc0:	0696      	lsls	r6, r2, #26
 8001cc2:	d50c      	bpl.n	8001cde <HAL_UART_IRQHandler+0xc2>
 8001cc4:	06a9      	lsls	r1, r5, #26
 8001cc6:	d50a      	bpl.n	8001cde <HAL_UART_IRQHandler+0xc2>
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{
  uint16_t* tmp;
  
  /* Check that a Rx process is ongoing */
  if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
 8001cc8:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
 8001ccc:	2b22      	cmp	r3, #34	; 0x22
 8001cce:	d1f6      	bne.n	8001cbe <HAL_UART_IRQHandler+0xa2>
  if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
  {
    UART_EndTransmit_IT(huart);
    return;
  }
}
 8001cd0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8001cd4:	f7ff bf62 	b.w	8001b9c <UART_Receive_IT.part.1>
      return;
    }
  }

  /* If some errors occur */
  if((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
 8001cd8:	f415 7f90 	tst.w	r5, #288	; 0x120
 8001cdc:	d1a9      	bne.n	8001c32 <HAL_UART_IRQHandler+0x16>
    }
    return;
  } /* End if some error occurs */

  /* UART in mode Transmitter ------------------------------------------------*/
  if(((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 8001cde:	0610      	lsls	r0, r2, #24
 8001ce0:	d40e      	bmi.n	8001d00 <HAL_UART_IRQHandler+0xe4>
    UART_Transmit_IT(huart);
    return;
  }
  
  /* UART in mode Transmitter end --------------------------------------------*/
  if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
 8001ce2:	0656      	lsls	r6, r2, #25
 8001ce4:	d5eb      	bpl.n	8001cbe <HAL_UART_IRQHandler+0xa2>
 8001ce6:	066d      	lsls	r5, r5, #25
 8001ce8:	d5e9      	bpl.n	8001cbe <HAL_UART_IRQHandler+0xa2>
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */    
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8001cea:	68da      	ldr	r2, [r3, #12]
  
  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8001cec:	2120      	movs	r1, #32
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */    
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8001cee:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8001cf2:	60da      	str	r2, [r3, #12]
  
  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
    
  HAL_UART_TxCpltCallback(huart);
 8001cf4:	4620      	mov	r0, r4
{
  /* Disable the UART Transmit Complete Interrupt */    
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
  
  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8001cf6:	f884 1039 	strb.w	r1, [r4, #57]	; 0x39
    
  HAL_UART_TxCpltCallback(huart);
 8001cfa:	f7fe fb35 	bl	8000368 <HAL_UART_TxCpltCallback>
 8001cfe:	bd70      	pop	{r4, r5, r6, pc}
    }
    return;
  } /* End if some error occurs */

  /* UART in mode Transmitter ------------------------------------------------*/
  if(((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 8001d00:	0629      	lsls	r1, r5, #24
 8001d02:	d5ee      	bpl.n	8001ce2 <HAL_UART_IRQHandler+0xc6>
static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
{
  uint16_t* tmp;
  
  /* Check that a Tx process is ongoing */
  if(huart->gState == HAL_UART_STATE_BUSY_TX)
 8001d04:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
 8001d08:	2a21      	cmp	r2, #33	; 0x21
 8001d0a:	d1d8      	bne.n	8001cbe <HAL_UART_IRQHandler+0xa2>
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 8001d0c:	68a2      	ldr	r2, [r4, #8]
 8001d0e:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
    {
      tmp = (uint16_t*) huart->pTxBuffPtr;
 8001d12:	6a22      	ldr	r2, [r4, #32]
  uint16_t* tmp;
  
  /* Check that a Tx process is ongoing */
  if(huart->gState == HAL_UART_STATE_BUSY_TX)
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 8001d14:	d038      	beq.n	8001d88 <HAL_UART_IRQHandler+0x16c>
        huart->pTxBuffPtr += 1U;
      }
    } 
    else
    {
      huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FFU);
 8001d16:	1c51      	adds	r1, r2, #1
 8001d18:	6221      	str	r1, [r4, #32]
 8001d1a:	7812      	ldrb	r2, [r2, #0]
 8001d1c:	605a      	str	r2, [r3, #4]
    }

    if(--huart->TxXferCount == 0U)
 8001d1e:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
 8001d20:	3a01      	subs	r2, #1
 8001d22:	b292      	uxth	r2, r2
 8001d24:	84e2      	strh	r2, [r4, #38]	; 0x26
 8001d26:	2a00      	cmp	r2, #0
 8001d28:	d1c9      	bne.n	8001cbe <HAL_UART_IRQHandler+0xa2>
    {
      /* Disable the UART Transmit Complete Interrupt */
      CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 8001d2a:	68da      	ldr	r2, [r3, #12]
 8001d2c:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8001d30:	60da      	str	r2, [r3, #12]

      /* Enable the UART Transmit Complete Interrupt */    
      SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8001d32:	68da      	ldr	r2, [r3, #12]
 8001d34:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8001d38:	60da      	str	r2, [r3, #12]
 8001d3a:	bd70      	pop	{r4, r5, r6, pc}
    {
      huart->ErrorCode |= HAL_UART_ERROR_NE;
    }
    
    /* UART frame error interrupt occurred -----------------------------------*/
    if(((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8001d3c:	0796      	lsls	r6, r2, #30
 8001d3e:	d50b      	bpl.n	8001d58 <HAL_UART_IRQHandler+0x13c>
 8001d40:	2900      	cmp	r1, #0
 8001d42:	d189      	bne.n	8001c58 <HAL_UART_IRQHandler+0x3c>
 8001d44:	e78e      	b.n	8001c64 <HAL_UART_IRQHandler+0x48>
    {
      huart->ErrorCode |= HAL_UART_ERROR_FE;
    }
    
    /* UART Over-Run interrupt occurred --------------------------------------*/
    if(((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8001d46:	0711      	lsls	r1, r2, #28
 8001d48:	d58c      	bpl.n	8001c64 <HAL_UART_IRQHandler+0x48>
    { 
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8001d4a:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8001d4c:	f041 0108 	orr.w	r1, r1, #8
 8001d50:	63e1      	str	r1, [r4, #60]	; 0x3c
 8001d52:	e787      	b.n	8001c64 <HAL_UART_IRQHandler+0x48>
    {
      huart->ErrorCode |= HAL_UART_ERROR_NE;
    }
    
    /* UART frame error interrupt occurred -----------------------------------*/
    if(((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8001d54:	0790      	lsls	r0, r2, #30
 8001d56:	d485      	bmi.n	8001c64 <HAL_UART_IRQHandler+0x48>
    {
      huart->ErrorCode |= HAL_UART_ERROR_FE;
    }
    
    /* UART Over-Run interrupt occurred --------------------------------------*/
    if(((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8001d58:	0710      	lsls	r0, r2, #28
 8001d5a:	d583      	bpl.n	8001c64 <HAL_UART_IRQHandler+0x48>
 8001d5c:	2900      	cmp	r1, #0
 8001d5e:	d081      	beq.n	8001c64 <HAL_UART_IRQHandler+0x48>
 8001d60:	e7f3      	b.n	8001d4a <HAL_UART_IRQHandler+0x12e>
            }
          }
          else
          {
            /* Call user error callback */
            HAL_UART_ErrorCallback(huart);
 8001d62:	4620      	mov	r0, r4
 8001d64:	f7fe fb1e 	bl	80003a4 <HAL_UART_ErrorCallback>
 8001d68:	bd70      	pop	{r4, r5, r6, pc}
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
            if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
            {
              /* Call Directly XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8001d6a:	6b60      	ldr	r0, [r4, #52]	; 0x34
  if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
  {
    UART_EndTransmit_IT(huart);
    return;
  }
}
 8001d6c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
            if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
            {
              /* Call Directly XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8001d70:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8001d72:	4718      	bx	r3
 8001d74:	4620      	mov	r0, r4
 8001d76:	f7ff ff11 	bl	8001b9c <UART_Receive_IT.part.1>
 8001d7a:	6823      	ldr	r3, [r4, #0]
 8001d7c:	e77d      	b.n	8001c7a <HAL_UART_IRQHandler+0x5e>
      }
      else
      {
        /* Non Blocking error : transfer could go on. 
           Error is notified to user through user error callback */
        HAL_UART_ErrorCallback(huart);
 8001d7e:	4620      	mov	r0, r4
 8001d80:	f7fe fb10 	bl	80003a4 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001d84:	63e5      	str	r5, [r4, #60]	; 0x3c
 8001d86:	bd70      	pop	{r4, r5, r6, pc}
  if(huart->gState == HAL_UART_STATE_BUSY_TX)
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
    {
      tmp = (uint16_t*) huart->pTxBuffPtr;
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FFU);
 8001d88:	8811      	ldrh	r1, [r2, #0]
      if(huart->Init.Parity == UART_PARITY_NONE)
 8001d8a:	6920      	ldr	r0, [r4, #16]
  if(huart->gState == HAL_UART_STATE_BUSY_TX)
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
    {
      tmp = (uint16_t*) huart->pTxBuffPtr;
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FFU);
 8001d8c:	f3c1 0108 	ubfx	r1, r1, #0, #9
 8001d90:	6059      	str	r1, [r3, #4]
      if(huart->Init.Parity == UART_PARITY_NONE)
 8001d92:	b910      	cbnz	r0, 8001d9a <HAL_UART_IRQHandler+0x17e>
      {
        huart->pTxBuffPtr += 2U;
 8001d94:	3202      	adds	r2, #2
 8001d96:	6222      	str	r2, [r4, #32]
 8001d98:	e7c1      	b.n	8001d1e <HAL_UART_IRQHandler+0x102>
      }
      else
      {
        huart->pTxBuffPtr += 1U;
 8001d9a:	3201      	adds	r2, #1
 8001d9c:	6222      	str	r2, [r4, #32]
 8001d9e:	e7be      	b.n	8001d1e <HAL_UART_IRQHandler+0x102>
 8001da0:	08001da5 	.word	0x08001da5

08001da4 <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 8001da4:	b508      	push	{r3, lr}
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8001da6:	6b80      	ldr	r0, [r0, #56]	; 0x38
  huart->RxXferCount = 0;
 8001da8:	2300      	movs	r3, #0
 8001daa:	85c3      	strh	r3, [r0, #46]	; 0x2e
  huart->TxXferCount = 0;
 8001dac:	84c3      	strh	r3, [r0, #38]	; 0x26

  HAL_UART_ErrorCallback(huart);
 8001dae:	f7fe faf9 	bl	80003a4 <HAL_UART_ErrorCallback>
 8001db2:	bd08      	pop	{r3, pc}

08001db4 <HAL_RCC_OscConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8001db4:	b5f0      	push	{r4, r5, r6, r7, lr}
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001db6:	6803      	ldr	r3, [r0, #0]
 8001db8:	07dd      	lsls	r5, r3, #31
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8001dba:	b083      	sub	sp, #12
 8001dbc:	4604      	mov	r4, r0
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001dbe:	d522      	bpl.n	8001e06 <HAL_RCC_OscConfig+0x52>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8001dc0:	49ad      	ldr	r1, [pc, #692]	; (8002078 <HAL_RCC_OscConfig+0x2c4>)
 8001dc2:	688a      	ldr	r2, [r1, #8]
 8001dc4:	f002 020c 	and.w	r2, r2, #12
 8001dc8:	2a04      	cmp	r2, #4
 8001dca:	f000 80eb 	beq.w	8001fa4 <HAL_RCC_OscConfig+0x1f0>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8001dce:	688a      	ldr	r2, [r1, #8]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8001dd0:	f002 020c 	and.w	r2, r2, #12
 8001dd4:	2a08      	cmp	r2, #8
 8001dd6:	f000 80e1 	beq.w	8001f9c <HAL_RCC_OscConfig+0x1e8>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001dda:	4ba8      	ldr	r3, [pc, #672]	; (800207c <HAL_RCC_OscConfig+0x2c8>)
 8001ddc:	7922      	ldrb	r2, [r4, #4]
 8001dde:	701a      	strb	r2, [r3, #0]
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8001de0:	6863      	ldr	r3, [r4, #4]
 8001de2:	2b00      	cmp	r3, #0
 8001de4:	f000 80cc 	beq.w	8001f80 <HAL_RCC_OscConfig+0x1cc>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001de8:	f000 fb6a 	bl	80024c0 <HAL_GetTick>
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001dec:	4da2      	ldr	r5, [pc, #648]	; (8002078 <HAL_RCC_OscConfig+0x2c4>)
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001dee:	4606      	mov	r6, r0
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001df0:	e005      	b.n	8001dfe <HAL_RCC_OscConfig+0x4a>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001df2:	f000 fb65 	bl	80024c0 <HAL_GetTick>
 8001df6:	1b80      	subs	r0, r0, r6
 8001df8:	2864      	cmp	r0, #100	; 0x64
 8001dfa:	f200 80a0 	bhi.w	8001f3e <HAL_RCC_OscConfig+0x18a>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001dfe:	682b      	ldr	r3, [r5, #0]
 8001e00:	039a      	lsls	r2, r3, #14
 8001e02:	d5f6      	bpl.n	8001df2 <HAL_RCC_OscConfig+0x3e>
 8001e04:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8001e06:	079f      	lsls	r7, r3, #30
 8001e08:	d52e      	bpl.n	8001e68 <HAL_RCC_OscConfig+0xb4>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8001e0a:	4a9b      	ldr	r2, [pc, #620]	; (8002078 <HAL_RCC_OscConfig+0x2c4>)
 8001e0c:	6891      	ldr	r1, [r2, #8]
 8001e0e:	f011 0f0c 	tst.w	r1, #12
 8001e12:	f000 809b 	beq.w	8001f4c <HAL_RCC_OscConfig+0x198>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8001e16:	6891      	ldr	r1, [r2, #8]
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8001e18:	f001 010c 	and.w	r1, r1, #12
 8001e1c:	2908      	cmp	r1, #8
 8001e1e:	f000 8091 	beq.w	8001f44 <HAL_RCC_OscConfig+0x190>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8001e22:	68e3      	ldr	r3, [r4, #12]
 8001e24:	2b00      	cmp	r3, #0
 8001e26:	f000 80d9 	beq.w	8001fdc <HAL_RCC_OscConfig+0x228>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8001e2a:	4b95      	ldr	r3, [pc, #596]	; (8002080 <HAL_RCC_OscConfig+0x2cc>)

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001e2c:	4d92      	ldr	r5, [pc, #584]	; (8002078 <HAL_RCC_OscConfig+0x2c4>)
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8001e2e:	2201      	movs	r2, #1
 8001e30:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001e32:	f000 fb45 	bl	80024c0 <HAL_GetTick>
 8001e36:	4606      	mov	r6, r0

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001e38:	e004      	b.n	8001e44 <HAL_RCC_OscConfig+0x90>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8001e3a:	f000 fb41 	bl	80024c0 <HAL_GetTick>
 8001e3e:	1b80      	subs	r0, r0, r6
 8001e40:	2802      	cmp	r0, #2
 8001e42:	d87c      	bhi.n	8001f3e <HAL_RCC_OscConfig+0x18a>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001e44:	682b      	ldr	r3, [r5, #0]
 8001e46:	4a8c      	ldr	r2, [pc, #560]	; (8002078 <HAL_RCC_OscConfig+0x2c4>)
 8001e48:	0798      	lsls	r0, r3, #30
 8001e4a:	d5f6      	bpl.n	8001e3a <HAL_RCC_OscConfig+0x86>
            return HAL_TIMEOUT;
          }       
        } 
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001e4c:	6811      	ldr	r1, [r2, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001e4e:	23f8      	movs	r3, #248	; 0xf8
 8001e50:	fa93 f3a3 	rbit	r3, r3
 8001e54:	6920      	ldr	r0, [r4, #16]
 8001e56:	fab3 f383 	clz	r3, r3
 8001e5a:	f021 01f8 	bic.w	r1, r1, #248	; 0xf8
 8001e5e:	fa00 f303 	lsl.w	r3, r0, r3
 8001e62:	430b      	orrs	r3, r1
 8001e64:	6013      	str	r3, [r2, #0]
 8001e66:	6823      	ldr	r3, [r4, #0]
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001e68:	071a      	lsls	r2, r3, #28
 8001e6a:	d420      	bmi.n	8001eae <HAL_RCC_OscConfig+0xfa>
        }       
      } 
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8001e6c:	0759      	lsls	r1, r3, #29
 8001e6e:	d434      	bmi.n	8001eda <HAL_RCC_OscConfig+0x126>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8001e70:	69a2      	ldr	r2, [r4, #24]
 8001e72:	b1ca      	cbz	r2, 8001ea8 <HAL_RCC_OscConfig+0xf4>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8001e74:	4b80      	ldr	r3, [pc, #512]	; (8002078 <HAL_RCC_OscConfig+0x2c4>)
 8001e76:	6899      	ldr	r1, [r3, #8]
 8001e78:	f001 010c 	and.w	r1, r1, #12
 8001e7c:	2908      	cmp	r1, #8
 8001e7e:	d06c      	beq.n	8001f5a <HAL_RCC_OscConfig+0x1a6>
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001e80:	2a02      	cmp	r2, #2
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001e82:	4a80      	ldr	r2, [pc, #512]	; (8002084 <HAL_RCC_OscConfig+0x2d0>)
 8001e84:	f04f 0100 	mov.w	r1, #0
 8001e88:	6011      	str	r1, [r2, #0]
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001e8a:	f000 80b8 	beq.w	8001ffe <HAL_RCC_OscConfig+0x24a>
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001e8e:	461c      	mov	r4, r3
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001e90:	f000 fb16 	bl	80024c0 <HAL_GetTick>
 8001e94:	4605      	mov	r5, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001e96:	e004      	b.n	8001ea2 <HAL_RCC_OscConfig+0xee>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001e98:	f000 fb12 	bl	80024c0 <HAL_GetTick>
 8001e9c:	1b40      	subs	r0, r0, r5
 8001e9e:	2802      	cmp	r0, #2
 8001ea0:	d84d      	bhi.n	8001f3e <HAL_RCC_OscConfig+0x18a>
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001ea2:	6823      	ldr	r3, [r4, #0]
 8001ea4:	019b      	lsls	r3, r3, #6
 8001ea6:	d4f7      	bmi.n	8001e98 <HAL_RCC_OscConfig+0xe4>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8001ea8:	2000      	movs	r0, #0
}
 8001eaa:	b003      	add	sp, #12
 8001eac:	bdf0      	pop	{r4, r5, r6, r7, pc}
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8001eae:	6963      	ldr	r3, [r4, #20]
 8001eb0:	2b00      	cmp	r3, #0
 8001eb2:	d055      	beq.n	8001f60 <HAL_RCC_OscConfig+0x1ac>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8001eb4:	4b74      	ldr	r3, [pc, #464]	; (8002088 <HAL_RCC_OscConfig+0x2d4>)
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001eb6:	4d70      	ldr	r5, [pc, #448]	; (8002078 <HAL_RCC_OscConfig+0x2c4>)

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8001eb8:	2201      	movs	r2, #1
 8001eba:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001ebc:	f000 fb00 	bl	80024c0 <HAL_GetTick>
 8001ec0:	4606      	mov	r6, r0
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001ec2:	e004      	b.n	8001ece <HAL_RCC_OscConfig+0x11a>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001ec4:	f000 fafc 	bl	80024c0 <HAL_GetTick>
 8001ec8:	1b80      	subs	r0, r0, r6
 8001eca:	2802      	cmp	r0, #2
 8001ecc:	d837      	bhi.n	8001f3e <HAL_RCC_OscConfig+0x18a>
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001ece:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8001ed0:	079f      	lsls	r7, r3, #30
 8001ed2:	d5f7      	bpl.n	8001ec4 <HAL_RCC_OscConfig+0x110>
 8001ed4:	6823      	ldr	r3, [r4, #0]
        }       
      } 
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8001ed6:	0759      	lsls	r1, r3, #29
 8001ed8:	d5ca      	bpl.n	8001e70 <HAL_RCC_OscConfig+0xbc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8001eda:	4b67      	ldr	r3, [pc, #412]	; (8002078 <HAL_RCC_OscConfig+0x2c4>)
    
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 8001edc:	4d6b      	ldr	r5, [pc, #428]	; (800208c <HAL_RCC_OscConfig+0x2d8>)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8001ede:	2200      	movs	r2, #0
 8001ee0:	9201      	str	r2, [sp, #4]
 8001ee2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001ee4:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001ee8:	641a      	str	r2, [r3, #64]	; 0x40
 8001eea:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001eec:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001ef0:	9301      	str	r3, [sp, #4]
 8001ef2:	9b01      	ldr	r3, [sp, #4]
    
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 8001ef4:	682b      	ldr	r3, [r5, #0]
 8001ef6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001efa:	602b      	str	r3, [r5, #0]
    
    /* Wait for Backup domain Write protection enable */
    tickstart = HAL_GetTick();
 8001efc:	f000 fae0 	bl	80024c0 <HAL_GetTick>
 8001f00:	4606      	mov	r6, r0
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8001f02:	e004      	b.n	8001f0e <HAL_RCC_OscConfig+0x15a>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8001f04:	f000 fadc 	bl	80024c0 <HAL_GetTick>
 8001f08:	1b80      	subs	r0, r0, r6
 8001f0a:	2802      	cmp	r0, #2
 8001f0c:	d817      	bhi.n	8001f3e <HAL_RCC_OscConfig+0x18a>
    PWR->CR |= PWR_CR_DBP;
    
    /* Wait for Backup domain Write protection enable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8001f0e:	682b      	ldr	r3, [r5, #0]
 8001f10:	05da      	lsls	r2, r3, #23
 8001f12:	d5f7      	bpl.n	8001f04 <HAL_RCC_OscConfig+0x150>
        return HAL_TIMEOUT;
      }      
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001f14:	4b5e      	ldr	r3, [pc, #376]	; (8002090 <HAL_RCC_OscConfig+0x2dc>)
 8001f16:	7a22      	ldrb	r2, [r4, #8]
 8001f18:	701a      	strb	r2, [r3, #0]
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8001f1a:	68a3      	ldr	r3, [r4, #8]
 8001f1c:	2b00      	cmp	r3, #0
 8001f1e:	f000 80c3 	beq.w	80020a8 <HAL_RCC_OscConfig+0x2f4>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001f22:	f000 facd 	bl	80024c0 <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001f26:	4d54      	ldr	r5, [pc, #336]	; (8002078 <HAL_RCC_OscConfig+0x2c4>)
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001f28:	4607      	mov	r7, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001f2a:	f241 3688 	movw	r6, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001f2e:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8001f30:	079b      	lsls	r3, r3, #30
 8001f32:	d49d      	bmi.n	8001e70 <HAL_RCC_OscConfig+0xbc>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001f34:	f000 fac4 	bl	80024c0 <HAL_GetTick>
 8001f38:	1bc0      	subs	r0, r0, r7
 8001f3a:	42b0      	cmp	r0, r6
 8001f3c:	d9f7      	bls.n	8001f2e <HAL_RCC_OscConfig+0x17a>
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 8001f3e:	2003      	movs	r0, #3
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 8001f40:	b003      	add	sp, #12
 8001f42:	bdf0      	pop	{r4, r5, r6, r7, pc}
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8001f44:	6852      	ldr	r2, [r2, #4]
 8001f46:	0256      	lsls	r6, r2, #9
 8001f48:	f53f af6b 	bmi.w	8001e22 <HAL_RCC_OscConfig+0x6e>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8001f4c:	4a4a      	ldr	r2, [pc, #296]	; (8002078 <HAL_RCC_OscConfig+0x2c4>)
 8001f4e:	6812      	ldr	r2, [r2, #0]
 8001f50:	0795      	lsls	r5, r2, #30
 8001f52:	d531      	bpl.n	8001fb8 <HAL_RCC_OscConfig+0x204>
 8001f54:	68e2      	ldr	r2, [r4, #12]
 8001f56:	2a01      	cmp	r2, #1
 8001f58:	d02e      	beq.n	8001fb8 <HAL_RCC_OscConfig+0x204>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
      {
        return HAL_ERROR;
 8001f5a:	2001      	movs	r0, #1
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 8001f5c:	b003      	add	sp, #12
 8001f5e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8001f60:	4a49      	ldr	r2, [pc, #292]	; (8002088 <HAL_RCC_OscConfig+0x2d4>)
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001f62:	4d45      	ldr	r5, [pc, #276]	; (8002078 <HAL_RCC_OscConfig+0x2c4>)
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8001f64:	6013      	str	r3, [r2, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001f66:	f000 faab 	bl	80024c0 <HAL_GetTick>
 8001f6a:	4606      	mov	r6, r0
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001f6c:	e004      	b.n	8001f78 <HAL_RCC_OscConfig+0x1c4>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001f6e:	f000 faa7 	bl	80024c0 <HAL_GetTick>
 8001f72:	1b80      	subs	r0, r0, r6
 8001f74:	2802      	cmp	r0, #2
 8001f76:	d8e2      	bhi.n	8001f3e <HAL_RCC_OscConfig+0x18a>
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001f78:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8001f7a:	0798      	lsls	r0, r3, #30
 8001f7c:	d4f7      	bmi.n	8001f6e <HAL_RCC_OscConfig+0x1ba>
 8001f7e:	e7a9      	b.n	8001ed4 <HAL_RCC_OscConfig+0x120>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001f80:	f000 fa9e 	bl	80024c0 <HAL_GetTick>

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001f84:	4d3c      	ldr	r5, [pc, #240]	; (8002078 <HAL_RCC_OscConfig+0x2c4>)
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001f86:	4606      	mov	r6, r0

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001f88:	e004      	b.n	8001f94 <HAL_RCC_OscConfig+0x1e0>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001f8a:	f000 fa99 	bl	80024c0 <HAL_GetTick>
 8001f8e:	1b80      	subs	r0, r0, r6
 8001f90:	2864      	cmp	r0, #100	; 0x64
 8001f92:	d8d4      	bhi.n	8001f3e <HAL_RCC_OscConfig+0x18a>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001f94:	682b      	ldr	r3, [r5, #0]
 8001f96:	039b      	lsls	r3, r3, #14
 8001f98:	d4f7      	bmi.n	8001f8a <HAL_RCC_OscConfig+0x1d6>
 8001f9a:	e733      	b.n	8001e04 <HAL_RCC_OscConfig+0x50>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8001f9c:	684a      	ldr	r2, [r1, #4]
 8001f9e:	0250      	lsls	r0, r2, #9
 8001fa0:	f57f af1b 	bpl.w	8001dda <HAL_RCC_OscConfig+0x26>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8001fa4:	4a34      	ldr	r2, [pc, #208]	; (8002078 <HAL_RCC_OscConfig+0x2c4>)
 8001fa6:	6812      	ldr	r2, [r2, #0]
 8001fa8:	0391      	lsls	r1, r2, #14
 8001faa:	f57f af2c 	bpl.w	8001e06 <HAL_RCC_OscConfig+0x52>
 8001fae:	6862      	ldr	r2, [r4, #4]
 8001fb0:	2a00      	cmp	r2, #0
 8001fb2:	f47f af28 	bne.w	8001e06 <HAL_RCC_OscConfig+0x52>
 8001fb6:	e7d0      	b.n	8001f5a <HAL_RCC_OscConfig+0x1a6>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001fb8:	4d2f      	ldr	r5, [pc, #188]	; (8002078 <HAL_RCC_OscConfig+0x2c4>)
 8001fba:	22f8      	movs	r2, #248	; 0xf8
 8001fbc:	6829      	ldr	r1, [r5, #0]
 8001fbe:	fa92 f2a2 	rbit	r2, r2
 8001fc2:	6920      	ldr	r0, [r4, #16]
 8001fc4:	fab2 f282 	clz	r2, r2
 8001fc8:	f021 01f8 	bic.w	r1, r1, #248	; 0xf8
 8001fcc:	fa00 f202 	lsl.w	r2, r0, r2
 8001fd0:	430a      	orrs	r2, r1
 8001fd2:	602a      	str	r2, [r5, #0]
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001fd4:	071a      	lsls	r2, r3, #28
 8001fd6:	f57f af49 	bpl.w	8001e6c <HAL_RCC_OscConfig+0xb8>
 8001fda:	e768      	b.n	8001eae <HAL_RCC_OscConfig+0xfa>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8001fdc:	4a28      	ldr	r2, [pc, #160]	; (8002080 <HAL_RCC_OscConfig+0x2cc>)

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001fde:	4d26      	ldr	r5, [pc, #152]	; (8002078 <HAL_RCC_OscConfig+0x2c4>)
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8001fe0:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001fe2:	f000 fa6d 	bl	80024c0 <HAL_GetTick>
 8001fe6:	4606      	mov	r6, r0
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001fe8:	e004      	b.n	8001ff4 <HAL_RCC_OscConfig+0x240>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8001fea:	f000 fa69 	bl	80024c0 <HAL_GetTick>
 8001fee:	1b80      	subs	r0, r0, r6
 8001ff0:	2802      	cmp	r0, #2
 8001ff2:	d8a4      	bhi.n	8001f3e <HAL_RCC_OscConfig+0x18a>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001ff4:	682b      	ldr	r3, [r5, #0]
 8001ff6:	0799      	lsls	r1, r3, #30
 8001ff8:	d4f7      	bmi.n	8001fea <HAL_RCC_OscConfig+0x236>
 8001ffa:	6823      	ldr	r3, [r4, #0]
 8001ffc:	e734      	b.n	8001e68 <HAL_RCC_OscConfig+0xb4>
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001ffe:	461d      	mov	r5, r3
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002000:	f000 fa5e 	bl	80024c0 <HAL_GetTick>
 8002004:	4606      	mov	r6, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8002006:	e004      	b.n	8002012 <HAL_RCC_OscConfig+0x25e>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8002008:	f000 fa5a 	bl	80024c0 <HAL_GetTick>
 800200c:	1b80      	subs	r0, r0, r6
 800200e:	2802      	cmp	r0, #2
 8002010:	d895      	bhi.n	8001f3e <HAL_RCC_OscConfig+0x18a>
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8002012:	682b      	ldr	r3, [r5, #0]
 8002014:	4a18      	ldr	r2, [pc, #96]	; (8002078 <HAL_RCC_OscConfig+0x2c4>)
 8002016:	0199      	lsls	r1, r3, #6
 8002018:	d4f6      	bmi.n	8002008 <HAL_RCC_OscConfig+0x254>
 800201a:	f647 76c0 	movw	r6, #32704	; 0x7fc0
 800201e:	fa96 f6a6 	rbit	r6, r6
 8002022:	f44f 3340 	mov.w	r3, #196608	; 0x30000
            return HAL_TIMEOUT;
          }
        }        

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8002026:	fab6 f786 	clz	r7, r6
 800202a:	fa93 f3a3 	rbit	r3, r3
 800202e:	f04f 6570 	mov.w	r5, #251658240	; 0xf000000
 8002032:	fab3 f383 	clz	r3, r3
 8002036:	fa95 f5a5 	rbit	r5, r5
 800203a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800203c:	6a66      	ldr	r6, [r4, #36]	; 0x24
 800203e:	f8d4 c01c 	ldr.w	ip, [r4, #28]
 8002042:	f8d4 e020 	ldr.w	lr, [r4, #32]
 8002046:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8002048:	0849      	lsrs	r1, r1, #1
 800204a:	40be      	lsls	r6, r7
 800204c:	3901      	subs	r1, #1
 800204e:	ea4c 070e 	orr.w	r7, ip, lr
 8002052:	fab5 f485 	clz	r4, r5
 8002056:	fa01 f303 	lsl.w	r3, r1, r3
 800205a:	ea47 0506 	orr.w	r5, r7, r6
 800205e:	fa00 f104 	lsl.w	r1, r0, r4
 8002062:	432b      	orrs	r3, r5
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << POSITION_VAL(RCC_PLLCFGR_PLLN))             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << POSITION_VAL(RCC_PLLCFGR_PLLP)) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << POSITION_VAL(RCC_PLLCFGR_PLLQ))));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8002064:	4807      	ldr	r0, [pc, #28]	; (8002084 <HAL_RCC_OscConfig+0x2d0>)
            return HAL_TIMEOUT;
          }
        }        

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8002066:	430b      	orrs	r3, r1
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << POSITION_VAL(RCC_PLLCFGR_PLLN))             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << POSITION_VAL(RCC_PLLCFGR_PLLP)) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << POSITION_VAL(RCC_PLLCFGR_PLLQ))));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8002068:	2101      	movs	r1, #1
            return HAL_TIMEOUT;
          }
        }        

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 800206a:	6053      	str	r3, [r2, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << POSITION_VAL(RCC_PLLCFGR_PLLN))             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << POSITION_VAL(RCC_PLLCFGR_PLLP)) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << POSITION_VAL(RCC_PLLCFGR_PLLQ))));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800206c:	6001      	str	r1, [r0, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800206e:	4614      	mov	r4, r2
                                 (RCC_OscInitStruct->PLL.PLLQ << POSITION_VAL(RCC_PLLCFGR_PLLQ))));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002070:	f000 fa26 	bl	80024c0 <HAL_GetTick>
 8002074:	4605      	mov	r5, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8002076:	e013      	b.n	80020a0 <HAL_RCC_OscConfig+0x2ec>
 8002078:	40023800 	.word	0x40023800
 800207c:	40023802 	.word	0x40023802
 8002080:	42470000 	.word	0x42470000
 8002084:	42470060 	.word	0x42470060
 8002088:	42470e80 	.word	0x42470e80
 800208c:	40007000 	.word	0x40007000
 8002090:	40023870 	.word	0x40023870
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8002094:	f000 fa14 	bl	80024c0 <HAL_GetTick>
 8002098:	1b40      	subs	r0, r0, r5
 800209a:	2802      	cmp	r0, #2
 800209c:	f63f af4f 	bhi.w	8001f3e <HAL_RCC_OscConfig+0x18a>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80020a0:	6823      	ldr	r3, [r4, #0]
 80020a2:	019a      	lsls	r2, r3, #6
 80020a4:	d5f6      	bpl.n	8002094 <HAL_RCC_OscConfig+0x2e0>
 80020a6:	e6ff      	b.n	8001ea8 <HAL_RCC_OscConfig+0xf4>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80020a8:	f000 fa0a 	bl	80024c0 <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80020ac:	4d06      	ldr	r5, [pc, #24]	; (80020c8 <HAL_RCC_OscConfig+0x314>)
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80020ae:	4607      	mov	r7, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80020b0:	f241 3688 	movw	r6, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80020b4:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80020b6:	0798      	lsls	r0, r3, #30
 80020b8:	f57f aeda 	bpl.w	8001e70 <HAL_RCC_OscConfig+0xbc>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80020bc:	f000 fa00 	bl	80024c0 <HAL_GetTick>
 80020c0:	1bc0      	subs	r0, r0, r7
 80020c2:	42b0      	cmp	r0, r6
 80020c4:	d9f6      	bls.n	80020b4 <HAL_RCC_OscConfig+0x300>
 80020c6:	e73a      	b.n	8001f3e <HAL_RCC_OscConfig+0x18a>
 80020c8:	40023800 	.word	0x40023800

080020cc <HAL_RCC_GetHCLKFreq>:
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
 80020cc:	4b01      	ldr	r3, [pc, #4]	; (80020d4 <HAL_RCC_GetHCLKFreq+0x8>)
}
 80020ce:	6818      	ldr	r0, [r3, #0]
 80020d0:	4770      	bx	lr
 80020d2:	bf00      	nop
 80020d4:	20000500 	.word	0x20000500

080020d8 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{  
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
 80020d8:	4b08      	ldr	r3, [pc, #32]	; (80020fc <HAL_RCC_GetPCLK1Freq+0x24>)
 80020da:	f44f 52e0 	mov.w	r2, #7168	; 0x1c00
 80020de:	689b      	ldr	r3, [r3, #8]
 80020e0:	fa92 f2a2 	rbit	r2, r2
 80020e4:	fab2 f282 	clz	r2, r2
 80020e8:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 80020ec:	40d3      	lsrs	r3, r2
 80020ee:	4904      	ldr	r1, [pc, #16]	; (8002100 <HAL_RCC_GetPCLK1Freq+0x28>)
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
 80020f0:	4a04      	ldr	r2, [pc, #16]	; (8002104 <HAL_RCC_GetPCLK1Freq+0x2c>)
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{  
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
 80020f2:	5ccb      	ldrb	r3, [r1, r3]
 80020f4:	6810      	ldr	r0, [r2, #0]
}
 80020f6:	40d8      	lsrs	r0, r3
 80020f8:	4770      	bx	lr
 80020fa:	bf00      	nop
 80020fc:	40023800 	.word	0x40023800
 8002100:	08002adc 	.word	0x08002adc
 8002104:	20000500 	.word	0x20000500

08002108 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
 8002108:	4b08      	ldr	r3, [pc, #32]	; (800212c <HAL_RCC_GetPCLK2Freq+0x24>)
 800210a:	f44f 4260 	mov.w	r2, #57344	; 0xe000
 800210e:	689b      	ldr	r3, [r3, #8]
 8002110:	fa92 f2a2 	rbit	r2, r2
 8002114:	fab2 f282 	clz	r2, r2
 8002118:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 800211c:	40d3      	lsrs	r3, r2
 800211e:	4904      	ldr	r1, [pc, #16]	; (8002130 <HAL_RCC_GetPCLK2Freq+0x28>)
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
 8002120:	4a04      	ldr	r2, [pc, #16]	; (8002134 <HAL_RCC_GetPCLK2Freq+0x2c>)
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
 8002122:	5ccb      	ldrb	r3, [r1, r3]
 8002124:	6810      	ldr	r0, [r2, #0]
} 
 8002126:	40d8      	lsrs	r0, r3
 8002128:	4770      	bx	lr
 800212a:	bf00      	nop
 800212c:	40023800 	.word	0x40023800
 8002130:	08002adc 	.word	0x08002adc
 8002134:	20000500 	.word	0x20000500

08002138 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8002138:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800213c:	f8df c1ec 	ldr.w	ip, [pc, #492]	; 800232c <HAL_GPIO_Init+0x1f4>
 8002140:	f8d1 e000 	ldr.w	lr, [r1]

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8002144:	f8df 81e8 	ldr.w	r8, [pc, #488]	; 8002330 <HAL_GPIO_Init+0x1f8>
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8002148:	4f71      	ldr	r7, [pc, #452]	; (8002310 <HAL_GPIO_Init+0x1d8>)
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800214a:	b083      	sub	sp, #12
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 800214c:	2600      	movs	r6, #0
 800214e:	e003      	b.n	8002158 <HAL_GPIO_Init+0x20>
 8002150:	3601      	adds	r6, #1
 8002152:	2e10      	cmp	r6, #16
 8002154:	f000 808e 	beq.w	8002274 <HAL_GPIO_Init+0x13c>
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
 8002158:	2301      	movs	r3, #1
 800215a:	40b3      	lsls	r3, r6
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
 800215c:	ea33 020e 	bics.w	r2, r3, lr
 8002160:	d1f6      	bne.n	8002150 <HAL_GPIO_Init+0x18>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8002162:	f8d1 9004 	ldr.w	r9, [r1, #4]
 8002166:	f029 0410 	bic.w	r4, r9, #16
 800216a:	2c02      	cmp	r4, #2
 800216c:	f000 8085 	beq.w	800227a <HAL_GPIO_Init+0x142>
 8002170:	ea4f 0a46 	mov.w	sl, r6, lsl #1
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8002174:	2203      	movs	r2, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8002176:	6805      	ldr	r5, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8002178:	fa02 f20a 	lsl.w	r2, r2, sl
 800217c:	43d2      	mvns	r2, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800217e:	f009 0b03 	and.w	fp, r9, #3
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8002182:	4015      	ands	r5, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8002184:	fa0b fb0a 	lsl.w	fp, fp, sl
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8002188:	3c01      	subs	r4, #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800218a:	ea4b 0505 	orr.w	r5, fp, r5
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800218e:	2c01      	cmp	r4, #1

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
      GPIOx->MODER = temp;
 8002190:	6005      	str	r5, [r0, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8002192:	f240 8094 	bls.w	80022be <HAL_GPIO_Init+0x186>
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
        GPIOx->OTYPER = temp;
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8002196:	68c5      	ldr	r5, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8002198:	688c      	ldr	r4, [r1, #8]
        GPIOx->OTYPER = temp;
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 800219a:	402a      	ands	r2, r5
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 800219c:	fa04 f40a 	lsl.w	r4, r4, sl
 80021a0:	4322      	orrs	r2, r4
      GPIOx->PUPDR = temp;

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80021a2:	f019 5f80 	tst.w	r9, #268435456	; 0x10000000

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
      temp |= ((GPIO_Init->Pull) << (position * 2U));
      GPIOx->PUPDR = temp;
 80021a6:	60c2      	str	r2, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80021a8:	d0d2      	beq.n	8002150 <HAL_GPIO_Init+0x18>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80021aa:	2200      	movs	r2, #0
 80021ac:	9201      	str	r2, [sp, #4]
 80021ae:	f8dc 4044 	ldr.w	r4, [ip, #68]	; 0x44
 80021b2:	f444 4480 	orr.w	r4, r4, #16384	; 0x4000
 80021b6:	f8cc 4044 	str.w	r4, [ip, #68]	; 0x44
 80021ba:	f8dc 4044 	ldr.w	r4, [ip, #68]	; 0x44
 80021be:	f026 0503 	bic.w	r5, r6, #3
 80021c2:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 80021c6:	f404 4480 	and.w	r4, r4, #16384	; 0x4000
 80021ca:	f505 359c 	add.w	r5, r5, #79872	; 0x13800
 80021ce:	9401      	str	r4, [sp, #4]

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 80021d0:	f006 0b03 	and.w	fp, r6, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80021d4:	9c01      	ldr	r4, [sp, #4]

        temp = SYSCFG->EXTICR[position >> 2U];
 80021d6:	f8d5 a008 	ldr.w	sl, [r5, #8]
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 80021da:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 80021de:	240f      	movs	r4, #15
 80021e0:	fa04 f40b 	lsl.w	r4, r4, fp
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80021e4:	4540      	cmp	r0, r8
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 80021e6:	ea2a 0a04 	bic.w	sl, sl, r4
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80021ea:	d01d      	beq.n	8002228 <HAL_GPIO_Init+0xf0>
 80021ec:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 80021f0:	f502 3201 	add.w	r2, r2, #132096	; 0x20400
 80021f4:	4290      	cmp	r0, r2
 80021f6:	d072      	beq.n	80022de <HAL_GPIO_Init+0x1a6>
 80021f8:	4a46      	ldr	r2, [pc, #280]	; (8002314 <HAL_GPIO_Init+0x1dc>)
 80021fa:	4290      	cmp	r0, r2
 80021fc:	d073      	beq.n	80022e6 <HAL_GPIO_Init+0x1ae>
 80021fe:	4a46      	ldr	r2, [pc, #280]	; (8002318 <HAL_GPIO_Init+0x1e0>)
 8002200:	4290      	cmp	r0, r2
 8002202:	d074      	beq.n	80022ee <HAL_GPIO_Init+0x1b6>
 8002204:	4a45      	ldr	r2, [pc, #276]	; (800231c <HAL_GPIO_Init+0x1e4>)
 8002206:	4290      	cmp	r0, r2
 8002208:	d075      	beq.n	80022f6 <HAL_GPIO_Init+0x1be>
 800220a:	4a45      	ldr	r2, [pc, #276]	; (8002320 <HAL_GPIO_Init+0x1e8>)
 800220c:	4290      	cmp	r0, r2
 800220e:	d076      	beq.n	80022fe <HAL_GPIO_Init+0x1c6>
 8002210:	4a44      	ldr	r2, [pc, #272]	; (8002324 <HAL_GPIO_Init+0x1ec>)
 8002212:	4290      	cmp	r0, r2
 8002214:	d077      	beq.n	8002306 <HAL_GPIO_Init+0x1ce>
 8002216:	4a44      	ldr	r2, [pc, #272]	; (8002328 <HAL_GPIO_Init+0x1f0>)
 8002218:	4290      	cmp	r0, r2
 800221a:	bf0b      	itete	eq
 800221c:	2207      	moveq	r2, #7
 800221e:	2408      	movne	r4, #8
 8002220:	fa02 f20b 	lsleq.w	r2, r2, fp
 8002224:	fa04 f20b 	lslne.w	r2, r4, fp
 8002228:	ea4a 0202 	orr.w	r2, sl, r2
        SYSCFG->EXTICR[position >> 2U] = temp;
 800222c:	60aa      	str	r2, [r5, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 800222e:	683a      	ldr	r2, [r7, #0]
        temp &= ~((uint32_t)iocurrent);
 8002230:	43dc      	mvns	r4, r3
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8002232:	f419 3f80 	tst.w	r9, #65536	; 0x10000
        {
          temp |= iocurrent;
 8002236:	bf14      	ite	ne
 8002238:	431a      	orrne	r2, r3
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
 800223a:	4022      	andeq	r2, r4
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
        }
        EXTI->IMR = temp;
 800223c:	603a      	str	r2, [r7, #0]

        temp = EXTI->EMR;
 800223e:	687a      	ldr	r2, [r7, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8002240:	f419 3f00 	tst.w	r9, #131072	; 0x20000
        {
          temp |= iocurrent;
 8002244:	bf14      	ite	ne
 8002246:	431a      	orrne	r2, r3
          temp |= iocurrent;
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
 8002248:	4022      	andeq	r2, r4
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
        }
        EXTI->EMR = temp;
 800224a:	607a      	str	r2, [r7, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800224c:	68ba      	ldr	r2, [r7, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800224e:	f419 1f80 	tst.w	r9, #1048576	; 0x100000
        {
          temp |= iocurrent;
 8002252:	bf14      	ite	ne
 8002254:	431a      	orrne	r2, r3
        }
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
 8002256:	4022      	andeq	r2, r4
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;
 8002258:	60ba      	str	r2, [r7, #8]

        temp = EXTI->FTSR;
 800225a:	68fa      	ldr	r2, [r7, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800225c:	f419 1f00 	tst.w	r9, #2097152	; 0x200000
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8002260:	f106 0601 	add.w	r6, r6, #1
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
 8002264:	bf0c      	ite	eq
 8002266:	ea04 0302 	andeq.w	r3, r4, r2
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
 800226a:	4313      	orrne	r3, r2
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 800226c:	2e10      	cmp	r6, #16
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
        }
        EXTI->FTSR = temp;
 800226e:	60fb      	str	r3, [r7, #12]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8002270:	f47f af72 	bne.w	8002158 <HAL_GPIO_Init+0x20>
        }
        EXTI->FTSR = temp;
      }
    }
  }
}
 8002274:	b003      	add	sp, #12
 8002276:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800227a:	ea4f 0ad6 	mov.w	sl, r6, lsr #3
 800227e:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 8002282:	f006 0407 	and.w	r4, r6, #7
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8002286:	f8da 5020 	ldr.w	r5, [sl, #32]
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
 800228a:	690a      	ldr	r2, [r1, #16]
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 800228c:	00a4      	lsls	r4, r4, #2
 800228e:	f04f 0b0f 	mov.w	fp, #15
 8002292:	fa0b fb04 	lsl.w	fp, fp, r4
 8002296:	ea25 050b 	bic.w	r5, r5, fp
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
 800229a:	40a2      	lsls	r2, r4
 800229c:	432a      	orrs	r2, r5
        GPIOx->AFR[position >> 3U] = temp;
 800229e:	f8ca 2020 	str.w	r2, [sl, #32]
 80022a2:	ea4f 0a46 	mov.w	sl, r6, lsl #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80022a6:	2203      	movs	r2, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 80022a8:	6804      	ldr	r4, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80022aa:	fa02 f20a 	lsl.w	r2, r2, sl
 80022ae:	43d2      	mvns	r2, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80022b0:	f009 0503 	and.w	r5, r9, #3
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80022b4:	4014      	ands	r4, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80022b6:	fa05 f50a 	lsl.w	r5, r5, sl
 80022ba:	432c      	orrs	r4, r5
      GPIOx->MODER = temp;
 80022bc:	6004      	str	r4, [r0, #0]
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 80022be:	6884      	ldr	r4, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
        temp |= (GPIO_Init->Speed << (position * 2U));
 80022c0:	68cd      	ldr	r5, [r1, #12]
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 80022c2:	4014      	ands	r4, r2
        temp |= (GPIO_Init->Speed << (position * 2U));
 80022c4:	fa05 f50a 	lsl.w	r5, r5, sl
 80022c8:	4325      	orrs	r5, r4
        GPIOx->OSPEEDR = temp;
 80022ca:	6085      	str	r5, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 80022cc:	6844      	ldr	r4, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 80022ce:	f3c9 1500 	ubfx	r5, r9, #4, #1
        temp |= (GPIO_Init->Speed << (position * 2U));
        GPIOx->OSPEEDR = temp;

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80022d2:	ea24 0403 	bic.w	r4, r4, r3
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 80022d6:	40b5      	lsls	r5, r6
 80022d8:	432c      	orrs	r4, r5
        GPIOx->OTYPER = temp;
 80022da:	6044      	str	r4, [r0, #4]
 80022dc:	e75b      	b.n	8002196 <HAL_GPIO_Init+0x5e>
 80022de:	2201      	movs	r2, #1
 80022e0:	fa02 f20b 	lsl.w	r2, r2, fp
 80022e4:	e7a0      	b.n	8002228 <HAL_GPIO_Init+0xf0>
 80022e6:	2202      	movs	r2, #2
 80022e8:	fa02 f20b 	lsl.w	r2, r2, fp
 80022ec:	e79c      	b.n	8002228 <HAL_GPIO_Init+0xf0>
 80022ee:	2203      	movs	r2, #3
 80022f0:	fa02 f20b 	lsl.w	r2, r2, fp
 80022f4:	e798      	b.n	8002228 <HAL_GPIO_Init+0xf0>
 80022f6:	2204      	movs	r2, #4
 80022f8:	fa02 f20b 	lsl.w	r2, r2, fp
 80022fc:	e794      	b.n	8002228 <HAL_GPIO_Init+0xf0>
 80022fe:	2205      	movs	r2, #5
 8002300:	fa02 f20b 	lsl.w	r2, r2, fp
 8002304:	e790      	b.n	8002228 <HAL_GPIO_Init+0xf0>
 8002306:	2206      	movs	r2, #6
 8002308:	fa02 f20b 	lsl.w	r2, r2, fp
 800230c:	e78c      	b.n	8002228 <HAL_GPIO_Init+0xf0>
 800230e:	bf00      	nop
 8002310:	40013c00 	.word	0x40013c00
 8002314:	40020800 	.word	0x40020800
 8002318:	40020c00 	.word	0x40020c00
 800231c:	40021000 	.word	0x40021000
 8002320:	40021400 	.word	0x40021400
 8002324:	40021800 	.word	0x40021800
 8002328:	40021c00 	.word	0x40021c00
 800232c:	40023800 	.word	0x40023800
 8002330:	40020000 	.word	0x40020000

08002334 <HAL_DMA_Abort_IT>:
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8002334:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8002338:	2b02      	cmp	r3, #2
 800233a:	d003      	beq.n	8002344 <HAL_DMA_Abort_IT+0x10>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 800233c:	2380      	movs	r3, #128	; 0x80
 800233e:	6543      	str	r3, [r0, #84]	; 0x54
    return HAL_ERROR;
 8002340:	2001      	movs	r0, #1
 8002342:	4770      	bx	lr
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 8002344:	6802      	ldr	r2, [r0, #0]
    return HAL_ERROR;
  }
  else
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
 8002346:	2305      	movs	r3, #5
 8002348:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 800234c:	6813      	ldr	r3, [r2, #0]
 800234e:	f023 0301 	bic.w	r3, r3, #1
 8002352:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 8002354:	2000      	movs	r0, #0
}
 8002356:	4770      	bx	lr

08002358 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8002358:	4a07      	ldr	r2, [pc, #28]	; (8002378 <HAL_NVIC_SetPriorityGrouping+0x20>)
 800235a:	68d1      	ldr	r1, [r2, #12]
 800235c:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8002360:	400b      	ands	r3, r1
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8002362:	0200      	lsls	r0, r0, #8
 8002364:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8002368:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
 800236c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8002370:	4303      	orrs	r3, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8002372:	60d3      	str	r3, [r2, #12]
 8002374:	4770      	bx	lr
 8002376:	bf00      	nop
 8002378:	e000ed00 	.word	0xe000ed00

0800237c <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800237c:	4b19      	ldr	r3, [pc, #100]	; (80023e4 <HAL_NVIC_SetPriority+0x68>)
 800237e:	68db      	ldr	r3, [r3, #12]
 8002380:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8002384:	b430      	push	{r4, r5}
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8002386:	f1c3 0507 	rsb	r5, r3, #7
 800238a:	2d04      	cmp	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800238c:	f103 0404 	add.w	r4, r3, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8002390:	bf28      	it	cs
 8002392:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8002394:	2c06      	cmp	r4, #6
 8002396:	d918      	bls.n	80023ca <HAL_NVIC_SetPriority+0x4e>
 8002398:	3b03      	subs	r3, #3
 800239a:	2401      	movs	r4, #1
 800239c:	409c      	lsls	r4, r3
 800239e:	3c01      	subs	r4, #1
 80023a0:	4022      	ands	r2, r4

  return (
 80023a2:	2401      	movs	r4, #1
 80023a4:	40ac      	lsls	r4, r5
 80023a6:	3c01      	subs	r4, #1
 80023a8:	4021      	ands	r1, r4
 80023aa:	fa01 f303 	lsl.w	r3, r1, r3
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 80023ae:	2800      	cmp	r0, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 80023b0:	ea42 0203 	orr.w	r2, r2, r3
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 80023b4:	db0c      	blt.n	80023d0 <HAL_NVIC_SetPriority+0x54>
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80023b6:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 80023ba:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 80023be:	0112      	lsls	r2, r2, #4
 80023c0:	b2d2      	uxtb	r2, r2
 80023c2:	f880 2300 	strb.w	r2, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 80023c6:	bc30      	pop	{r4, r5}
 80023c8:	4770      	bx	lr
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80023ca:	2200      	movs	r2, #0
 80023cc:	4613      	mov	r3, r2
 80023ce:	e7e8      	b.n	80023a2 <HAL_NVIC_SetPriority+0x26>
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80023d0:	4b05      	ldr	r3, [pc, #20]	; (80023e8 <HAL_NVIC_SetPriority+0x6c>)
 80023d2:	f000 000f 	and.w	r0, r0, #15
 80023d6:	0112      	lsls	r2, r2, #4
 80023d8:	4403      	add	r3, r0
 80023da:	b2d2      	uxtb	r2, r2
 80023dc:	761a      	strb	r2, [r3, #24]
 80023de:	bc30      	pop	{r4, r5}
 80023e0:	4770      	bx	lr
 80023e2:	bf00      	nop
 80023e4:	e000ed00 	.word	0xe000ed00
 80023e8:	e000ecfc 	.word	0xe000ecfc

080023ec <HAL_NVIC_EnableIRQ>:
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80023ec:	f000 011f 	and.w	r1, r0, #31
 80023f0:	2301      	movs	r3, #1
 80023f2:	0940      	lsrs	r0, r0, #5
 80023f4:	4a02      	ldr	r2, [pc, #8]	; (8002400 <HAL_NVIC_EnableIRQ+0x14>)
 80023f6:	408b      	lsls	r3, r1
 80023f8:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
 80023fc:	4770      	bx	lr
 80023fe:	bf00      	nop
 8002400:	e000e100 	.word	0xe000e100

08002404 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8002404:	3801      	subs	r0, #1
 8002406:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 800240a:	d20e      	bcs.n	800242a <HAL_SYSTICK_Config+0x26>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800240c:	4b08      	ldr	r3, [pc, #32]	; (8002430 <HAL_SYSTICK_Config+0x2c>)
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800240e:	b410      	push	{r4}
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002410:	4c08      	ldr	r4, [pc, #32]	; (8002434 <HAL_SYSTICK_Config+0x30>)
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8002412:	6058      	str	r0, [r3, #4]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002414:	20f0      	movs	r0, #240	; 0xf0
 8002416:	f884 0023 	strb.w	r0, [r4, #35]	; 0x23
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800241a:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800241c:	2107      	movs	r1, #7
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800241e:	4610      	mov	r0, r2
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8002420:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8002422:	6019      	str	r1, [r3, #0]
   return SysTick_Config(TicksNumb);
}
 8002424:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002428:	4770      	bx	lr
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
 800242a:	2001      	movs	r0, #1
 800242c:	4770      	bx	lr
 800242e:	bf00      	nop
 8002430:	e000e010 	.word	0xe000e010
 8002434:	e000ed00 	.word	0xe000ed00

08002438 <HAL_SYSTICK_CLKSourceConfig>:
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8002438:	4a04      	ldr	r2, [pc, #16]	; (800244c <HAL_SYSTICK_CLKSourceConfig+0x14>)
 800243a:	6813      	ldr	r3, [r2, #0]
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 800243c:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 800243e:	bf0c      	ite	eq
 8002440:	f043 0304 	orreq.w	r3, r3, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 8002444:	f023 0304 	bicne.w	r3, r3, #4
 8002448:	6013      	str	r3, [r2, #0]
 800244a:	4770      	bx	lr
 800244c:	e000e010 	.word	0xe000e010

08002450 <HAL_InitTick>:
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000U);
 8002450:	4b08      	ldr	r3, [pc, #32]	; (8002474 <HAL_InitTick+0x24>)
 8002452:	4a09      	ldr	r2, [pc, #36]	; (8002478 <HAL_InitTick+0x28>)
 8002454:	681b      	ldr	r3, [r3, #0]
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8002456:	b510      	push	{r4, lr}
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000U);
 8002458:	fba2 2303 	umull	r2, r3, r2, r3
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800245c:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000U);
 800245e:	0998      	lsrs	r0, r3, #6
 8002460:	f7ff ffd0 	bl	8002404 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0U);
 8002464:	4621      	mov	r1, r4
 8002466:	2200      	movs	r2, #0
 8002468:	f04f 30ff 	mov.w	r0, #4294967295
 800246c:	f7ff ff86 	bl	800237c <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 8002470:	2000      	movs	r0, #0
 8002472:	bd10      	pop	{r4, pc}
 8002474:	20000500 	.word	0x20000500
 8002478:	10624dd3 	.word	0x10624dd3

0800247c <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 800247c:	b508      	push	{r3, lr}
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 800247e:	4b0b      	ldr	r3, [pc, #44]	; (80024ac <HAL_Init+0x30>)
 8002480:	681a      	ldr	r2, [r3, #0]
 8002482:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8002486:	601a      	str	r2, [r3, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
 8002488:	681a      	ldr	r2, [r3, #0]
 800248a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800248e:	601a      	str	r2, [r3, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8002490:	681a      	ldr	r2, [r3, #0]
 8002492:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8002496:	601a      	str	r2, [r3, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8002498:	2003      	movs	r0, #3
 800249a:	f7ff ff5d 	bl	8002358 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 800249e:	200f      	movs	r0, #15
 80024a0:	f7ff ffd6 	bl	8002450 <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 80024a4:	f7fe fa92 	bl	80009cc <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
}
 80024a8:	2000      	movs	r0, #0
 80024aa:	bd08      	pop	{r3, pc}
 80024ac:	40023c00 	.word	0x40023c00

080024b0 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 80024b0:	4a02      	ldr	r2, [pc, #8]	; (80024bc <HAL_IncTick+0xc>)
 80024b2:	6813      	ldr	r3, [r2, #0]
 80024b4:	3301      	adds	r3, #1
 80024b6:	6013      	str	r3, [r2, #0]
 80024b8:	4770      	bx	lr
 80024ba:	bf00      	nop
 80024bc:	20000940 	.word	0x20000940

080024c0 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80024c0:	4b01      	ldr	r3, [pc, #4]	; (80024c8 <HAL_GetTick+0x8>)
 80024c2:	6818      	ldr	r0, [r3, #0]
}
 80024c4:	4770      	bx	lr
 80024c6:	bf00      	nop
 80024c8:	20000940 	.word	0x20000940

080024cc <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 80024cc:	b510      	push	{r4, lr}
 80024ce:	b082      	sub	sp, #8
 80024d0:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = 0U;
  tickstart = HAL_GetTick();
 80024d2:	f7ff fff5 	bl	80024c0 <HAL_GetTick>
 80024d6:	4604      	mov	r4, r0
  while((HAL_GetTick() - tickstart) < Delay)
 80024d8:	f7ff fff2 	bl	80024c0 <HAL_GetTick>
 80024dc:	9b01      	ldr	r3, [sp, #4]
 80024de:	1b00      	subs	r0, r0, r4
 80024e0:	4298      	cmp	r0, r3
 80024e2:	d3f9      	bcc.n	80024d8 <HAL_Delay+0xc>
  {
  }
}
 80024e4:	b002      	add	sp, #8
 80024e6:	bd10      	pop	{r4, pc}

080024e8 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 80024e8:	4910      	ldr	r1, [pc, #64]	; (800252c <SystemInit+0x44>)
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80024ea:	4b11      	ldr	r3, [pc, #68]	; (8002530 <SystemInit+0x48>)
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 80024ec:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80024f0:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 80024f4:	b410      	push	{r4}
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 80024f6:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80024fa:	681a      	ldr	r2, [r3, #0]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80024fc:	4c0d      	ldr	r4, [pc, #52]	; (8002534 <SystemInit+0x4c>)
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 80024fe:	2000      	movs	r0, #0
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8002500:	f042 0201 	orr.w	r2, r2, #1
 8002504:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8002506:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8002508:	681a      	ldr	r2, [r3, #0]
 800250a:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 800250e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002512:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8002514:	605c      	str	r4, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8002516:	681a      	ldr	r2, [r3, #0]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8002518:	f04f 6400 	mov.w	r4, #134217728	; 0x8000000

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800251c:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8002520:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8002522:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8002524:	608c      	str	r4, [r1, #8]
#endif
}
 8002526:	f85d 4b04 	ldr.w	r4, [sp], #4
 800252a:	4770      	bx	lr
 800252c:	e000ed00 	.word	0xe000ed00
 8002530:	40023800 	.word	0x40023800
 8002534:	24003010 	.word	0x24003010

08002538 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 8002538:	f8df d034 	ldr.w	sp, [pc, #52]	; 8002570 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 800253c:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800253e:	e003      	b.n	8002548 <LoopCopyDataInit>

08002540 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8002540:	4b0c      	ldr	r3, [pc, #48]	; (8002574 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 8002542:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8002544:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8002546:	3104      	adds	r1, #4

08002548 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8002548:	480b      	ldr	r0, [pc, #44]	; (8002578 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 800254a:	4b0c      	ldr	r3, [pc, #48]	; (800257c <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 800254c:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800254e:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8002550:	d3f6      	bcc.n	8002540 <CopyDataInit>
  ldr  r2, =_sbss
 8002552:	4a0b      	ldr	r2, [pc, #44]	; (8002580 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8002554:	e002      	b.n	800255c <LoopFillZerobss>

08002556 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8002556:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8002558:	f842 3b04 	str.w	r3, [r2], #4

0800255c <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800255c:	4b09      	ldr	r3, [pc, #36]	; (8002584 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 800255e:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8002560:	d3f9      	bcc.n	8002556 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 8002562:	f7ff ffc1 	bl	80024e8 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8002566:	f000 f811 	bl	800258c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800256a:	f7fe fe6f 	bl	800124c <main>
  bx  lr    
 800256e:	4770      	bx	lr

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 8002570:	20020000 	.word	0x20020000
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 8002574:	08002af4 	.word	0x08002af4
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8002578:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 800257c:	20000504 	.word	0x20000504
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 8002580:	20000504 	.word	0x20000504
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8002584:	20000944 	.word	0x20000944

08002588 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8002588:	e7fe      	b.n	8002588 <ADC_IRQHandler>
	...

0800258c <__libc_init_array>:
 800258c:	b570      	push	{r4, r5, r6, lr}
 800258e:	4b0e      	ldr	r3, [pc, #56]	; (80025c8 <__libc_init_array+0x3c>)
 8002590:	4c0e      	ldr	r4, [pc, #56]	; (80025cc <__libc_init_array+0x40>)
 8002592:	1ae4      	subs	r4, r4, r3
 8002594:	10a4      	asrs	r4, r4, #2
 8002596:	2500      	movs	r5, #0
 8002598:	461e      	mov	r6, r3
 800259a:	42a5      	cmp	r5, r4
 800259c:	d004      	beq.n	80025a8 <__libc_init_array+0x1c>
 800259e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80025a2:	4798      	blx	r3
 80025a4:	3501      	adds	r5, #1
 80025a6:	e7f8      	b.n	800259a <__libc_init_array+0xe>
 80025a8:	f000 f816 	bl	80025d8 <_init>
 80025ac:	4c08      	ldr	r4, [pc, #32]	; (80025d0 <__libc_init_array+0x44>)
 80025ae:	4b09      	ldr	r3, [pc, #36]	; (80025d4 <__libc_init_array+0x48>)
 80025b0:	1ae4      	subs	r4, r4, r3
 80025b2:	10a4      	asrs	r4, r4, #2
 80025b4:	2500      	movs	r5, #0
 80025b6:	461e      	mov	r6, r3
 80025b8:	42a5      	cmp	r5, r4
 80025ba:	d004      	beq.n	80025c6 <__libc_init_array+0x3a>
 80025bc:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80025c0:	4798      	blx	r3
 80025c2:	3501      	adds	r5, #1
 80025c4:	e7f8      	b.n	80025b8 <__libc_init_array+0x2c>
 80025c6:	bd70      	pop	{r4, r5, r6, pc}
 80025c8:	08002aec 	.word	0x08002aec
 80025cc:	08002aec 	.word	0x08002aec
 80025d0:	08002af0 	.word	0x08002af0
 80025d4:	08002aec 	.word	0x08002aec

080025d8 <_init>:
 80025d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80025da:	bf00      	nop
 80025dc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80025de:	bc08      	pop	{r3}
 80025e0:	469e      	mov	lr, r3
 80025e2:	4770      	bx	lr

080025e4 <_fini>:
 80025e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80025e6:	bf00      	nop
 80025e8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80025ea:	bc08      	pop	{r3}
 80025ec:	469e      	mov	lr, r3
 80025ee:	4770      	bx	lr
